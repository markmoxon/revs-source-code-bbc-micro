\ ******************************************************************************
\
\ REVS SOURCE
\
\ Revs was written by Geoffrey J Crammond and is copyright Acornsoft 1985
\
\ The code on this site has been disassembled from the original game discs
\
\ The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
\ in the documentation are entirely my fault
\
\ The terminology and notations used in this commentary are explained at
\ https://revs.bbcelite.com/about_site/terminology_used_in_this_commentary.html
\
\ The deep dive articles referred to in this commentary can be found at
\ https://revs.bbcelite.com/deep_dives
\
\ ------------------------------------------------------------------------------
\
\ This source file produces the following binary file:
\
\   * Revs.bin
\
\ ******************************************************************************

INCLUDE "1-source-files/main-sources/revs-header.h.asm"

_ACORNSOFT              = (_VARIANT = 1)
_SUPERIOR               = (_VARIANT = 2)

GUARD &8000             \ Guard against assembling over sideways ROMs

\ ******************************************************************************
\
\ Configuration variables
\
\ ******************************************************************************

IRQ1V = &0204           \ The IRQ1V vector that we intercept to implement the
                        \ screen mode

VIA = &FE00             \ Memory-mapped space for accessing internal hardware,
                        \ such as the video ULA, 6845 CRTC and 6522 VIAs (also
                        \ known as SHEILA)

OSRDCH = &FFE0          \ The address for the OSRDCH routine
OSWRCH = &FFEE          \ The address for the OSWRCH routine
OSBYTE = &FFF4          \ The address for the OSBYTE routine
OSWORD = &FFF1          \ The address for the OSWORD routine

CODE% = &0B00           \ The address of the main game code

LOAD% = &1200           \ The load address of the main code binary

LOAD_END% = &7000       \ The address of the end of the main code binary

dashData = &3000        \ The address of the first code block that gets swapped
                        \ in and out of screen memory, along with parts of the
                        \ dashboard image

trackLoad = &70DB       \ The load address of the track data file

trackChecksum = &7800   \ The address of the checksums in the track data file
                        \ after it is loaded but before it is moved in memory

                        \ The following configuration variables represent screen
                        \ addresses for the custom screen

tyreLeft1 = &6E85       \ The tread on the left tyre in screen memory
tyreLeft2 = &6E8A
tyreLeft3 = &6FC0

tyreRight1 = &6FB2      \ The tread on the right tyre in screen memory
tyreRight2 = &6FBD
tyreRight3 = &70F8

L713D = &713D           \ A point in the track view next to the left tyre

L7205 = &7205           \ A point in the track view next to the right tyre

mirror0 = &7540         \ Mirror 0 base address (left mirror, outer segment)
mirror1 = &7548         \ Mirror 1 base address (left mirror, middle segment)
mirror2 = &7418         \ Mirror 2 base address (left mirror, inner segment)

mirror3 = &7530         \ Mirror 3 base address (right mirror, inner segment)
mirror4 = &7670         \ Mirror 4 base address (right mirror, middle segment)
mirror5 = &7678         \ Mirror 5 base address (right mirror, outer segment)

assistLeft1 = &77DB     \ Centre-bottom of dashboard in screen memory for
assistLeft2 = &77DC     \ showing the Computer Assisted Steering (CAS)
assistRight1 = &77E3    \ indicator
assistRight2 = &77E4

                        \ The following configuration variables represent screen
                        \ addresses for mode 7

row2_column1 = &7C79    \ Chequered flag mode 7 screen address
row18_column5 = &7E85   \ The first entry's number in a mode 7 menu
row24_column5 = &7FC5   \ Location of "PRESS SPACE BAR TO CONTINUE" prompt

\ ******************************************************************************
\
\       Name: Zero page
\       Type: Workspace
\    Address: &0070 to &008F
\   Category: Workspaces
\    Summary: Mainly temporary variables that are used a lot
\
\ ******************************************************************************

ORG &0000

.playerMoving

 SKIP 1                 \ Flag to denote whether the player's car is moving
                        \
                        \   * 0 = player's car is not moving
                        \
                        \   * Non-zero = player's car is moving

.thisSectionFlags

 SKIP 1                 \ The track section flags for the current track section

.thisVectorNumber

 SKIP 1                 \ The number of the track vector for the current track
                        \ segment, ready to store in the track segment buffer
                        \ as segmentVector

.currentPosition

 SKIP 1                 \ The position of the current player
                        \
                        \ This refers to the current player's position in the
                        \ driversInOrder list

.thisSectionNumber

 SKIP 1                 \ The number * 8 of the current section number when
                        \ calculating the track verges

.L0005

 SKIP 1                 \ 

.L0006

 SKIP 1                 \ 
                        \
                        \ Set to 6 in ResetVariables

.L0007

 SKIP 1                 \ 

.L0008

 SKIP 1                 \ 
                        \
                        \ Set to 6 in ResetVariables

.L0009

 SKIP 1                 \ 
                        \
                        \ Set to 7 in ResetVariables

.playerRotationLo

 SKIP 1                 \ Low byte of the player's rotation about the y-axis
                        \ (left-right rotation)

.playerRotationHi

 SKIP 1                 \ High byte of the player's rotation about the y-axis
                        \ (left-right rotation)

.yStore1

 SKIP 1                 \ Temporary storage for Y

.L000D

 SKIP 1                 \ 

.L000E

 SKIP 1                 \ 

.leaveTrackTimer

 SKIP 1                 \ The leave track timer
                        \
                        \ When set to a non-zero figure, the timer starts to
                        \ count down by one every iteration of the main loop,
                        \ until it reaches 1, at which point we leave the track
                        \
                        \ During the countdown we are unable to accelerate or
                        \ brake, but can steer

.L0010

 SKIP 1                 \ 

.L0011

 SKIP 1                 \ 

.L0012

 SKIP 1                 \ 

.L0013

 SKIP 1                 \ 

.L0014

 SKIP 1                 \ 

.L0015

 SKIP 1                 \ 

.previousRacingLine

 SKIP 1                 \ The previous value of bestRacingLine when calculating
                        \ the best racing line for a track segment

.turnCounter

 SKIP 1                 \ A counter for the length of turn when calculating the
                        \ best racing line for a track segment

.previousSpeed

 SKIP 1                 \ The previous value of trackDriverSpeed when
                        \ calculating the best racing line for a track segment

.gearChange

 SKIP 1                 \ Used to store the direction of the gear change
                        \
                        \   * 1 = change up
                        \
                        \   * 0 = no gear change
                        \
                        \   * -1 = change down

.L001A

 SKIP 1                 \ 

.thisObjectIndex

 SKIP 0                 \ The index of the current object part's data as we work
                        \ our way through an object's constituent parts

.rowCounter

 SKIP 1                 \ The table row number when printing the driver tables

.pressingShiftArrow

 SKIP 1                 \ Bit 7 is set if we are pressing SHIFT and right arrow
                        \ (which restarts the game)

.thisPosition

 SKIP 1                 \ The position of the car that we are analysing in the
                        \ MoveAndDrawCars routine

.L001E

 SKIP 1                 \ 

.horizonLine

 SKIP 1                 \ The track line number of the horizon
                        \
                        \ Track lines are one pixel high, and go from 79 (at the
                        \ top of the track view, in the sky), down to 3 (the
                        \ lowest track line, between the mirrors and dashboard)

.previousSpeed7

 SKIP 1                 \ The previous value of trackDriverSpeed when
                        \ calculating the best racing line for a track segment,
                        \ only used for accessing bit 7

.sectionBehind

 SKIP 1                 \ Used to store the number * 8 of the track section
                        \ behind us when we drive backwards along the track
                        \
                        \ Track sections are numbered from 0 to 23, so this
                        \ ranges from 0 to 184

.segmentIndex96

 SKIP 1                 \ Contains segmentIndex - 96

.segmentIndexPrev

 SKIP 1                 \ Used to store the index * 3 of the previous track
                        \ segment

.segmentIndex

 SKIP 1                 \ Used to store the index * 3 of the current track
                        \ segment
                        \
                        \ Track segment indexes are numbered from 0 to 39, so
                        \ this ranges from 0 to 117

.directionFacing

 SKIP 1                 \ The direction that our car is facing
                        \
                        \   * Bit 7 clear = facing forwards
                        \
                        \   * Bit 7 set = facing backwards

.L0026

 SKIP 1                 \ 

.L0027

 SKIP 1                 \ 

.L0028

 SKIP 1                 \ 

.L0029

 SKIP 1                 \ 

.scaleUp

 SKIP 1                 \ The nominator scale factor for scaling an object
                        \ scaffold (i.e. scale up)
                        \
                        \ The scaffold is multiplied by scaleUp

.scaleDown

 SKIP 1                 \ The denominator scale factor for scaling an object
                        \ scaffold (i.e. scale down)
                        \
                        \ The scaffold is divided by 2^scaleDown

.L002C

 SKIP 1                 \ 

.L002D

 SKIP 1                 \ 

.speedLo

 SKIP 1                 \ Low byte of the car's speed
                        \
                        \ In mph? This looks like the fractional part

.positionChangeBCD

 SKIP 1                 \ Some kind of delta in BCD for the player's race
                        \ position ???
                        \
                        \ Gets added to currentPositionBCD when non-zero
                        \
                        \ Set to the current player's position in BCD in
                        \ ResetVariables

.pastHalfway

 SKIP 1                 \ Stores which half of the track the player is in
                        \
                        \   * 0 = the first half of the track
                        \
                        \   * 1 = the second half of the track
                        \
                        \ The halfway point is defined as the middle track
                        \ section, or if there is an odd number of track
                        \ sections, the section before the middle track section
                        \
                        \ Set to 1 in ResetVariables

.currentPositionBCD

 SKIP 1                 \ The current race position in BCD
                        \
                        \ Displayed at the top of the screen after "Position"

.L0032

 SKIP 1                 \ 

.L0033

 SKIP 1                 \ 

.L0034

 SKIP 1                 \ 

.xCoord

 SKIP 1                 \ The pixel x-coordinate of the centre of the current
                        \ object
                        \
                        \ In terms of screen coordinates, so 0 is the left edge
                        \ of the screen, 80 is the centre and 159 is the right
                        \ edge

.yCoord

 SKIP 1                 \ The pixel y-coordinate of the centre of the current
                        \ object
                        \
                        \ In terms of track lines, so 80 is the top of the track
                        \ view and 0 is the bottom of the track view

.objectType

 SKIP 1                 \ The type of object to draw (0 to 12)
                        \
                        \   * 0 = Four-object car, front tyres
                        \   * 1 = Four-object car, body and helmet
                        \   * 2 = Four-object car, rear tyres
                        \   * 3 = Four-object car, rear wing
                        \   * 4 = Standard car
                        \   * 5 = Distant car
                        \   * 6 = Corner marker
                        \   * 7 = Straight sign
                        \   * 8 = Start flag
                        \   * 9 = Blank road sign
                        \   * 10 = Chicane road sign
                        \   * 11 = Right turn road sign
                        \   * 12 = Left turn road sign

.var15Lo

 SKIP 1                 \ 

.var15Hi

 SKIP 1                 \ 

.var16Lo

 SKIP 1                 \ 

.var16Hi

 SKIP 1                 \ 

.revCount

 SKIP 1                 \ The current rev count, as shown on the rev counter

.L003D

 SKIP 1                 \ 

.throttleBrakeState

 SKIP 1                 \ Denotes whether the throttle or brake are being
                        \ applied
                        \
                        \   * Bit 7 is set if there is no brake or throttle key
                        \     press
                        \
                        \   * 0 = brakes are being applied
                        \
                        \   * 1 = throttle is being applied

.throttleBrake

 SKIP 1                 \ The amount of throttle or brake being applied

.gearNumber

 SKIP 1                 \ The current gear number
                        \
                        \  * 0 = reverse
                        \
                        \  * 1 = neutral
                        \
                        \  * 2-7 = 1 to 5

.objectDistanceLo

 SKIP 1                 \ The low byte of the distance to the current object

.colourScheme

 SKIP 0                 \ The number of the table colour scheme passed to the
                        \ SetRowColours routine:
                        \
                        \ Scheme 0: Even rows: 132 on 134 (blue on cyan)
                        \           Odd rows:  134 on 135 (cyan on white)
                        \
                        \ Scheme 4: Even rows: 129 on 132 (red on blue)
                        \           Odd rows:  131 on 130 (yellow on green)
                        \
                        \ Scheme 8: Even rows: 131 on 132 (yellow on blue)
                        \           Odd rows:  129 on 135 (red on white)

.objectNumber

 SKIP 0                 \ The object number of the four-part car we are drawing

.segmentCounter

 SKIP 0                 \ A counter for the track segment we are processing

.temp2

 SKIP 0                 \ Temporary storage

.L0042

 SKIP 1                 \ 

.L0043

 SKIP 1                 \ 

.L0044

 SKIP 1                 \ 

.driverPrinted

 SKIP 0                 \ The number of the driver we just printed in the
                        \ PrintPositionName routine

.thisDriver

 SKIP 0                 \ The number of the car we are currently drawing

.xStore2

 SKIP 0                 \ Temporary storage for X so it can be preserved through
                        \ calls to DrawCarInPosition and DrawCarOrSign

.temp4

 SKIP 0                 \ Temporary storage

.L0045

 SKIP 1                 \ 

.timerAdjust

 SKIP 1                 \ A counter for implementing the clock speed adjustment
                        \
                        \ Starts out with the value of trackTimerAdjust from the
                        \ track data (see the ProcessTime routine)
                        \
                        \ Gets decremented on each iteration of the main driving
                        \ loop, looping back to trackTimerAdjust after reaching
                        \ zero
                        \
                        \ When timerAdjust matches equals trackTimerAdjust, the
                        \ clock timer adds 18/100 of a second rather than the
                        \ usual 9/100 of a second, so the clock timer speeds up
                        \ every time the counter loops round
                        \
                        \ Decreasing the value of trackTimerAdjust therefore
                        \ speeds up the clock timer, allowing the speed of the
                        \ clock timer to be adjusted on a per-track basis
                        \
                        \ The Silverstone track has a trackTimerAdjust value of
                        \ 24, so timerAdjust wraps around from 0 to 24

.bottomTrackLine

 SKIP 1                 \ The bottom track line for the current object part

.prevEdgeInByte

 SKIP 1                 \ Determines whether we are drawing two edges within the
                        \ same pixel byte in DrawObjectEdge

.L0049

 SKIP 1                 \ 

.setSpeedForDriver

 SKIP 1                 \ The driver whose speed will be set on the next call to
                        \ the SetDriverSpeed routine

.L004B

 SKIP 1                 \ 

.L004C

 SKIP 1                 \ 

.positionAhead

 SKIP 1                 \ The number of the position ahead of the current
                        \ player's position
                        \
                        \ This refers to the current player's position in the
                        \ driversInOrder list
                        \
                        \ The position ahead of the leader is last place

.L004E

 SKIP 1                 \ 

.L004F

 SKIP 1                 \ 

.L0050

 SKIP 1                 \ 

.L0051

 SKIP 1                 \ 

.L0052

 SKIP 1                 \ 

.L0053

 SKIP 1                 \ 

.L0054

 SKIP 1                 \ 

.objectDistanceHi

 SKIP 1                 \ The high byte of the distance to the current object
                        \
                        \ If a car's objectDistanceHi is >= 5, then it is drawn
                        \ as a distant car

.temp1

 SKIP 1                 \ Temporary storage

.markersToDraw

 SKIP 1                 \ The number of corner markers to draw

.gearChangeKey

 SKIP 1                 \ Determines whether or not a gear change key has been
                        \ pressed
                        \
                        \   * Bit 7 set = a gear change key has been pressed

.L0059

 SKIP 1                 \ 

.L005A

 SKIP 1                 \ 

.positionBehind

 SKIP 1                 \ The number of the position behind the current player's
                        \ position
                        \
                        \ This refers to the current player's position in the
                        \ driversInOrder list
                        \
                        \ The position behind last place is the leader

.L005C

 SKIP 1                 \ 

.L005D

 SKIP 1                 \ 

.L005E

 SKIP 1                 \ 

.soundRevTarget

 SKIP 1                 \ The target pitch for the revs sound
                        \
                        \ The pitch for the revs sound moves towards this pitch
                        \ level one step at a time, to simulate the sound of the
                        \ engine "catching up" to the throttle
                        \
                        \ The target pitch is set to revCount + 25

.soundRevCount

 SKIP 1                 \ The current pitch for the revs sound

.engineStatus

 SKIP 1                 \ Whether or not the engine is on
                        \
                        \   * 0 = engine is off
                        \
                        \   * &FF = engine is on

.L0062

 SKIP 1                 \ 

.speedHi

 SKIP 1                 \ High byte of the car's speed
                        \
                        \ In mph? This looks like the integer part

.printMode

 SKIP 1                 \ Determines how the next character is printed
                        \ on-screen:
                        \
                        \  * 0 = poke the character directly into screen memory
                        \
                        \  * 1 = print the character with OSWRCH (for mode 7)

.qualifyTimeEnding

 SKIP 1                 \ Determines whether the time warnings have been shown
                        \ at the end of the qualifying time:
                        \
                        \   * Bit 6 set = the one-minute warning has been shown
                        \
                        \   * Bit 7 set = the time-up watning has been shown

.updateDrivingInfo

 SKIP 1                 \ Determines which parts of the driving information
                        \ should be updated at the top of the screen
                        \
                        \   * Bit 7 set = update lap number (during a race)
                        \                 update lap time (practice/qualifying)
                        \
                        \   * Bit 6 set = we are driving the first practice or
                        \                 qualifying lap, so do not update the
                        \                 best lap time
                        \
                        \ Set to %10000000 in ResetVariables for race laps only

.collisionDriver

 SKIP 1                 \ The number of the driver being hit by the player's car

.processContact

 SKIP 1                 \ Another car is close enough to the player's car for us
                        \ to process car-on-car contact
                        \
                        \   * 0 = no car is close enough
                        \
                        \   * Non-zero = a car is close enough to check for
                        \                contact

.lineBufferSize

 SKIP 1                 \ The size of the line buffer
                        \
                        \ Zeroed in SetupGame

.mainLoopCounterLo

 SKIP 1                 \ Low byte of the main loop counter, which increments on
                        \ each iteration of the main driving loop
                        \
                        \ Stored as a 16-bit value (mainLoopCounterHi
                        \ mainLoopCounterLo)

.startingStack

 SKIP 1                 \ The value of the stack pointer when the game starts,
                        \ so we can restore it when restarting the game

.raceStarted

 SKIP 1                 \ Flag determining whether the race has started
                        \
                        \   * Bit 7 clear = this is practice or a qualifying lap
                        \
                        \   * Bit 7 set = the race has started

.raceStarting

 SKIP 1                 \ The current stage of the starting lights at the start
                        \ of the race
                        \
                        \ When a race is about to start, raceStarting is set to
                        \ 128, and stays on this value until the engine is
                        \ started, at which point it starts to count down, with
                        \ one tick per iteration of the main loop, working
                        \ through the following sequence:
                        \
                        \   * 128 = show black lights, engine not yet started
                        \
                        \   * Start counting down from 240 once engine starts
                        \
                        \   * 240-192 = show black lights
                        \
                        \   * 191-161 = show blue lights
                        \
                        \   * 160 = keep showing blue lights and stop counting
                        \           down until main loop counter is a multiple
                        \           of 64
                        \
                        \   * Start counting down from 40 once loop counter is
                        \     a multiple of 64
                        \
                        \   * 40-1 = show green lights
                        \
                        \   * 0 = show no lights (race has started)
                        \
                        \ When bit 7 is set (i.e. raceStarting >= 128), we are
                        \ on the grid, so we do not increment the clock timer in
                        \ ProcessTime, and the MoveCars routine has no effect

.numberOfLaps

 SKIP 1                 \ The number of laps in the race (5, 10 or 20)

.currentPlayer

 SKIP 1                 \ The number of the current player
                        \
                        \   * 0 for practice
                        \
                        \   * 0 to 19 for competition

.P

 SKIP 1                 \ Temporary storage, used in a number of places

.Q

 SKIP 1                 \ Temporary storage, used in a number of places

.R

 SKIP 1                 \ Temporary storage, used in a number of places

.S

 SKIP 1                 \ Temporary storage, used in a number of places

.T

 SKIP 1                 \ Temporary storage, used in a number of places

.U

 SKIP 1                 \ Temporary storage, used in a number of places

.edgePixel

 SKIP 0                 \ The current edge, as a one-pixel byte

.V

 SKIP 1                 \ Temporary storage, used in a number of places

.W

 SKIP 1                 \ Temporary storage, used in a number of places

.leftOfEdge

 SKIP 0                 \ The fill colour to the left of the edge we are drawing

.G

 SKIP 1                 \ Temporary storage, used in a number of places

.rightOfEdge

 SKIP 0                 \ The fill colour to the right of the edge we are
                        \ drawing

.H

 SKIP 1                 \ Temporary storage, used in a number of places

.I

 SKIP 1                 \ Temporary storage, used in a number of places

.J

 SKIP 1                 \ Temporary storage, used in a number of places

.prevBlockNumber

 SKIP 0                 \ The dash data block number for the previous edge

.K

 SKIP 1                 \ Temporary storage, used in a number of places

.L

 SKIP 1                 \ Temporary storage, used in a number of places

.thisEdge

 SKIP 0                 \ The current edge that we are drawing as part of an
                        \ object part

.M

 SKIP 1                 \ Temporary storage, used in a number of places

.topTrackLine

 SKIP 0                 \ The top track line for the current object part

.N

 SKIP 1                 \ Temporary storage, used in a number of places

.PP

 SKIP 1                 \ Temporary storage, used in a number of places

.QQ

 SKIP 1                 \ Temporary storage, used in a number of places

.blockOffset

 SKIP 0                 \ The dash data offset for the current edge

.RR

 SKIP 1                 \ Temporary storage, used in a number of places

.nextEdge

 SKIP 0                 \ The next edge that we are drawing as part of an
                        \ object part (where applicable)

.SS

 SKIP 1                 \ Temporary storage, used in a number of places

.colourData

 SKIP 0                 \ Colour data for the current object part

.TT

 SKIP 1                 \ Temporary storage, used in a number of places

.blockNumber

 SKIP 0                 \ The dash data block number for the current edge

.UU

 SKIP 1                 \ Temporary storage, used in a number of places

.VV

 SKIP 1                 \ Temporary storage, used in a number of places

.WW

 SKIP 1                 \ Temporary storage, used in a number of places

.GG

 SKIP 1                 \ Temporary storage, used in a number of places

.HH

 SKIP 1                 \ This byte does not appear to benused

.II

 SKIP 1                 \ Temporary storage, used in a number of places

.JJ

 SKIP 1                 \ Temporary storage, used in a number of places

.edgePixelMask

 SKIP 0                 \ The pixel mask for the previous edge

.KK

 SKIP 1                 \ Temporary storage, used in a number of places

.nextBlockNumber

 SKIP 0                 \ The dash data block number for the next edge

.LL

 SKIP 1                 \ Temporary storage, used in a number of places

.MM

 SKIP 1                 \ Temporary storage, used in a number of places

.nextEdgeCoord

 SKIP 0                 \ The x-coordinate for the next edge

.NN

 SKIP 1                 \ Temporary storage, used in a number of places

\ ******************************************************************************
\
\       Name: Stack variables
\       Type: Workspace
\    Address: &0100 to &0175
\   Category: Workspaces
\    Summary: Variables that share page 1 with the stack
\
\ ******************************************************************************

ORG &0100

.positionNumber

 SKIP 0                 \ Position numbers to show in the first column of the
                        \ driver table

.carStatus

 SKIP 20                \ Each car's status byte
                        \
                        \   * Bit 0 = update this carStatus byte when applying
                        \             tactics in the ApplyDriverTactics routine
                        \
                        \       * Clear = do update carStatus
                        \
                        \       * Set = do not update carStatus
                        \
                        \   * Bit 4 = affects driving round corners for visible
                        \             cars (see BuildVisibleCar)
                        \
                        \       * Clear = follow the segment's steering line in
                        \                 segmentSteering when going fast enough
                        \                 (carSpeedHi >= 50)
                        \
                        \       * Set = do not follow the segment's steering
                        \               line in segmentSteering
                        \
                        \   * Bit 6 = acceleration status
                        \
                        \       * Clear = do not acclerate car
                        \
                        \       * Set = acclerate car
                        \
                        \   * Bit 7 = braking status
                        \
                        \       * Clear = do not apply brakes
                        \
                        \       * Set = apply brakes

.carSteering

 SKIP 20                \ Contains the steering to apply to each car
                        \
                        \   * Bits 0-5 = the amount of steering as a positive
                        \                value (0 to 31)
                        \
                        \   * Bit 6 = controls whether to apply steering in the
                        \             MoveCars routine
                        \
                        \       * Clear = apply steering
                        \
                        \       * Set = do not apply steering
                        \
                        \   * Bit 7 = the direction of the steering
                        \
                        \       * Clear = steer left
                        \
                        \       * Set = steer right
                        \
                        \ The steering is stored as a sign-magnitude number,
                        \ where the sign is in bit 7 and the magnitude is in
                        \ bits 0-5
                        \
                        \ The amount is in terms of the racing line, where the
                        \ width of the track is 256, so steering by 26 would
                        \ steer the car sideways by 10% of the track width

.driverSpeed

 SKIP 20                \ The average speed of this driver in the race (88 to
                        \ 162)
                        \
                        \ The speed for each driver depends on a number of
                        \ factors, and is calculated in the SetDriverSpeed
                        \ routine
                        \
                        \ Indexed by driver number (0 to 19)

.driversInOrder

 SKIP 20                \ A list of driver numbers in order
                        \
                        \ For example, during a race, this contains the race
                        \ position of each driver in the race (i.e. first place,
                        \ second place etc.)
                        \
                        \ It is also used to sort drivers by lap time and points
                        \ for the driver table
                        \
                        \ Indexed by driver number (0 to 19)
                        \
                        \ Gets set in InitialiseDrivers to the number of each
                        \ driver, so the initial order is driver number

.carSpeedHi

 SKIP 20                \ High byte of each car's forward speed
                        \
                        \ Stored as an 8-bit value (carSpeedHi carSpeedLo)

.carProgress

 SKIP 20                \ Lowest byte of each car's progress around the track
                        \
                        \ This is effectively a fractional part of the car's
                        \ progress around the track, from the starting line
                        \
                        \ When this byte rolls over, we increment the car's
                        \ (objProgressHi objProgressLo), so it's effectively
                        \ (objProgressHi objProgressLo carProgress)

.carRacingLine

 SKIP 20                \ Each car's position on the track in the x-axis
                        \
                        \ This determines how far each car is to the left or
                        \ right on the track - i.e. it's the car's racing line
                        \
                        \   * 0 is full right
                        \
                        \   * 128 is the centre line
                        \
                        \   * 255 is full left
                        \
                        \ Bit 7 is therefore set if the car is in the left half
                        \ the track, and clear for the right half

.objectStatus

 SKIP 24                \ Various status flags for each object
                        \
                        \   * Bits 0-3 = the object type
                        \
                        \   * Bit 6: 0 = the car is still racing
                        \            1 = the car has finished the race
                        \
                        \   * Bit 7: 0 = object is visible
                        \            1 = object is hidden
                        \
                        \ Set to &80 in ResetVariables

.carSectionSpeed

 SKIP 20                \ Set to the driver speed for the next track section,
                        \ which is taken from the track data and used to set the
                        \ section's approach speed for non-player drivers
                        \
                        \ Only applies to sections with bit 7 of the flag byte
                        \ set, in which case carSectionSpeed is set to the
                        \ trackDriverSpeed value from the preceding track 
                        \ section
                        \
                        \ Set to 255 in ResetVariables, which means no minimum
                        \ speed

\ ******************************************************************************
\
\       Name: Main variable workspace
\       Type: Workspace
\    Address: &0380 to &07F8 and &0880 to &0AFF
\   Category: Workspaces
\    Summary: The main block of game variables
\
\ ******************************************************************************

ORG &0380

.objRotationLo

 SKIP 24                \ Low byte of each object's rotation about the y-axis
                        \ (left-right rotation)

.objRotationHi

 SKIP 24                \ High byte of each object's rotation about the y-axis
                        \ (left-right rotation)

.objElevation

 SKIP 24                \ Each object's elevation angle (up-down)

.objectScaleUp

 SKIP 24                \ The scaleUp factor for each of the objects (i.e. the
                        \ object's size)

 SKIP 32                \ These bytes appear to be unused

.L0400

 SKIP 80                \ 

.L0450

 SKIP 80                \ 

.driverGridRow

 SKIP 20                \ The grid row for each driver (0 to 9)
                        \
                        \ There are two cars per grid row, with grid row 0 at
                        \ the front including the car in pole position
                        \
                        \ There are 20 cars, in rows 0 to 9
                        \
                        \ Indexed by driver number (0 to 19)
                        \
                        \ Gets set in InitialiseDrivers

.driverLapNumber

 SKIP 20                \ The current lap number for each driver
                        \
                        \ Indexed by driver number (0 to 19)

.driversInOrder2

 SKIP 20                \ Used to store a copy of the driversInOrder list

.totalRaceMinutes

 SKIP 20                \ Minutes of each driver's total race time, stored in
                        \ BCD
                        \
                        \ Set to &80 in ResetVariables

.totalPointsTop

 SKIP 20                \ Top byte of total accumulated points for each driver
                        \
                        \ Indexed by driver number (0 to 19)
                        \
                        \ Gets set to 0 in InitialiseDrivers
                        \
                        \ Stored as a 24-bit value (totalPointsTop totalPointsHi
                        \ totalPointsLo)

.tyreRightEdge

 SKIP 80                \ Storage for the first track pixel byte along the right
                        \ edge of the left tyre
                        \
                        \ This table is used to store the track pixel byte that
                        \ would be shown along the edge of the left tyre, but
                        \ which is partially obscured by the edge
                        \
                        \ This is stored so we can retrieve it when masking the
                        \ pixel byte with the tyre edge when we draw the track
                        \ line that starts at the edge of the left tyre
                        \
                        \ There is a byte for each track line from 43 (the track
                        \ line at the top of the dashboard) down to line 3 (the
                        \ lowest track line, just above where the wing mirror
                        \ joins the car body)
                        \
                        \ Lines 0 to 2 are not used

.rightGrassStart

 SKIP 80                \ For each track line, the block number where the grass
                        \ starts to the right of the track

.leftVergeStart

 SKIP 80                \ For each track line, the block number where the left
                        \ track verge starts

.configStop

 SKIP 1                 \ A key has been pressed that stops the race
                        \
                        \   * Bit 5 set = retire from race/lap
                        \     (SHIFT-f7 pressed)
                        \
                        \   * Bit 7 and bit 6 set = pit stop
                        \     (SHIFT-f0 pressed)
                        \
                        \   * Bit 7 set and bit 6 clear = restart game
                        \     (SHIFT and right arrow pressed)
                        \
                        \ Zeroed in SetupGame

.configJoystick

 SKIP 1                 \ A key has been pressed to set joystick or keyboard
                        \
                        \   * No bits set = keyboard
                        \     (SHIFT-f1 pressed)
                        \
                        \   * Bit 7 set = joystick
                        \     (SHIFT-f2 pressed)
                        \
                        \ Zeroed in SetupGame

.configVolume

 SKIP 1                 \ A key has been pressed to change the volume
                        \
                        \   * Bit 7 and bit 6 set = volume down
                        \     (SHIFT-f4 pressed)
                        \
                        \   * Bit 7 clear and bit 6 set = volume up
                        \     (SHIFT-f5 pressed)
                        \
                        \ Zeroed in SetupGame

.configPause

 SKIP 1                 \ A key has been pressed to pause the game
                        \
                        \   * Bit 7 set = pause game
                        \     (COPY pressed)
                        \
                        \   * Bit 6 set = unpause game
                        \     (DELETE pressed)
                        \
                        \ Zeroed in SetupGame

.configAssist

 SKIP 1                 \ A key has been pressed to toggle Computer Assisted
                        \ Steering (CAS)
                        \
                        \   * No bits set = disable Computer Assisted Steering
                        \     (SHIFT-f3 pressed)
                        \
                        \   * Bit 7 set = enable Computer Assisted Steering
                        \     (SHIFT-f6 pressed)
                        \
                        \ Zeroed in SetupGame

 SKIP 5                 \ These bytes appear to be unused

.volumeLevel

 SKIP 1                 \ The game's volume level
                        \
                        \ This uses the operating system's volume scale, with
                        \ -15 being full volume and 0 being silent
                        \
                        \ Set to -10 (246) in SetupGame

 SKIP 1                 \ This byte appears to be unused

.rightVergeStart

 SKIP 80                \ For each track line, the block number where the right
                        \ track verge starts

.leftTrackStart

 SKIP 80                \ For each track line, the block number where the track
                        \ starts (i.e. the left edge of the black track)

.bestLapTenths

 SKIP 20                \ Tenths of seconds of each driver's best lap time,
                        \ stored in BCD
                        \
                        \ Indexed by driver number (0 to 19)

.clockTenths

 SKIP 1                 \ Tenths of seconds for the clock timer
                        \
                        \ The clock timer counts the time spent on the track, so
                        \ that's the total amount of qualifying time, or the
                        \ time spent throughout an entire race

.lapTenths

 SKIP 1                 \ Tenths of seconds for the lap timer
                        \
                        \ The lap timer counts the time spent on the current lap

 SKIP 2                 \ These bytes appear to be unused

.bestLapSeconds

 SKIP 20                \ Seconds of each driver's best lap time, stored in BCD
                        \
                        \ Indexed by driver number (0 to 19)

.clockSeconds

 SKIP 1                 \ Seconds for the clock timer
                        \
                        \ The clock timer counts the time spent on the track, so
                        \ that's the total amount of qualifying time, or the
                        \ time spent throughout an entire race

.lapSeconds

 SKIP 1                 \ Seconds for the lap timer
                        \
                        \ The lap timer counts the time spent on the current lap

 SKIP 2                 \ These bytes appear to be unused

.bestLapMinutes

 SKIP 20                \ Minutes of each driver's best lap time, stored in BCD
                        \
                        \ Indexed by driver number (0 to 19)

.clockMinutes

 SKIP 1                 \ Minutes for the clock timer
                        \
                        \ The clock timer counts the time spent on the track, so
                        \ that's the total amount of qualifying time, or the
                        \ time spent throughout an entire race

.lapMinutes

 SKIP 1                 \ Minutes for the lap timer
                        \
                        \ The lap timer counts the time spent on the current lap

 SKIP 2                 \ These bytes appear to be unused

.objTrackSection

 SKIP 24                \ The number of the track section * 8 for each object
                        \
                        \ In the Silverstone track there are 24 track sections
                        \ numbered from 0 to 23, so this ranges from 0 to 184

.segmentVector

 SKIP 1                 \ The track vector number for a track segment in the
                        \ track segment buffer

.segmentSteering

 SKIP 1                 \ The carSteering value to steer round the corner for a
                        \ track segment in the track segment buffer
                        \
                        \ The various bits are as for carSteering:
                        \
                        \   * Bits 0-5 = the amount of steering as a positive
                        \                value (0 to 31)
                        \
                        \   * Bit 6 = controls whether to apply steering in the
                        \             MoveCars routine
                        \
                        \       * Clear = apply steering
                        \
                        \       * Set = do not apply steering
                        \
                        \   * Bit 7 = the direction of the steering
                        \
                        \       * Clear = steer left
                        \
                        \       * Set = steer right
                        
.segmentFlags

 SKIP 1                 \ Section flags based on trackSectionFlag for a track
                        \ segment in the track segment buffer

 SKIP 39 * 3            \ The track segment buffer contains data for 40 track
                        \ segments, with three bytes per segment, so this
                        \ reserves space for the other 39

 SKIP 8                 \ These bytes appear to be unused

.lineBufferPixel

 SKIP 40                \ The original screen contents of each pixel in the line
                        \ buffer

.lineBufferAddrLo

 SKIP 40                \ The low byte of the screen address of each pixel in
                        \ the line buffer

.lineBufferAddrHi

 SKIP 40                \ The low byte of the screen address of each pixel in
                        \ the line buffer

ORG &0880

.objSectionCount

 SKIP 24                \ Each object's progress within the current track
                        \ section, counting from the start of the section
                        \
                        \ Increments along with objProgressLo as the object
                        \ moves through the section, until it reaches the
                        \ section's trackSectionSize (the section's length),
                        \ at which point it resets to zero for the next section

.totalRaceTenths

 SKIP 20                \ Tenths of seconds of each driver's total race time,
                        \ stored in BCD
                        \
                        \ Indexed by driver number (0 to 19)

.totalRaceSeconds

 SKIP 20                \ Seconds of each driver's total race time, stored in
                        \ BCD
                        \
                        \ Indexed by driver number (0 to 19)

 SKIP 16                \ These bytes appear to be unused

.objProgressLo

 SKIP 24                \ Low byte of each object's progress around the track
                        \
                        \ This is the object's position on the track, in terms
                        \ of progress from the starting line, and is typically
                        \ used for car objects
                        \
                        \ It is zero when the car is on the starting line, and
                        \ goes up to (trackLengthHi trackLengthLo) as the car
                        \ progresses round the track, before resetting to zero
                        \ again at the end
                        \
                        \ Set to (trackPracticeHi trackPracticeLo) in
                        \ ResetVariables
                        \
                        \ For the Silverstone track, objProgress is initialised
                        \ to &034B and has a maximum value of &0400
                        \
                        \ Stored as a 16-bit value (objProgressHi objProgressLo)

.objProgressHi

 SKIP 24                \ High byte of each object's progress around the track
                        \
                        \ This is the object's position on the track, in terms
                        \ of progress from the starting line, and is typically
                        \ used for car objects
                        \
                        \ It is zero when the car is on the starting line, and
                        \ goes up to (trackLengthHi trackLengthLo) as the car
                        \ progresses round the track, before resetting to zero
                        \ again at the end
                        \
                        \ Set to (trackPracticeHi trackPracticeLo) in
                        \ ResetVariables
                        \
                        \ For the Silverstone track, objProgress is initialised
                        \ to &034B and has a maximum value of &0400
                        \
                        \ Stored as a 16-bit value (objProgressHi objProgressLo)

.xSegmentCoordILo

 SKIP 1                 \ The low byte of the 3D x-coordinate for an inner track
                        \ segment in the track segment buffer

.ySegmentCoordILo

 SKIP 1                 \ The low byte of the 3D y-coordinate for an inner track
                        \ segment in the track segment buffer

.zSegmentCoordILo

 SKIP 1                 \ The low byte of the 3D z-coordinate for an inner track
                        \ segment in the track segment buffer

 SKIP 39 * 3            \ The track segment buffer contains data for 40 track
                        \ segments, with three bytes per segment, so this
                        \ reserves space for the other 39

.xSegmentCoordOLo

 SKIP 1                 \ The low byte of the 3D x-coordinate for an outer track
                        \ segment in the track segment buffer

.ySegmentCoordOLo

 SKIP 1                 \ The low byte of the 3D y-coordinate for an outer track
                        \ segment in the track segment buffer

.zSegmentCoordOLo

 SKIP 1                 \ The low byte of the 3D z-coordinate for an outer track
                        \ segment in the track segment buffer

 SKIP 39 * 3            \ The track segment buffer contains data for 40 track
                        \ segments, with three bytes per segment, so this
                        \ reserves space for the other 39

 SKIP 4                 \ These bytes appear to be unused

.xVector7Lo

 SKIP 1

.yVector7Lo

 SKIP 1

.zVector7Lo

 SKIP 1

 SKIP 3                 \ These bytes appear to be unused

.xVector3Lo

 SKIP 1

.yVector3Lo

 SKIP 1

.zVector3Lo

 SKIP 1

.xVector4Lo

 SKIP 1

.yVector4Lo

 SKIP 1

.zVector4Lo

 SKIP 1

.xSegmentCoordIHi

 SKIP 1                 \ The high byte of the 3D x-coordinate for an inner
                        \ track segment in the track segment buffer

.ySegmentCoordIHi

 SKIP 1                 \ The high byte of the 3D y-coordinate for an inner
                        \ track segment in the track segment buffer

.zSegmentCoordIHi

 SKIP 1                 \ The high byte of the 3D z-coordinate for an inner
                        \ track segment in the track segment buffer

 SKIP 39 * 3            \ The track segment buffer contains data for 40 track
                        \ segments, with three bytes per segment, so this
                        \ reserves space for the other 39

.xSegmentCoordOHi

 SKIP 1                 \ The high byte of the 3D x-coordinate for an outer
                        \ track segment in the track segment buffer

.ySegmentCoordOHi

 SKIP 1                 \ The high byte of the 3D y-coordinate for an outer
                        \ track segment in the track segment buffer

.zSegmentCoordOHi

 SKIP 1                 \ The high byte of the 3D z-coordinate for an outer
                        \ track segment in the track segment buffer

 SKIP 39 * 3            \ The track segment buffer contains data for 40 track
                        \ segments, with three bytes per segment, so this
                        \ reserves space for the other 39

 SKIP 4                 \ These bytes appear to be unused

.xVector7Hi

 SKIP 1

.yVector7Hi

 SKIP 1

.zVector7Hi

 SKIP 1

 SKIP 3                 \ These bytes appear to be unused

.xVector3Hi

 SKIP 1

.yVector3Hi

 SKIP 1

.zVector3Hi

 SKIP 1

.xVector4Hi

 SKIP 1

.yVector4Hi

 SKIP 1

.zVector4Hi

 SKIP 1

\ ******************************************************************************
\
\ REVS MAIN GAME CODE
\
\ Produces the binary file Revs.bin that contains the main game code.
\
\ ******************************************************************************

\ ******************************************************************************
\
\       Name: Entry
\       Type: Subroutine
\   Category: Setup
\    Summary: The main entry point for the game: move code into upper memory and
\             call it
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

ORG &1200

.Entry

 LDY #0                 \ We start by copying the following block in memory:
                        \
                        \   * &1200-&12FF is copied to &7900-&79FF
                        \
                        \ so set up a byte counter in Y
.entr1

 LDA &1200,Y            \ Copy the Y-th byte of &1200 to the Y-th byte of &7900
 STA &7900,Y

 INY                    \ Increment the byte counter

 BNE entr1              \ Loop back until we have copied a whole page of bytes

 JMP SwapCode           \ Jump to the routine that we just moved to continue the
                        \ setup process

\ This code starts out at &1200 and is run there, before it moves itself to
\ &7900-&790D along with the rest of the page, so the following moves this code
\ next to the block that runs at &790E-&79FF

COPYBLOCK &1200, &120E, &7900
CLEAR &1200, &120E

\ ******************************************************************************
\
\       Name: SwapCode
\       Type: Subroutine
\   Category: Setup
\    Summary: Move the track data to the right place and run a checksum on it
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

ORG &790E

.SwapCode

 LDA #200               \ Call OSBYTE with A = 200, X = 3 and Y = 0 to disable
 LDX #3                 \ the ESCAPE key and clear memory if the BREAK key is
 LDY #0                 \ pressed
 JSR OSBYTE

 LDA #140               \ Call OSBYTE with A = 140 and X = 0 to select the tape
 LDX #0                 \ filing system (i.e. do a *TAPE command)
 JSR OSBYTE

                        \ We now want to move the track data from trackLoad
                        \ (which is where the loading process loads the track
                        \ file) to trackData (which is where the game expects
                        \ to find the track data)
                        \
                        \ At the same time, we also want to move the data that
                        \ is currently at trackData, which is part of the
                        \ dashboard image, into screen memory at trackLoad
                        \
                        \ trackLoad is &70DB and trackData is &5300, so we
                        \ want to do the following:
                        \
                        \   * Swap &70DB-&77FF and &5300-&5A24
                        \
                        \ At the same time, we want to perform a checksum on the
                        \ track data and compare the results with the four
                        \ checksum bytes in trackChecksum
                        \
                        \ The following does this in batches of 256 bytes, using
                        \ Y as an index that goes from 0 to 255. The checks are
                        \ done at the end of the loop, and they check the value
                        \ of Y first (against &25), and then the high byte of
                        \ the higher address (against &77) but only if the Y
                        \ test fails, so the swaps end up being:
                        \
                        \   * Swap &5300 + 0-255 with &70DB + 0-255
                        \   * Swap &5400 + 0-255 with &71DB + 0-255
                        \   * Swap &5500 + 0-255 with &72DB + 0-255
                        \   * Swap &5600 + 0-255 with &73DB + 0-255
                        \   * Swap &5700 + 0-255 with &74DB + 0-255
                        \   * Swap &5800 + 0-255 with &75DB + 0-255
                        \   * Swap &5900 + 0-255 with &76DB + 0-255
                        \   * Swap &5A00 + 0-&24 with &77DB + 0-&24
                        \
                        \ So the last operation swaps &5A24 and &77FF

 LDA #LO(trackData)     \ Set (Q P) = trackData
 STA P                  \
 LDA #HI(trackData)     \ so that's one address for the swap
 STA Q

 LDA #LO(trackLoad)     \ Set (S R) = trackLoad
 STA R                  \
 LDA #HI(trackLoad)     \ so that's the other address for the swap
 STA S

 LDY #0                 \ Set a byte counter in Y for the swap

.swap1

 LDA (R),Y              \ Swap the Y-th bytes of (Q P) and (S R)
 PHA
 LDA (P),Y
 STA (R),Y
 PLA
 STA (P),Y

 AND #3                 \ Decrement the relevant checksum byte
 TAX                    \
 DEC trackChecksum,X    \ The checksum bytes work like this:
                        \
                        \   * trackChecksum+0 counts the number of data bytes
                        \     ending in %00
                        \
                        \   * trackChecksum+1 counts the number of data bytes
                        \     ending in %01
                        \
                        \   * trackChecksum+2 counts the number of data bytes
                        \     ending in %10
                        \
                        \   * trackChecksum+3 counts the number of data bytes
                        \     ending in %11
                        \
                        \ This code checks off the relevant checksum byte for
                        \ the data byte in A, so if all the data is correct,
                        \ this will eventually decrement all four bytes to zero

 INY                    \ Increment the loop counter

 BNE swap2              \ If we have finshed swapping a page of bytes, increment
 INC Q                  \ the high bytes of (Q P) and (S R) to move on to next
 INC S                  \ page

.swap2

 CPY #&25               \ If we have not yet reached addresses &5A24 and &77FF,
 BNE swap1              \ jump back to swap1 to keep swapping data
 LDA S
 CMP #&77
 BNE swap1

 LDX #3                 \ The data swap is now done, so we now check that all
                        \ three checksum bytes at trackChecksum are zero, so set
                        \ a counter in X to work through the four bytes

.swap3

 LDA trackChecksum,X    \ If the X-th checksum byte is non-zero, the checksum
 BNE swap4              \ has failed, so jump to swap4 to reset the machine

 DEX                    \ Decrement the checksum byte counter

 BPL swap3              \ Loop back to check the next checksum byte

 BMI MoveCode           \ If we get here then all four checksum bytes are zero,
                        \ so jump to swap4 to keep going (this BMI is
                        \ effectively a JMP as we just passed through a BPL)

.swap4

 JMP (&FFFC)            \ The checksum has failed, so reset the machine

\ ******************************************************************************
\
\       Name: MoveCode
\       Type: Subroutine
\   Category: Setup
\    Summary: Move and reset various blocks around in memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.MoveCode

                        \ We are going to process the five memory blocks defined
                        \ in (blockStartHi blockStartLo)-(blockEndHi blockEndLo)
                        \
                        \ We will either zero the memory block (for the first
                        \ block in the table), or move the block to the address
                        \ in (blockToHi blockToLo)
                        \
                        \ We work through the blocks from the last entry to the
                        \ first, so we end up doing this:
                        \
                        \   * Move &1500-&15DA to &7000-&70DA
                        \   * Move &1300-&14FF to &0B00-&0CFF
                        \   * Move &5A80-&645B to &0D00-&16DB
                        \   * Move &64D0-&6BFF to &5FD0-&63FF
                        \   * Zero &5A80-&5E3F

 LDX #4                 \ Set a block counter in X to work through the five
                        \ memory blocks, starting with the block defined at
                        \ the end of the block tables

 LDY #0                 \ Set Y as a byte counter

.move1

 LDA blockStartLo,X     \ Set (Q P) to the X-th address from (blockStartHi
 STA P                  \ blockStartLo)
 LDA blockStartHi,X
 STA Q

 LDA blockToLo,X        \ Set (S R) to the X-th address from (blockToHi
 STA R                  \ blockToLo)
 LDA blockToHi,X
 STA S

.move2

 LDA (P),Y              \ Copy the Y-th byte of (Q P) to the Y-th byte of (S R)
 STA (R),Y              \
                        \ The LDA (P),Y instruction gets modified to LDA #0 for
                        \ the last block that we process, i.e. when X = 0

 INC P                  \ Increment the address in (Q P), starting with the low
                        \ byte

 BNE move3              \ Increment the high byte if we cross a page boundary
 INC Q

.move3

 INC R                  \ Increment the address in (S R), starting with the low
                        \ byte

 BNE move4              \ Increment the high byte if we cross a page boundary
 INC S

.move4

 LDA P                  \ If (Q P) <> (blockEndHi blockEndLo) then jump back to
 CMP blockEndLo,X       \ move2 to process the next byte in the block
 BNE move2
 LDA Q
 CMP blockEndHi,X
 BNE move2

 DEX                    \ We have finished processing a block, so decrement the
                        \ block counter in X to move on to the next block (i.e.
                        \ the previous entry in the table)

 BMI move5              \ If X < 0 then we have finished processing all five
                        \ blocks, so jump to move5

 BNE move1              \ If X <> 0, i.e. X > 0, then jump up to move1 to move
                        \ the next block

 LDA ldaZero            \ We get here when X = 0, which means we have reached
 STA move2              \ the last block to process (i.e. the first entry in the
 LDA ldaZero+1          \ block tables)
 STA move2+1            \
                        \ We don't want to copy this block, we want to zero it,
                        \ so we modify the instruction at move2 to LDA #0, so
                        \ the code zeroes the block rather than moving it

 JMP move1              \ Jump back to move1 to zero the final block

.move5

IF _ACORNSOFT

 JMP SetupGame          \ If we get here we have processed all the blocks in the
                        \ block tables, so jump to SetupGame to continue setting
                        \ up the game

ELIF _SUPERIOR

 JMP Protect            \ If we get here we have processed all the blocks in the
                        \ block tables, so jump to Protect to continue setting
                        \ up the game

ENDIF

\ ******************************************************************************
\
\       Name: ldaZero
\       Type: Variable
\   Category: Setup
\    Summary: Contains code that's used for modifying the MoveCode routine
\
\ ******************************************************************************

.ldaZero

 LDA #0                 \ The instruction at move2 in the MoveCode routine is
                        \ modified to this instruction so the routine zeroes a
                        \ block of memory rather than moving it

\ ******************************************************************************
\
\       Name: blockStartLo
\       Type: Variable
\   Category: Setup
\    Summary: Low byte of the start address of blocks moved by the MoveCode
\             routine
\
\ ******************************************************************************

.blockStartLo

 EQUB &80, &D0, &80, &00, &00

\ ******************************************************************************
\
\       Name: blockStartHi
\       Type: Variable
\   Category: Setup
\    Summary: High byte of the start address of blocks moved by the MoveCode
\             routine
\
\ ******************************************************************************

.blockStartHi

 EQUB &5A, &64, &5A, &13, &15

\ ******************************************************************************
\
\       Name: blockEndLo
\       Type: Variable
\   Category: Setup
\    Summary: Low byte of the end address of blocks moved by the MoveCode
\             routine
\
\ ******************************************************************************

.blockEndLo

 EQUB &40, &00, &5C, &00, &DB

\ ******************************************************************************
\
\       Name: blockEndHi
\       Type: Variable
\   Category: Setup
\    Summary: High byte of the end address of blocks moved by the MoveCode
\             routine
\
\ ******************************************************************************

.blockEndHi

 EQUB &5E, &6C, &64, &15, &15

\ ******************************************************************************
\
\       Name: blockToLo
\       Type: Variable
\   Category: Setup
\    Summary: Low byte of the destination address of blocks moved by the
\             MoveCode routine
\
\ ******************************************************************************

.blockToLo

 EQUB &80, &D0, &00, &00, &00

\ ******************************************************************************
\
\       Name: blockToHi
\       Type: Variable
\   Category: Setup
\    Summary: High byte of the destination address of blocks moved by the
\             MoveCode routine
\
\ ******************************************************************************

.blockToHi

 EQUB &5A, &5F, &0D, &0B, &70

 EQUB &09, &B9          \ These bytes appear to be unused
 EQUB &02, &50
 EQUB &9D, &01
 EQUB &09, &9D
 EQUB &79, &09
 EQUB &B9, &03
 EQUB &50, &9D
 EQUB &02, &09
 EQUB &B9, &01
 EQUB &51, &9D
 EQUB &00, &0A
 EQUB &B9, &02
 EQUB &51, &9D
 EQUB &01, &0A
 EQUB &9D, &79
 EQUB &0A, &B9
 EQUB &03, &51
 EQUB &9D, &02
 EQUB &0A, &B9
 EQUB &04, &50
 EQUB &9D, &78
 EQUB &09, &B9
 EQUB &06, &50
 EQUB &9D, &7A
 EQUB &09, &B9
 EQUB &04

\ ******************************************************************************
\
\       Name: soundData
\       Type: Variable
\   Category: Sound
\    Summary: OSWORD blocks for making the various game sounds
\
\ ------------------------------------------------------------------------------
\
\ Sound data. To make a sound, the MakeSound passes the bytes in this table to
\ OSWORD 7. These bytes are the OSWORD equivalents of the parameters passed to
\ the SOUND keyword in BASIC. The parameters have these meanings:
\
\   channel/flush, amplitude (or envelope number if 1-4), pitch, duration
\
\ where each value consists of two bytes, with the low byte first and the high
\ byte second.
\
\ For the channel/flush parameter, the top nibble of the low byte is the flush
\ control (where a flush control of 0 queues the sound, and a flush control of
\ 1 makes the sound instantly), while the bottom nibble of the low byte is the
\ channel number . When written in hexadecimal, the first figure gives the flush
\ control, while the second is the channel (so &13 indicates flush control = 1
\ and channel = 3).
\
\ ******************************************************************************

ORG &0B00

 EQUB &10, &10          \ These bytes appear to be unused
 EQUB &10, &10
 EQUB &10, &10
 EQUB &10, &10
 EQUB &10, &10
 EQUB &10, &10
 EQUB &10, &10
 EQUB &10, &10

.soundData

 EQUB &10, &00          \ Sound #0: Engine exhaust (SOUND &10, -10, 3, 255)
 EQUB &F6, &FF
 EQUB &03, &00
 EQUB &FF, &00

 EQUB &11, &00          \ Sound #1: Engine tone 1 (SOUND &11, -10, 187, 255)
 EQUB &F6, &FF
 EQUB &BB, &00
 EQUB &FF, &00

 EQUB &12, &00          \ Sound #2: Engine tone 2 (SOUND &12, -10, 40, 255)
 EQUB &F6, &FF
 EQUB &28, &00
 EQUB &FF, &00

 EQUB &13, &00          \ Sound #3: Tyre squeal (SOUND &13, 1, 130, 255)
 EQUB &01, &00
 EQUB &82, &00
 EQUB &FF, &00

 EQUB &10, &00          \ Sound #4: Crash/contact (SOUND &10, -10, 6, 4)
 EQUB &F6, &FF
 EQUB &06, &00
 EQUB &04, &00

\ ******************************************************************************
\
\       Name: envelopeData
\       Type: Variable
\   Category: Sound
\    Summary: Data for the sound envelope for squealing tyres
\
\ ------------------------------------------------------------------------------
\
\ There is only one sound envelope defined in Revs:
\
\   * Envelope 1 defines the sound of the tyres squealing
\
\ ******************************************************************************

.envelopeData

 EQUB 1, 1, 2, -2, -6, 4, 1, 1, 10, 0, 0, 0, 72, 0

\ ******************************************************************************
\
\       Name: xStore1
\       Type: Variable
\   Category: Sound
\    Summary: Temporary storage for X so it can be preserved through calls to
\             the sound routines
\
\ ******************************************************************************

.xStore1

 EQUB &FF

\ ******************************************************************************
\
\       Name: MakeSound
\       Type: Subroutine
\   Category: Sound
\    Summary: Make a sound
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The sound number from the soundData table (0 to 4)
\
\   Y                   The volume level to use for the sound, or the envelope
\                       number (the latter is used for sound #3 only, and is
\                       always set to envelope 1, which is the only envelope)
\
\ Other entry points:
\
\   MakeSound-3         Make the sound at the current volume level
\
\ ******************************************************************************

 LDY volumeLevel        \ Set Y to the current volumeLevel, to use as the sound
                        \ amplitude below

.MakeSound

 STX xStore1            \ Store the value of X in xStore1, so we can preserve it
                        \ through the routine

 ASL A                  \ Set A = A * 8
 ASL A                  \
 ASL A                  \ so we can use it as an index into the soundData table,
                        \ which has 8 bytes per entry

 CLC                    \ Set (Y X) = soundData + A
 ADC #LO(soundData)     \
 TAX                    \ starting with the low byte in X, which gets set to the
                        \ following, as LO(soundData) is 16:
                        \
                        \   * 16 for sound #0
                        \   * 24 for sound #1
                        \   * 32 for sound #2
                        \   * 40 for sound #3
                        \   * 48 for sound #4
                        \
                        \ This means that soundData - 16 + X points to the sound
                        \ data block for the sound we are making, which we now
                        \ use to set the volume or envelope for the sound to Y,
                        \ and flag the correct sound buffer as being in use

 TYA                    \ Set byte #2 of the sound data (low byte of amplitude
 STA soundData-16+2,X   \ or envelope number) to Y

 LDA soundData-16,X     \ Set Y to byte #0 of the sound data (channel/flush),
 AND #3                 \ and extract the channel number into Y
 TAY

 LDA #7                 \ Set A = 7 for the OSWORD command to make a sound

 STA soundBuffer,Y      \ Set the Y-th sound buffer status to 7, which is
                        \ non-zero and indicates that we are making a sound on
                        \ this channel

 BNE MakeSoundEnvelope  \ Jump to MakeSoundEnvelope to set up Y and apply the
                        \ OSWORD command to the (Y X) block, which makes the
                        \ relevant sound (this BNE is effectively a JMP as A is
                        \ never zero)

\ ******************************************************************************
\
\       Name: DefineEnvelope
\       Type: Subroutine
\   Category: Sound
\    Summary: Define a sound envelope
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The offset of the sound envelope data in envelopeData:
\
\                         * A = 0 for the first (and only) envelope definition
\
\ Returns:
\
\   X                   X is unchanged
\
\ ******************************************************************************

.DefineEnvelope

 STX xStore1            \ Store the value of X in xStore1, so we can preserve it
                        \ through the routine

 CLC                    \ Set (Y X) = envelopeData + A
 ADC #LO(envelopeData)  \
 TAX                    \ starting with the low byte

 LDA #8                 \ Set A = 8 for the OSWORD command to define an envelope

                        \ Fall through into MakeSoundEnvelope to set up Y and
                        \ apply the OSWORD command to the (Y X) block, which
                        \ defines the relevant sound envelope

\ ******************************************************************************
\
\       Name: MakeSoundEnvelope
\       Type: Subroutine
\   Category: Sound
\    Summary: Either make a sound or set up an envelope
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The action:
\
\                         * A = 7 make a sound
\
\                         * A = 8 to define a sound envelope
\
\   X                   The low byte of the address of the OSWORD block
\
\   xStore1             The value of X to restore at the end of the routine
\
\ ******************************************************************************

.MakeSoundEnvelope

 LDY #HI(soundData)     \ Set y to the high byte of the soundData block
                        \ address, so (Y X) now points to the relevant envelope
                        \ or sound data block

 JSR OSWORD             \ Call OSWORD with action A, as follows:
                        \
                        \  * A = 7 to make the sound at (Y X)
                        \
                        \  * A = 8 to set up the sound envelope at (Y X)

 LDX xStore1            \ Fetch the value of X we stored before calling the
                        \ routine, so it doesn't change

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ScaleWingSettings
\       Type: Subroutine
\   Category: Driving model
\    Summary: Scale the wing settings and calculate the wing balance, for use in
\             the driving model
\
\ ------------------------------------------------------------------------------
\
\ The wing settings (0 to 40) are scaled to the range 90 to 218.
\
\ The wing balance is calculated as:
\
\   60 + (rearWingSetting * 3 + frontWingSetting) / 2
\
\ which is in the range 60 to 140, with higher numbers when the rear wing is
\ greater (i.e. pushes down more) than the front wing.
\
\ ******************************************************************************

.ScaleWingSettings

 LDX #1                 \ We are about to loop through the two wing settings, so
                        \ set a counter in X so we do the rear wing setting
                        \ first, and then the front wing setting

.P0B79

 LDA frontWingSetting,X \ Set U = wing setting * 4
 ASL A
 ASL A
 STA U

 LDA wingScaleFactor,X  \ Set A to the wingScaleFactor for this wing setting,
                        \ which is hard-coded to 205

 JSR Multiply8x8        \ Set (A T) = A * U

                        \ So by this point, we have:
                        \
                        \   A = A * U / 256
                        \     = U * 205 / 256
                        \     = wing setting * 4 * 205 / 256
                        \     = wing setting * 820 / 256
                        \
                        \ The wing settings can be from 0 to 40, so this scales
                        \ the setting to the range 0 to 128

 CLC                    \ Set A = A + 90
 ADC #90                \
                        \ which is in the range 90 to 218

 STA wingSetting,X      \ Store the scaled wing setting in wingSetting

 DEX                    \ Decrement the loop counter

 BPL P0B79              \ Loop back until we have scaled both wing settings

 LDA rearWingSetting    \ Set A = (rearWingSetting * 2 + rearWingSetting
 ASL A                  \         + frontWingSetting) / 2 + 60
 ADC rearWingSetting    \       = (rearWingSetting * 3 + frontWingSetting) / 2
 ADC frontWingSetting   \         + 60
 LSR A                  \
 ADC #60                \ which is in the range 60 to 140, with higher numbers
                        \ when the rear wing is greater than the front wing

 STA wingBalance        \ Store the wing balance in wingBalance

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: wingScaleFactor
\       Type: Variable
\   Category: Driving model
\    Summary: Scale factors for the wing settings
\
\ ******************************************************************************

.wingScaleFactor

 EQUB 205               \ Scale factor for the front wing setting

 EQUB 205               \ Scale factor for the rear wing setting

\ ******************************************************************************
\
\       Name: RotateTrack
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   L0005 to 5, update L5EE0, var24Lo, var24Hi, yVergeRight
\
\                       Above + 40, update L5F08, var23Lo, var23Hi, yVergeLeft
\
\ ******************************************************************************

.RotateTrack

 LDA #0                 \ Set the Y-th entry in L5EE0 to 0
 STA L5EE0,Y

 LDA var24Lo,Y          \ Set var24 = var24 - spinSpeed
 SEC                    \
 SBC spinSpeedLo        \ starting with the high bytes
 STA var24Lo,Y

 LDA var24Hi,Y          \ And then the low bytes
 SBC spinSpeedHi
 STA var24Hi,Y

 LDA yVergeRight,Y      \ Set A = Y-th entry in yVergeRight - L004E
 SEC
 SBC L004E

 STA yVergeRight,Y      \ Store the result in the Y-th entry in yVergeRight

 CMP horizonLine        \ If A < horizonLine, then this track section is lower
 BCC rott1              \ than the current horizon, jump to rott1 to return
                        \ from the subroutine

 STA horizonLine        \ Store the result in horizonLine

 STY L0051              \ Set L0051 = Y

.rott1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: AddVectors
\       Type: Subroutine
\   Category: Maths
\    Summary: Add two three-axis vectors together
\
\ ------------------------------------------------------------------------------
\
\ Given a three-axis variable vectorX and a three-axis variable vectorY, this
\ routine calculates the following addition:
\
\                       [ (SS T) ]
\   vectorX = vectorY + [ (TT U) ]
\                       [ (UU V) ]
\
\ Arguments:
\
\   X                   The offset of the vectorX variable to update:
\
\                         * Index * 3 of the track segment to use for the
\                           section coordinates for the inner track
\
\                         * &F4 = xVector7
\
\                         * &FA = xVector3
\
\                         * &FD = xVector4
\
\   Y                   The offset of the vectorY variable to add:
\
\                         * Index * 3 of the track segment to use for the
\                           section coordinates for the inner track
\
\                         * &F4 = xVector7
\
\                         * &FA = xVector3
\
\                         * &FD = xVector4
\
\   (SS T)              The value to add to the first axis
\
\   (TT U)              The value to add to the second axis
\
\   (UU V)              The value to add to the third axis
\
\ ******************************************************************************

.AddVectors

 LDA xSegmentCoordILo,Y \ Set xVectorX = xVectorY + (SS T)
 CLC                    \
 ADC T                  \ starting with the high bytes
 STA xSegmentCoordILo,X

 LDA xSegmentCoordIHi,Y \ And then the low bytes
 ADC SS
 STA xSegmentCoordIHi,X

 LDA ySegmentCoordILo,Y \ Set yVectorX = yVectorY + (TT U)
 CLC                    \
 ADC U                  \ starting with the high bytes
 STA ySegmentCoordILo,X

 LDA ySegmentCoordIHi,Y \ And then the low bytes
 ADC TT
 STA ySegmentCoordIHi,X

 LDA zSegmentCoordILo,Y \ Set zVectorX = zVectorY + (UU V)
 CLC                    \
 ADC V                  \ starting with the high bytes
 STA zSegmentCoordILo,X

 LDA zSegmentCoordIHi,Y \ And then the low bytes
 ADC UU
 STA zSegmentCoordIHi,X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Multiply8x8
\       Type: Subroutine
\   Category: Maths
\    Summary: Calculate (A T) = T * U
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of two unsigned 8-bit numbers:
\
\   (A T) = A * U
\
\ Returns:
\
\   X                   X is unchanged
\
\ Other entry points:
\
\   Multiply8x8+2       Calculate (A T) = T * U
\
\ ******************************************************************************

.Multiply8x8

 STA T                  \ Set T = A

                        \ We now calculate (A T) = T * U
                        \                        = A * U

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LSR T                  \ Set T = T >> 1
                        \ and C flag = bit 0 of T

                        \ We are now going to work our way through the bits of
                        \ T, and do a shift-add for any bits that are set,
                        \ keeping the running total in A, and instead of using a
                        \ loop, we unroll the calculation, starting with bit 0

 BCC P%+5               \ If C (i.e. the next bit from T) is set, do the
 CLC                    \ addition for this bit of T:
 ADC U                  \
                        \   A = A + U

 ROR A                  \ Shift A right to catch the next digit of our result,
                        \ which the next ROR sticks into the left end of T while
                        \ also extracting the next bit of T

 ROR T                  \ Add the overspill from shifting A to the right onto
                        \ the start of T, and shift T right to fetch the next
                        \ bit for the calculation into the C flag

 BCC P%+5               \ Repeat the shift-and-add loop for bit 1
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 2
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 3
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 4
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 5
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 6
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 7
 CLC
 ADC U
 ROR A
 ROR T

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Divide8x8
\       Type: Subroutine
\   Category: Maths
\    Summary: Calculate T = 256 * A / V
\
\ ------------------------------------------------------------------------------
\
\ In the same way that shift-and-add implements a binary version of the manual
\ long multiplication process, shift-and-subtract implements long division. We
\ shift bits out of the left end of the number being divided (A), subtracting
\ the largest possible multiple of the divisor (V) after each shift; each bit of
\ A where we can subtract Q gives a 1 the answer to the division, otherwise it
\ gives a 0.
\
\ Arguments:
\
\   T                   This has an effect, not sure what ???
\
\   A                   Unsigned integer
\
\   V                   Unsigned integer
\
\ ******************************************************************************

.Divide8x8

 ASL T                  \ Shift T left, which clears bit 0 of T, ready for us to
                        \ start building the result

                        \ We now repeat the following five instruction block
                        \ eight times, one for each bit in T

 ROL A                  \ Shift A to the left to extract the next bit from the
                        \ number being divided

 BCS P%+6               \ If we just shifted a 1 out of A, skip the next two
                        \ instructions and jump straight to the subtraction

 CMP V                  \ If A < V skip the following two instructions with the
 BCC P%+5               \ C flag clear, so we shift a 0 into the result in T

 SBC V                  \ A >= V, so set A = A - V and set the C flag so we
 SEC                    \ shift a 1 into the result in T

 ROL T                  \ Shift T to the left, pulling the C flag into bit 0

 ROL A                  \ Repeat the shift-and-subtract loop for bit 1
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for bit 2
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for bit 3
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for bit 4
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for bit 5
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for bit 6
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for bit 7, but
 BCS P%+4               \ without the subtraction, as we don't need to keep
 CMP V                  \ calculating A once its top bit has been extracted
 ROL T

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetObjectDistance
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate the distance between an object and the player's car, for
\             collision purposes
\
\ ------------------------------------------------------------------------------
\
\ If the viewing angle is < 18.2 degrees:
\
\   * Set (L K) = (J I) + (H G) / 8
\               = max + min / 8
\
\ If the viewing angle is >= 18.2 degrees
\
\   * Set (L K) = (J I) * 7/8 + (H G) / 2
\               = max * 7/8 + min / 2
\
\ This appears to set the distance between the object and the player's car, for
\ the purposes of determining whether contact has been made.
\
\ I suspect the calculation is designed to take the long shape of the cars into
\ consideration, given the viewing angle of the other car.
\
\ Arguments:
\
\   (J I)               max(|x-delta|, |z-delta|)
\
\   (H G)               min(|x-delta|, |z-delta|)
\
\   M                   The smaller viewing angle of the object, where 0 to 255
\                       represents 0 to 45 degrees, so 103 = 18.2 degrees
\
\ Returns:
\
\   (L K)               The distance between the object and the player's car
\
\   A                   Contains the high byte of (L K)
\
\ ******************************************************************************

.GetObjectDistance

 LDA M                  \ If M >= 103, jump to C0CC2
 CMP #103
 BCS C0CC2

 LDA G                  \ Set A = G

 LSR H                  \ Set (H A) = (H A) >> 3
 ROR A                  \           = (H G) >> 3
 LSR H
 ROR A
 LSR H
 ROR A

 CLC                    \ Set (L K) = (J I) + (H A)
 ADC I                  \           = (J I) + (H G) >> 3
 STA K                  \           = (J I) + (H G) / 8
 LDA H
 ADC J
 STA L

 RTS                    \ Return from the subroutine

.C0CC2

 LSR H                  \ Set (H G) = (H G) >> 1
 ROR G

 LDA J                  \ Set (T A) = (J I)
 STA T
 LDA I

 LSR T                  \ Set (T U) = (T A) >> 3
 ROR A                  \           = (J I) >> 3
 LSR T
 ROR A
 LSR T
 ROR A
 STA U

 LDA G                  \ Set (L K) = (J I) + (H G)
 CLC                    \           = (J I) + (H G) >> 1
 ADC I
 STA K
 LDA H
 ADC J
 STA L

 LDA K                  \ Set (L K) = (L K) - (T U)
 SEC                    \           = (J I) + (H G) >> 1 - (J I) >> 3
 SBC U                  \           = (J I) * 7/8 + (H G) / 2
 STA K
 LDA L
 SBC T
 STA L

 RTS                    \ Return from the subroutine

 EQUB &F1, &0C          \ These bytes appear to be unused
 EQUB &E5, &74
 EQUB &8D, &F6
 EQUB &0C, &60
 EQUB &00, &00
 EQUB &00, &00
 EQUB &00, &00
 EQUB &40

\ ******************************************************************************
\
\       Name: sub_C0D01
\       Type: Subroutine
\   Category: Maths
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C0D01

 STA J
 STX T
 JSR sub_C0DB3
 STA G
 LDA U
 STA H
 LDX #1
 STX L0042
 LDX #0
 BIT J
 BVC C0D1B
 INX
 DEC L0042

.C0D1B

 CMP #&7A
 BCC C0D27
 BCS C0D4F
 LDA G
 CMP #&F0
 BCS C0D4F

.C0D27

 LDA #&AB

 JSR Multiply8x8        \ Set (A T) = A * U

 JSR Multiply8x8        \ Set (A T) = A * U

 STA V

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256

 LDA G
 SEC
 SBC T
 STA T
 LDA H
 SBC U
 ASL T
 ROL A
 STA var26Hi,X
 LDA T
 AND #&FE
 STA var26Lo,X
 JMP C0D7F

.C0D4F

 LDA #0
 SEC
 SBC G
 STA T
 LDA #&C9
 SBC H
 STA U
 STA V

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256

 ASL T
 ROL U
 LDA #0
 SEC
 SBC T
 AND #&FE
 STA var26Lo,X
 LDA #0
 SBC U
 BCC C0D7C
 LDA #&FE
 STA var26Lo,X
 LDA #&FF

.C0D7C

 STA var26Hi,X

.C0D7F

 CPX L0042
 BEQ C0D97
 LDX L0042
 LDA #0
 SEC
 SBC G
 STA G
 LDA #&C9
 SBC H
 STA H
 STA U
 JMP C0D1B

.C0D97

 LDA J
 BPL C0DA3
 LDA #1
 ORA var26Lo
 STA var26Lo

.C0DA3

 LDA J
 ASL A
 EOR J
 BPL C0DB2
 LDA #1
 ORA L62A1
 STA L62A1

.C0DB2

 RTS

\ ******************************************************************************
\
\       Name: sub_C0DB3
\       Type: Subroutine
\   Category: Maths
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C0DB3

 ASL T
 ROL A
 ASL T
 ROL A
 STA V
 LDA #&C9
 STA U

\ ******************************************************************************
\
\       Name: Multiply8x16
\       Type: Subroutine
\   Category: Maths
\    Summary: Multiply an 8-bit and a 16-bit number
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of two unsigned numbers:
\
\   (U T) = U * (V T) / 256
\
\ ******************************************************************************

.Multiply8x16

 JSR Multiply8x8+2      \ Set (A T) = T * U

 STA W                  \ Set (W T) = (A T)
                        \           = T * U
                        \
                        \ So W = T * U / 256

 LDA V                  \ Set A = V

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = V * U

 STA U                  \ Set (U T) = (A T)
                        \           = V * U

 LDA W                  \ Set (U T) = (U T) + W
 CLC                    \
 ADC T                  \ starting with the low bytes
 STA T

 BCC mult1              \ And then the high bytes, so we get the following:
 INC U                  \
                        \   (U T) = (U T) + W
                        \         = V * U + (T * U / 256)
                        \         = U * (V + T / 256)
                        \         = U * (256 * V + T) / 256
                        \         = U * (V T) / 256
                        \
                        \ which is what we want

.mult1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C0DD7
\       Type: Subroutine
\   Category: Maths
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C0DD7

 LDA QQ
 BPL C0DEE
 LDA #0
 SEC
 SBC PP
 STA PP
 LDA #0
 SBC QQ
 STA QQ
 LDA H
 EOR #&80
 STA H

.C0DEE

 LDA RR
 AND #1
 BEQ C0DFA
 LDA H
 EOR #&80
 STA H

.C0DFA

 LDA QQ
 STA U
 LDA RR

 JSR Multiply8x8        \ Set (A T) = A * U

 STA W
 LDA T
 CLC
 ADC #&80
 STA V
 BCC C0E10
 INC W

.C0E10

 LDA SS

 JSR Multiply8x8        \ Set (A T) = A * U

 STA G
 LDA T
 CLC
 ADC W
 STA W
 BCC C0E22
 INC G

.C0E22

 LDA PP
 STA U
 LDA SS

 JSR Multiply8x8        \ Set (A T) = A * U

 STA U
 LDA T
 CLC
 ADC V
 LDA U
 ADC W
 STA T
 BCC C0E3C
 INC G

.C0E3C

 LDA G
 BIT H

\ ******************************************************************************
\
\       Name: Absolute16Bit
\       Type: Subroutine
\   Category: Maths
\    Summary: Calculate the absolute value (modulus) of a 16-bit number
\
\ ------------------------------------------------------------------------------
\
\ This routine sets (A T) = |A T|.
\
\ It can also return (A T) * abs(n), where A is given the sign of n.
\
\ Arguments:
\
\   (A T)               The number to make positive
\
\   N flag              Controls the sign to be applied:
\
\                         * If we want to calculate |A T|, do an LDA or
\                           equivalent before calling the routine
\
\                         * If we want to calculate (A T) * abs(n), do a BIT n
\                           before calling the routine
\
\                         * If we want to set the sign of (A T), then call with:
\
\                           * N flag clear to calculate (A T) * 1
\
\                           * N flag set to calculate (A T) * -1
\
\ ******************************************************************************

.Absolute16Bit

 BPL ScanKeyboard-1     \ If the high byte in A is already positive, return from
                        \ the subroutine (as ScanKeyboard-1 contains an RTS)

                        \ Otherwise fall through into Negate16Bit to negate the
                        \ number in (A T), which will make it positive, so this
                        \ sets (A T) = |A T|

\ ******************************************************************************
\
\       Name: Negate16Bit
\       Type: Subroutine
\   Category: Maths
\    Summary: Negate a 16-bit number
\
\ ------------------------------------------------------------------------------
\
\ This routine negates the 16-bit number (A T).
\
\ Other entry points:
\
\   Negate16Bit+2       Set (A T) = -(U T)
\
\ ******************************************************************************

.Negate16Bit

 STA U                  \ Set (U T) = (A T)

 LDA #0                 \ Set (A T) = 0 - (U T)
 SEC                    \           = -(A T)
 SBC T                  \
 STA T                  \ starting with the low bytes

 LDA #0                 \ And then the high bytes
 SBC U

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ScanKeyboard
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the kayboard for a specific key press
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The negative inkey value of the key to scan for (in the
\                       range &80 to &FF)
\
\ Returns:
\
\   Z flag              Set if the key in X is being pressed, in which case BEQ
\                       will branch
\
\                       CLear if the key in X is not being pressed, in which
\                       case BNE will branch
\
\ Other entry points:
\
\   ScanKeyboard-1      Contains an RTS
\
\ ******************************************************************************

.ScanKeyboard

 LDA #129               \ Call OSBYTE with A = 129, Y = &FF and the inkey value
 LDY #&FF               \ in X, to scan the keyboard for key X
 JSR OSBYTE

 CPX #&FF               \ If the key in X is being pressed, the above call sets
                        \ both X and Y to &FF, so this sets the Z flag depending
                        \ on whether the key is being pressed (so a BEQ after
                        \ the call will branch if the key in X is being pressed)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FlushSoundBuffer
\       Type: Subroutine
\   Category: Sound
\    Summary: Flush the specified sound buffer
\
\ ------------------------------------------------------------------------------
\
\ This routine flushes the specified sound channel buffer, but only if that
\ channel's soundBuffer value is non-zero.
\
\ Arguments:
\
\   X                   The number of the sound channel buffer to flush (0 to 3)
\
\ Returns:
\
\   X                   X is unchanged
\
\   A                   A is unchanged
\
\ ******************************************************************************

.FlushSoundBuffer

 PHA                    \ Store the value of A on the stack so we can retrieve
                        \ it before returning from the routine

 LDA soundBuffer,X      \ If this buffer's soundBuffer value is zero, then there
 BEQ flus1              \ is nothing to flush, so jump to flus1 to return from
                        \ the subroutine

 LDA #0                 \ Set this buffer's soundBuffer value for this buffer to
 STA soundBuffer,X      \ 0 to indicate that it has been flushed

 TXA                    \ Set bit 2 of X
 ORA #%00000100         \
 TAX                    \ This changes X from the original range of 0 to 3, into
                        \ the range 4 to 7, so it now matches the relevant sound
                        \ buffer number (as buffers 4 to 7 are the buffers for
                        \ sound channels 0 to 3)

 LDA #21                \ Call OSBYTE with A = 21 to flush buffer X, which
 JSR OSBYTE             \ flushes the relevant sound channel buffer

 TXA                    \ Clear bit 2 of X, to reverse the X OR 4 above
 AND #%11111011
 TAX

.flus1

 PLA                    \ Retrieve the value of A that we stored on the stack
                        \ above, so it remains unchanged by the routine

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MakeDrivingSounds
\       Type: Subroutine
\   Category: Sound
\    Summary: Make the relevant sounds for the engine and tyres
\
\ ------------------------------------------------------------------------------
\
\ The engine sound is made up of three parts:
\
\   * Engine exhaust on sound channel 0
\   * Engine tone 1 on sound channel 1
\   * Engine tone 2 on sound channel 2
\
\ The exhaust is a kind of "putter-putter" white-noise sound, while the tones
\ get higher with higher rev counts, with tone 2 sounding for the whole range of
\ engine speeds from idling and up, and tone 1 only kicking in at higher revs.
\ The exhaust sound dies off at higher revs, when the engine is working at high
\ efficiency. The two tones are separated by a pitch of 28, with tone 1 lower
\ than tone 2.
\
\ The engine sounds depend on the value of soundRevTarget, which is set to
\ revCount + 25 (where revCount is the current rev count, as shown on the rev
\ counter). The soundRevCount variable moves towards the value of soundRevTarget
\ in steps of 1 on each call of this routine, so the engine sound is constantly
\ pitching up or down, trying to match the target in soundRevTarget.
\
\ This is how the engine sounds work with the various ranges of soundRevCount:
\
\   * If soundRevCount < 28:
\
\     * The engine is effectively off (revCount < 3)
\     * Rev counter hand is resting on the pin at 8 o'clock (i.e. the minimum)
\     * Stop all engine-related sounds
\
\   * If 28 <= soundRevCount < 64:
\
\     * The engine is idling (3 <= revCount < 39)
\     * When the engine is idling, soundRevCountdrops below 28 every now and
\       then, so the engine sound cuts out as if it is misfiring, but generally
\       it stays just above 28
\     * Rev counter hand is between 8 o'clock and 9 o'clock
\     * Make the sound of the engine exhaust
\     * Silence engine tone 1
\     * Silence engine tone 2
\
\   * If 64 <= soundRevCount < 92:
\
\     * The engine is revving up (39 <= revCount < 67)
\     * Rev counter hand is between 9 o'clock and 11 o'clock
\     * Make the sound of the engine exhaust
\     * Silence engine tone 1
\     * Set the pitch of engine tone 2 to soundRevCount - 64 (0 to 27)
\     * Make the sound of engine tone 2
\
\   * If soundRevCount >= 92:
\
\     * The engine is revved up (revCount >= 67)
\     * Rev counter hand is past 11 o'clock
\     * Do not make the sound of the engine exhaust
\     * Set the pitch of engine tone 1 to soundRevCount - 92 (0 and up)
\     * Make the sound of engine tone 1
\     * Set the pitch of engine tone 2 to soundRevCount - 64 (28 and up)
\     * Make the sound of engine tone 2
\
\ Note that in the above, the clock-face times are rounded to the nearest hour,
\ to keep things simple (for example, both tones kick in when the rev counter
\ passes 3.5 minutes to 12, which is a little way after 11 o'clock).
\
\ ******************************************************************************

.MakeDrivingSounds

 LDA L62A6              \ If bit 7 is clear in both L62A6 and L62A7, jump to
 ORA L62A7              \ soun1 to skip the following
 BPL soun1

                        \ Otherwise we add some random pitch variation to the
                        \ crash/contact sound and make the sound of the tyres
                        \ squealing

 LDA VIA+&68            \ Read 6522 User VIA T1C-L timer 2 low-order counter
                        \ (SHEILA &68), which will be a pretty random figure

 CMP #63                \ If A < 63 (25% chance), jump to soun1 to skip the
 BCS soun1              \ following

 AND #3                 \ Reduce A to a random number in the range 0 to 3

 CLC                    \ Add 130 to A, so A is a random number in the range
 ADC #130               \ 130 to 133

 STA soundData+28       \ Update byte #5 of sound #4 (low byte of pitch) so the
                        \ pitch of the crash/contact sound wavers randomly

 LDA #3                 \ Make sound #3 (tyre squeal) using envelope 1
 LDY #1
 JSR MakeSound

.soun1

                        \ We now increment or decrement soundRevCount so it
                        \ steps towards the value of soundRevTarget, which moves
                        \ the pitch of the engine towards the current rev count

 LDX soundRevCount      \ Set X = soundRevCount

 CPX soundRevTarget     \ If X = soundRevTarget, jump to soun8 to return from
 BEQ soun8              \ the subroutine

 BCC soun2              \ If X < soundRevTarget, jump to soun2 to increment X

 DEX                    \ Decrement X and skip the next instruction (this BCS
 BCS soun3              \ is effectively a JMP as we passed through the BCC)

.soun2

 INX                    \ Increment X

.soun3

 STX soundRevCount      \ Store X in soundRevCount, so soundRevCount moves one
                        \ step closed to soundRevTarget

                        \ We now do the following, depending on the updated
                        \ value of soundRevCount in X:
                        \
                        \   * If soundRevCount < 28, flush all the sound buffers
                        \     (i.e. stop making any sounds)
                        \
                        \   * If 28 <= soundRevCount < 92, make the engine
                        \     exhaust sound, set the pitch of engine tone 1 to
                        \     soundRevCount + 95 and the volume of engine tone 1
                        \     to 0, and make the sound of engine tone 1
                        \
                        \   * If soundRevCount >= 92, silence the exhaust, set
                        \     the pitch of engine tone 1 to soundRevCount - 92,
                        \     and make the sound of engine tone 1

 CPX #28                \ If X < 28, then jump to soun9 to flush all the sound
 BCC soun9              \ buffers, as the rev count is too low for the engine to
                        \ make a sound

 TXA                    \ Set A = X - 92
 SEC
 SBC #92

 BCS soun4              \ If the subtraction didn't underflow, i.e. X >= 92,
                        \ then jump to soun4 to silence the engine exhaust and
                        \ set the pitch of engine tone 1 to X - 92

 PHA                    \ Store A on the stack to we can retrieve it after the
                        \ following call

 LDA #0                 \ Make sound #0 (engine exhaust) at the current volume
 JSR MakeSound-3        \ level

 PLA                    \ Retrieve the value of A that we stored on the stack,
                        \ so A = X - 92

 CLC                    \ Set A = A + 187
 ADC #187               \       = X - 92 + 187
                        \       = X + 95
                        \
                        \ so we set the pitch of engine tone 1 to X + 95

 LDY #0                 \ Set Y = 0, so we set the volume of engine tone 1 to
                        \ zero (silent)

 BEQ soun5              \ Jump to soun5 (this BEQ is effectively a JMP as Y is
                        \ always zero)

.soun4

 LDX #0                 \ Flush the buffer for sound channel 0, which will stop
 JSR FlushSoundBuffer   \ the sound of the engine exhaust

 LDY volumeLevel        \ Set Y to the current volume level

.soun5

 STA soundData+12       \ Update byte #5 of sound #1 (low byte of pitch), to set
                        \ the pitch of engine tone 1 to A

 LDA #1                 \ Make sound #1 (engine tone 1) with volume Y
 JSR MakeSound

                        \ We now do the following, depending on the updated
                        \ value of soundRevCount:
                        \
                        \   * If the volume level is currently zero, make the
                        \     sound of engine tone 2 sound with volume 0
                        \
                        \   * If soundRevCount >= 64, set the pitch of engine
                        \     tone 2 to soundRevCount - 64, and make the sound
                        \     of engine tone 2
                        \
                        \   * If soundRevCount < 64, make the sound of engine
                        \     tone 2 with volume 0

 LDY volumeLevel        \ If the volume level is currently zero (no sound), jump
 BEQ soun7              \ to soun7 to make the engine tone 2 sound with volume 0

 LDA soundRevCount      \ Set A = soundRevCount - 64
 SEC
 SBC #64

 BCS soun6              \ If the subtraction didn't underflow, i.e. A >= 64,
                        \ then jump to soun6 to set the pitch of engine tone 2
                        \ to soundRevCount - 64

 LDY #0                 \ Set Y = 0, so we set the volume of engine tone 2 to
                        \ zero (silent)

 BEQ soun7              \ Jump to soun7 (this BEQ is effectively a JMP as Y is
                        \ always zero)

.soun6

 STA soundData+20       \ Update byte #5 of sound #2 (low byte of pitch), to set
                        \ the pitch of engine tone 2 to A

.soun7

 LDA #2                 \ Make sound #2 (engine tone 2) with volume Y
 JSR MakeSound

.soun8

 RTS                    \ Return from the subroutine

.soun9

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ProcessShiftedKeys
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Check for shifted keys (i.e. those that need SHIFT holding down to
\             trigger) and process them accordingly
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   Scan for the first Y + 1 keys from shiftedKeys
\
\ ******************************************************************************

.ProcessShiftedKeys

 STY T                  \ Set T to the number of keys to scan

 LDX #&FF               \ Scan the keyboard to see if SHIFT is being pressed
 JSR ScanKeyboard

 BNE shif10             \ If SHIFT is not being pressed, jump to shif10 to
                        \ return from the subroutine

 LDY T                  \ Set Y to the number of keys to scan, to use as a loop
                        \ counter as we work our way backwards through the
                        \ shiftedKeys table, from entry Y to entry 0

.shif1

 STY T                  \ Set T to the loop counter

 LDX shiftedKeys,Y      \ Fetch the next key number from the shiftedKeys table

 JSR ScanKeyboard       \ Scan the keyboard to see if this key is being pressed

 BEQ shif2              \ If this key is being pressed, jump to shif2 to update
                        \ the relevant configuration setting

 LDY T                  \ Otherwise set Y to the value of the loop counter

 DEY                    \ Decrement the loop counter to point to the next key in
                        \ the table (working backwards)

 BPL shif1              \ Loop back to check the next key in the table until we
                        \ have checked them all

 BMI shif3              \ None of the keys are being pressed, so jump to shif3
                        \ to skip updating the configuration bytes (this BMI is
                        \ effectively a JMP as we just passed through a BPL)

.shif2

                        \ If we get here then the Y-th key is being pressed,
                        \ along with SHIFT, so we now update the relevant
                        \ configuration byte, according to the settings in the
                        \ configKeys table

 LDY T                  \ Otherwise set Y to the value of the loop counter,
                        \ which gives us the offset of key that is being pressed
                        \ within the shiftedKeys table

 LDA configKeys,Y       \ Set X to the low nibble for this key's corresonding
 AND #&0F               \ entry in the configKeys, which contains the offset of
 TAX                    \ the configuration byte from the first configuration
                        \ byte at configStop

 LDA configKeys,Y       \ Set A to the high nibble for this key's corresonding
 AND #&F0               \ entry in the configKeys, which contains the value that
                        \ we need for the corresponding configuration byte

 STA configStop,X       \ Set the coresponding configuration byte to the value
                        \ in A

.shif3

 LDA configPause        \ If configPause = 0, then neither COPY nor DELETE are
 BEQ shif6              \ being, so jump to shif6

                        \ If we get here then one of the pause buttons is being
                        \ pressed

 BPL shif5              \ If bit 7 of configPause is clear, then this means bit
                        \ 6 must be set, which only happens when the unpause key
                        \ (DELETE) is being pressed, so jump to shif5 to unpause
                        \ the game

                        \ Otherwise we need to pause the game

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers to stop the sound
                        \ while we are paused

.shif4

 JSR ResetTrackLines    \ Reset the blocks at leftVergeStart, leftTrackStart,
                        \ rightVergeStart, rightGrassStart and backgroundColour

 LDX #&A6               \ Scan the keyboard to see if DELETE is being pressed
 JSR ScanKeyboard

 BNE shif4              \ If DELETE is not being pressed, loop back to shif4 to
                        \ remain paused, otherwise keep going to unpause the
                        \ game

.shif5

 INC soundRevCount      \ Increment soundRevCount to make the engine sound jump
                        \ a little

 LDA #0                 \ Set configPause = 0 to clear the pause/unpause key
 STA configPause        \ press

.shif6

 LDY volumeLevel        \ Set Y to the volume level, which uses the operating
                        \ system's volume scale, with -15 being full volume and
                        \ 0 being silent

 LDA mainLoopCounterLo  \ If bit 0 of mainLoopCounterLo is set, which it will be
 AND #1                 \ every other iteration round the main loop, jump to
 BNE shif9              \ shif9 to skip the following, so the sound changes more
                        \ slowly than it would if we did this every loop

 LDA configVolume       \ If configVolume = 0, jump to shif10 to return from the
 BEQ shif10             \ subroutine

 BPL shif7              \ If bit 7 of configVolume is clear, then this means bit
                        \ 6 must be set, which only happens when the volume up
                        \ (f5) key is being pressed, so jump to shif7

                        \ If we get here then we need to turn the volume down

 INY                    \ Increment Y to decrease the volume

 BEQ shif8              \ If Y is 0 or negative, then it is still a valid volume
 BMI shif8              \ level, so jump to shif8 to update the volume setting

 BPL shif9              \ Otherwise we have already turned the volume down as
                        \ far as it will go, so jump to shif9 to clear the key
                        \ press and return from the subroutine (this BPL is
                        \ effectively a JMP as we just passed through a BMI)

.shif7

                        \ If we get here then we need to turn the volume up

 DEY                    \ Decrement Y to increase the volume

 CPY #241               \ If Y < -15, then we have already turned the volume up
 BCC shif9              \ as far as it will go, so jump to shif9 to clear the
                        \ key press and return from the subroutine

                        \ Otherwise fall through into shif8 to update the
                        \ volume setting

.shif8

 STY volumeLevel        \ Store the updated volume level in volumeLevel

 TYA                    \ Set A = -Y, negated using two's complement
 EOR #&FF
 CLC
 ADC #1

 ASL A                  \ Set envelopeData+12 = A << 3
 ASL A                  \                       = -Y * 8
 ASL A                  \
 STA envelopeData+12    \ which is 0 for no volume, or 120 for full volume, so
                        \ this sets the target level for the end of the attack
                        \ phase to a higher figure for higher volume settings

 LDA #0                 \ Set up the envelope for the engine sound, with the
 JSR DefineEnvelope     \ volume changed accordingly

 INC soundRevCount      \ Increment soundRevCount to make the engine sound jump
                        \ a little

.shif9

 LDA #0                 \ Set configVolume = 0 to clear the volume key press
 STA configVolume

.shif10

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SortDrivers
\       Type: Subroutine
\   Category: Drivers
\    Summary: Create a sorted list of driver numbers, ordered as specified
\
\ ------------------------------------------------------------------------------
\
\ This routine sorts the driver list in driversInOrder according to the value
\ specified by argument A. It also populates carStatus with the position
\ numbers for the sorted driver list, which will typically run from 0 to 19,
\ but may also contain repeated numbers in the case of a tie.
\
\ The routine uses a basic bubble sort algorithm, swapping neighbouring drivers
\ repeatedly until the whole list is sorted. This is not very efficient, but as
\ this is only done when showing the driver table between races, that doesn't
\ matter.
\
\ Arguments:
\
\   A                   Determines the order of the sorted list to create:
\
\                           * 0 = best lap times
\
\                           * Bit 6 set = accumulated points
\
\                           * Bit 7 set = total race times
\
\ Returns:
\
\   positionNumber      A list of position numbers, from 0 to 19, ready to print
\                       in the first column of the driver table (with 1 added),
\                       with drivers who are tied in the same position sharing
\                       the same number
\
\   driversInOrder      A list of driver numbers, sorted according to the value
\                       specified by argument A
\
\ ******************************************************************************

.SortDrivers

 STA G                  \ Store A in G

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

.sort1

 LDX #0                 \ Set V = 0, which we will use to indicate whether the
 STX V                  \ driversInOrder list is sorted
                        \
                        \ We start at 0 to indicate it is sorted, and change it
                        \ if we have to reorder the list

 STX positionNumber     \ Set the first entry in positionNumber to 0, as the
                        \ winning driver will always be in position 0

 INX                    \ Set X = 1 as a position counter, counting through 1 to
                        \ 19, which denotes the position number that we are
                        \ processing in this iteration of the loop (we skip the
                        \ first position as we already set it)

.sort2

 STX W                  \ Store the position counter in W

 LDY driversInOrder,X   \ Set Y to the number of the driver at position X in the
                        \ driversInOrder list ("this driver")

 TXA                    \ Set the X-th entry in positionNumber to the position
 STA positionNumber,X   \ counter (as the X-th driver is in position X)

 LDA driversInOrder-1,X \ Set X to the number of the driver at position X - 1 in
 TAX                    \ the driversInOrder list ("the driver ahead")

 SEC                    \ Set the C flag for the subtractions below

 BIT G                  \ If bit 6 of G is set, jump to sort5 to compare total
 BVS sort5              \ points

 BMI sort6              \ If bit 7 of G is set, jump to sort6 to compare best
                        \ lap times

                        \ If we get here then bit 6 and 7 of G are clear, so we
                        \ compare most recent lap times

 LDA bestLapTenths,Y    \ Set (A H U) =   this driver's best lap time
 SBC bestLapTenths,X    \               - best lap time of the driver ahead
 STA U                  \
                        \ starting with the tenths of a second

 LDA bestLapSeconds,Y   \ Then the seconds
 SBC bestLapSeconds,X
 STA H

 LDA bestLapMinutes,Y   \ And then the minutes
 SBC bestLapMinutes,X

 BCC sort7              \ If the subtraction underflowed, then this driver's
                        \ lap time is quicker than the lap time of the driver
                        \ ahead, which is the wrong way round if we are trying
                        \ to create a list where the winner has the fastest lap
                        \ time, so jump to sort7 to swap them around in the
                        \ driversInOrder list

.sort3

 ORA U                  \ At this point (A H U) contains the difference between
 ORA H                  \ the two drivers' times/points, so this jumps to sort4
 BNE sort4              \ if any of the bytes in (A U H) are non-zero, i.e. if
                        \ the two drivers have different times/points

 LDX W                  \ The two drivers have identical times/points, so set
 DEX                    \ we need to set the current driver's position number to
 LDA positionNumber,X   \ be the same as the position number of the driver ahead
 STA positionNumber+1,X \ as there is a tie

.sort4

                        \ If we get here then we move on to the next position

 LDX W                  \ Fetch the position counter that we stored in W above

 INX                    \ Increment the position counter to the next position

 CPX #20                \ Loop back until we have gone through the whole table
 BCC sort2              \ of 20 positions

 LDA V                  \ If V <> 0 then we had to alter the order of the
 BNE sort1              \ driversInOrder list, as it wasn't fully sorted, so
                        \ we jump back to sort1 to repeat the whole process as
                        \ we don't yet know that the list is fully sorted

 CLD                    \ Otherwise the driversInOrder list is sorted, so clear
                        \ the D flag to switch arithmetic to normal

 JSR SetPlayerPositions \ Set the current player's position, plus the position
                        \ ahead and the position behind

 RTS                    \ Return from the subroutine

.sort5

 LDA totalPointsLo,X    \ Set (A H U) =   total points of the driver ahead
 SBC totalPointsLo,Y    \               - this driver's total points
 STA U                  \
                        \ starting with the low bytes

 LDA totalPointsHi,X    \ Then the high bytes
 SBC totalPointsHi,Y
 STA H

 LDA totalPointsTop,X   \ And then the top bytes
 SBC totalPointsTop,Y

 BCC sort7              \ If the subtraction underflowed, then this driver has
                        \ more points than the driver ahead, which is the wrong
                        \ way round if we are trying to create a list where the
                        \ winner has the most points, so jump to sort7 to swap
                        \ them around in the driversInOrder list

 BCS sort3              \ Jump to sort3 to check for a tie and move on to the
                        \ next position (this BCS is effectively a JMP as we
                        \ just passed through a BCC)

.sort6

 LDA totalRaceTenths,Y  \ Set (A H U) =   this driver's total race time
 SBC totalRaceTenths,X  \               - total race time of the driver ahead
 STA U                  \
                        \ starting with the tenths of a second

 LDA totalRaceSeconds,Y \ Then the seconds
 SBC totalRaceSeconds,X
 STA H

 LDA totalRaceMinutes,Y \ And then the minutes
 SBC totalRaceMinutes,X

 BCS sort4              \ If the subtraction didn't underflow then the drivers
                        \ are in the correct order, so jump to sort4 to move on
                        \ to the next position

                        \ Otherwise the subtraction underflowed, so this
                        \ driver's total race time is quicker than the total
                        \ race time of the driver ahead, which is the wrong way
                        \ round if we are trying to create a list where the
                        \ winner has the fastest time, so fall through into
                        \ sort7 to swap them around in the driversInOrder list

.sort7

                        \ If we get here then the two drivers we are comparing
                        \ are in the wrong order in the driversInOrder list, so
                        \ we need to swap them round
                        \
                        \ At this point X contains the number of the driver
                        \ ahead and Y contains the number of this driver

 STX T                  \ Store the number of the driver ahead in T

 LDX W                  \ Set X to the position counter

 TYA                    \ Set A to the number of this driver

 STA driversInOrder-1,X \ Set the number of the driver ahead (i.e. the position
                        \ before the one we are processing) to A (i.e. the
                        \ number of this driver)

 LDA T                  \ Set the number of this driver (i.e. the current
 STA driversInOrder,X   \ position) to T (i.e. the number of the driver ahead)

 DEC V                  \ Decrement V so that is it non-zero, to indicate that
                        \ we had to swap an entry in the driversInOrder list

 JMP sort4              \ Jump to sort4 to move on to the next position

\ ******************************************************************************
\
\       Name: UpdateLapTimers
\       Type: Subroutine
\   Category: Drivers
\    Summary: Update the lap timers and display timer-related messages at the
\             top of the screen
\
\ ******************************************************************************

.UpdateLapTimers

 LDA raceStarted        \ If bit 7 of raceStarted is clear then this is either
 BPL laps2              \ a practice or qualifying lap, so jump to laps2 to
                        \ update the lap timers for qualifying

                        \ If we get here then this is a race lap

 BIT updateDrivingInfo  \ If bit 7 of updateDrivingInfo is clear then we do not
 BPL laps1              \ need to update the lap number, so jump to laps1 to
                        \ skip straight to updating the driver positions

 LDA #%00000000         \ Clear bits 6 and 7 of updateDrivingInfo so we don't
 STA updateDrivingInfo  \ update the number of laps again until the value of
                        \ updateDrivingInfo changes to indicate that we should

 STA G                  \ Set G = 0 so the call to Print2DigitBCD below will
                        \ print the second digit and will not print leading
                        \ zeroes when printing the number of laps

 LDX currentPlayer      \ Set X to the driver number of the current player

 LDA driverLapNumber,X  \ Set A to the current lap number for the current player

 CMP #1                 \ If A >= 1, set the C flag, otherwise clear it

 EOR #&FF               \ Set A = numberOfLaps + ~A + C
 ADC numberOfLaps       \       = numberOfLaps - A      if A >= 1
                        \       = numberOfLaps - 1      if A = 0

 PHP                    \ Store the resulting flags on the stack

 JSR ConvertNumberToBCD \ Convert the number in A into binary coded decimal
                        \ (BCD), adding 1 in the process

 LDX #12                \ Print the number in A at column 12, pixel row 33, on
 LDY #33                \ the second text line at the top of the screen
 JSR Print2DigitBCD-6

 PLP                    \ If the result of the above addition was positive, jump
 BPL laps1              \ to laps1 to skip printing the finished message

 LDX #53                \ Blank out the first text line at the top of the screen
 JSR PrintSecondLineGap \ and print token 53 on the second line, to give:
                        \
                        \    "                                      "
                        \    "               FINISHED               "

.laps1

 LDA leaveTrackTimer    \ If leaveTrackTimer is non-zero then the leave track
 BNE laps8              \ timer is counting down, so jump to laps8 to return
                        \ from the subroutine without updating the text at the
                        \ top of the screen

 JSR UpdatePositionInfo \ Otherwise update the position number and driver names
                        \ at the top of the screeen

 RTS                    \ Return from the subroutine

.laps2

                        \ If we get here then this is a practice or qualifying
                        \ lap

 LDX #1                 \ Add time to the lap timer at (lapMinutes lapSeconds
 JSR AddTimeToTimer     \ lapTenths), setting the C flag if the time has changed

 BIT updateDrivingInfo  \ If bit 6 of updateDrivingInfo is set then we have
 BVS laps4              \ started the first lap, so jump to laps4 to skip the
                        \ following and print the lap time only (we make the
                        \ jump with the C flag indicating whether the timer has
                        \ changed)

 BPL laps6              \ If bit 7 of updateDrivingInfo is clear then we do not
                        \ need to update the lap time, so jump to laps6 to skip
                        \ the following

                        \ If we get here then we have started the first lap of
                        \ practice or qualifying and we need to print the lap
                        \ time

 LSR updateDrivingInfo  \ Bit 7 of updateDrivingInfo is set and bit 6 is clear,
                        \ so clear bit 7 and set bit 6 of updateDrivingInfo to
                        \ indicate that we are now driving the first lap

 LDA #33                \ Set firstLapStarted = firstLapStarted + 33
 CLC                    \
 ADC firstLapStarted    \ So if we have just started the first lap, then this
 STA firstLapStarted    \ changes firstLapStarted from -33 to 0

 BEQ laps3              \ If A = 0, then we just started the first qualifying or
                        \ practice lap, so jump to laps3 to skip the following
                        \ two instructions

                        \ I am not sure if we ever get here, as the current lap
                        \ time is never printed with tenths of a second

 LDA #%00100110         \ Print the current lap time at the top of the screen in
 JSR PrintLapTime+2     \ the following format:
                        \
                        \   * %00 Minutes: No leading zeroes, print both digits
                        \   * %10 Seconds: Leading zeroes, print both digits
                        \   * %0  Tenths: Print tenths of a second
                        \   * %11 Tenths: Leading zeroes, no second digit

.laps3

 LDX #1                 \ Zero the lap timer
 JSR ZeroTimer

 BEQ laps6              \ Jump to laps6 (this BNE is effectively a JMP as the
                        \ ZeroTimer routine sets the Z flag)

.laps4

                        \ If we get here, then the C flag indicates whether the
                        \ lap timer at (lapMinutes lapSeconds lapTenths) has
                        \ changed

 LDA firstLapStarted    \ If firstLapStarted = 0 then we are currently driving
 BEQ laps5              \ the first qualifying or practice lap, so jump to laps5
                        \ to print the current lap time, but not the best lap
                        \ time (as we haven't completed a lap yet)
                        \
                        \ We jump with the C flag indicating whether the timer
                        \ has changed

 DEC firstLapStarted    \ Decrement firstLapStarted

 BNE laps6              \ If firstLapStarted is non-zero, jump to laps6 to skip
                        \ printing any lap times

 JSR PrintBestLapTime   \ Print the best lap time and the current lap time at
                        \ the top of the screen

 LDA #2                 \ Print two spaces
 JSR PrintSpaces

 BEQ laps6              \ Jump to laps6 to skip the following (this BEQ is
                        \ effectively a JMP, as PrintSpaces sets the Z flag)

.laps5

                        \ If we get here, then the C flag indicates whether the
                        \ lap timer at (lapMinutes lapSeconds lapTenths) has
                        \ changed

 BCC laps6              \ If the C flag is clear then the timer has not changed,
                        \ so jump to laps6 to skip the following instruction

 JSR PrintLapTime       \ Print the current lap time at the top of the screen in
                        \ the following format:
                        \
                        \   * Minutes: No leading zeroes, print both digits
                        \   * Seconds: Leading zeroes, print both digits
                        \   * Tenths: Do not print tenths of a second

.laps6

 LDA qualifyingTime     \ If bit 7 of qualifyingTime is set then this is a
 BMI laps8              \ practice lap (i.e. qualifyingTime = 255), so jump to
                        \ laps8 to return from the subroutine

                        \ If we get here then this is a qualifying lap, and the
                        \ number of minutes of qualifying lap time is in A, as
                        \ follows:
                        \
                        \   * A = 4 indicates 5 minutes of qualifying time
                        \
                        \   * A = 9 indicates 10 minutes of qualifying time
                        \
                        \   * A = 25 indicates 26 minutes of qualifying time

 CMP clockMinutes       \ If A < clockMinutes then we have reached the end of
 BCC laps7              \ qualifying time, so jump to laps7 to display the
                        \ time-up message

 BNE laps8              \ If A <> clockMinutes, i.e. A > clockMinutes, then
                        \ there is still some qualifying time left, so jump to
                        \ laps8 to return from the subroutine

 BIT qualifyTimeEnding  \ If bit 6 of qualifyTimeEnding is set, then we have
 BVS laps8              \ already displayed the one-minute warning, so jump to
                        \ laps8 to return from the subroutine

 LDA #%01000000         \ Set bit 6 of qualifyTimeEnding to indicate that the
 STA qualifyTimeEnding  \ one-minute warning has been displayed

 LDX #41                \ Print token 41 on the first text line at the top of
 JSR PrintFirstLine     \ the screen, to give:
                        \
                        \   "      Less than one minute to go      "

 RTS                    \ Return from the subroutine

.laps7

 LDA qualifyTimeEnding  \ If bit 7 of qualifyTimeEnding is set, then we have
 BMI laps8              \ already displayed the time-up message, so jump to
                        \ laps8 to return from the subroutine

 LDA #%11000000         \ Set bits of 6 and 7 of qualifyTimeEnding to indicate
 STA qualifyTimeEnding  \ that we have displayed both the one-minute warning and
                        \ the time-up message

 LDA #60                \ Set leaveTrackTimer = 60, so we leave the track in 60
 STA leaveTrackTimer    \ main loop iterations and return to the game menu

 LDX #42                \ Print token 42 on the first text line at the top of
 JSR PrintFirstLine     \ the screen, to give:
                        \
                        \   "           YOUR TIME IS UP!           "

.laps8

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ResetCarsOnTrack
\       Type: Subroutine
\   Category: Driving model
\    Summary: Position the cars on the track, ready for a race or qualifying lap
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The distance between each car:
\
\                         * 1 if this is a race
\
\                         * The value of trackCarSpacing if this is practice or
\                           qualifying (40 for Silverstone)
\
\ ******************************************************************************

.ResetCarsOnTrack

 STA V                  \ Store the value of A in V, so V contains the size of
                        \ the gap that we want to insert between the cars

 SEC                    \ Set bit 7 of updateLapTimes, so when we move the cars
 ROR updateLapTimes     \ forward in MoveObjectForward, the lap number and lap
                        \ time are not affected

                        \ We start by moving all the cars to the end of the
                        \ track
                        \
                        \ In Silverstone, all the cars start at an objProgress
                        \ value of &034B, so the following loop moves all the
                        \ cars forwards one step at a time, until objProgress
                        \ wraps round to 0 (which it does after reaching the
                        \ value of trackLength, which is &0400 for Silverstone)

.rcar1

 LDX #19                \ Set a loop counter in X to loop through the drivers

.rcar2

 JSR MoveObjectForward  \ Move driver X forwards along the track

 DEX                    \ Decrement the loop counter

 BPL rcar2              \ Loop back until we have processed all 20 drivers

 LDA objProgressLo      \ If objProgress for driver 0 is non-zero, jump back to
 ORA objProgressHi      \ rcar1 to repeat the above loop
 BNE rcar1

                        \ All 20 cars are now at the end of the track

 LDA #&FF               \ Set G = -1, so it can be incremented to 0 as the start
 STA G                  \ of the outer loop at rcar5

                        \ We now jump into a nested loop, with an inner loop
                        \ between rcar3 and rcar5 an outer loop between rcar3
                        \ and rcar6
                        \
                        \ We iterate round the outer loop with G from 0 to 19,
                        \ and for each outer iteration, we iterate round the
                        \ inner loop with X from G to 19
                        \
                        \ The outer loop runs through each position, while the
                        \ inner loop runs through each car behind that position,
                        \ so the cars get moved backwards around the track as a
                        \ group, with one car being dropped off after each inner
                        \ loop in the correct position
                        \
                        \ Specifically, the first iteration of the inner loop
                        \ moves the cars in positions 0 to 19 backwards, then
                        \ the cars in positions 1 to 19, then 2 to 19 and so on,
                        \ leaving a trail of cars behind it as it works
                        \ backwards so position 0 is first, then position 1, and
                        \ so on to position 19

 BNE rcar5              \ Jump to rcar5 (this BNE is effectively a JMP as A is
                        \ never zero)

.rcar3

                        \ This is the start of the inner loop, which runs
                        \ through each position from G to 19, moving each car
                        \ backwards V times (so each car moves backwards by the
                        \ distance in V)

 LDA V                  \ Set W = V, so W contains the size of the gap that we
 STA W                  \ want to insert between the cars

.rcar4

 TXA                    \ Store X on the stack
 PHA

 LDA driversInOrder,X   \ Set X to the number of driver in position X
 TAX

 JSR MoveObjectBack     \ Move driver X backwards along the track

 PLA                    \ Retrieve X from the stack
 TAX

 DEC W                  \ Decrement W

 BPL rcar4              \ Loop back until we have repeated the above W times

 INX                    \ Increment the loop counter

 CPX #20                \ Loop back until we have processed all 20 drivers
 BCC rcar3

.rcar5

                        \ This is where we join the loop with G = -1, so the
                        \ following increments G to 0 as soon as we join
                        \
                        \ This outer part of the loop runs through each position
                        \ in G, from 0 to 19, and calls the inner loop above for
                        \ each value of G

 INC G                  \ Increment G

 LDX G                  \ Set X = G, so the inner loop does G to 19

 CPX #20                \ Loop back until we have done G = 0 to 19
 BCC rcar3

                        \ At this point the cars are spaced out by the correct
                        \ distance, working backwards from position 0 at the end
                        \ of the track (i.e. just before the start line), to
                        \ position 19 at the back of the pack

                        \ We now use the currently unused driver 23 to work out
                        \ the number of track segments we need to initialise in
                        \ front of the current driver, by first moving forwards
                        \ until we are exactly 32 from the current player, then
                        \ moving backwards by 49, and then moving backwards to
                        \ the start of the track section, leaving segmentCounter
                        \ set to the total distance moved backwards

.rcar6

 LDX #23                \ Set X to driver 23

 JSR MoveObjectForward  \ Move driver 23 forwards along the track

 LDY #23                \ Set Y to driver 23

 LDX currentPlayer      \ Set X to the driver number of the current player

 SEC                    \ Set the C flag for a 16-bit calculation in the call
                        \ to GetObjectProgress

 JSR GetObjectProgress  \ Set A and T to the distance between drivers X and Y

 BCS rcar6              \ If the C flag is set then the cars are far apart, so
                        \ jump to rcar6 to keep moving driver 23 forwards

 CMP #32                \ If A <> 32, jump to rcar6 to keep moving driver 23
 BNE rcar6              \ forwards

                        \ At this point, driver 23 is a distance of exactly 32
                        \ from the current player

                        \ We now move driver 23 back by 49

 LDX #23                \ Set X to driver 23

 LDA #49                \ Set V = 49, to use as a loop counter from 49 to 1
 STA V

 STA segmentCounter     \ Set segmentCounter = 49

.rcar7

 JSR MoveObjectBack     \ Move driver 23 backwards along the track

 DEC V                  \ Decrement the loop counter

 BNE rcar7              \ Loop back until we have moved driver 23 backwards by
                        \ 49

                        \ We now move driver 23 backwards until it moves into a
                        \ new track section, incrementing segmentCounter by the
                        \ distance moved

.rcar8

 INC segmentCounter     \ Increment segmentCounter

 JSR MoveObjectBack     \ Move driver 23 backwards along the track, setting the
                        \ C flag if we move into a new track section

 BCC rcar8              \ Loop back to keep moving driver 23 backwards until it
                        \ moves into a new track section

                        \ We now move the cars to alternating sides of the track
                        \ so the grid is staggered

 LDA #80                \ Set A to 80, which we will flip between 80 and 175 to
                        \ alternate cars between the right (80) and left (175)
                        \ side of the track, where 0 is full right and 255 is
                        \ full left

 LDY #19                \ Set a loop counter in Y to loop through the positions

.rcar9

 LDX driversInOrder,Y   \ Set X to the number of driver in position X

 EOR #&FF               \ Flip A between 80 and 175

 STA carRacingLine,X    \ Set the racing line of the car on the track (i.e. its
                        \ left-right position) to the value in A

 DEY                    \ Decrement the loop counter to move on to the next
                        \ position

 BPL rcar9              \ Loop back until we have staggered the whole pack

 LDA #0                 \ Set segmentIndex = 0
 STA segmentIndex

                        \ We now call SetTrackSegment segmentCounter times,
                        \ where segmentCounter is the number of times we moved
                        \ driver 23 backwards in the above

.rcar10

 JSR SetTrackSegment    \ Initialise the next track segment

 DEC segmentCounter     \ Decrement the counter in segmentCounter

 BNE rcar10             \ Loop back until we have called SetTrackSegment
                        \ segmentCounter times

 LSR updateLapTimes     \ Clear bit 7 of updateLapTimes, so any further calls to
                        \ MoveObjectForward will update the lap number and lap
                        \ time once again

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CheckForCrash
\       Type: Subroutine
\   Category: Driving model
\    Summary: Check to see if we have crashed into the fence, and if so, display
\             the fence and make the crash sound
\
\ ******************************************************************************

.CheckForCrash

 LDA L0011              \ If L0011 < 2, jump to cras3 to return from the
 CMP #2                 \ subroutine
 BCC cras3

 LDA L005E              \ Set A = L005E

 JSR Absolute8Bit       \ Set A = |A|
                        \       = |L005E|

 CMP #96                \ If A >= 96, jump to cras1 to crash into the fence
 BCS cras1

 LDA #20                \ Set A = 20

 BIT spinSpeedHi        \ Set the flags according to the sign of spinSpeedHi, so
                        \ the call to Absolute8Bit sets the sign of A to the
                        \ same sign as spinSpeed

 JSR Absolute8Bit       \ Set A = 20 * abs(spinSpeed)

 JMP SquealTyres        \ Jump to SquealTyres to update spinSpeed and make the
                        \ tyres squeal, returning from the subroutine using a
                        \ tail call

.cras1

 DEC crashedIntoFence   \ Decrement crashedIntoFence from 0 to &FF so the main
                        \ driving loop will pause while showing the fence

 INC horizonLine        \ Increment horizonLine ???

 JSR DrawFence          \ Draw the fence that we crash into when running off the
                        \ track

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers

 LDA #4                 \ Make sound #4 (crash/contact) at the current volume
 JSR MakeSound-3        \ level

 LDA #0                 \ Set A = 0, so we can use it to reset variables to zero
                        \ in the following loop

 LDX #&1E               \ We now zero all variables from var02Lo to var12Hi, so
                        \ so set up a loop counter in X

.cras2

 STA var02Lo,X          \ Zero the X-th byte from var02Lo

 DEX                    \ Decrement the loop counter

 BPL cras2              \ Loop back until we have zeroed all variables from
                        \ var02Lo to var12Hi

 STA engineStatus       \ Set engineStatus = 0 to turn off the engine

 STA L0026              \ Set L0026 = 0

 STA soundRevCount      \ Set soundRevCount = 0 to stop the engine sound

 STA soundRevTarget     \ Set soundRevTarget = 0 to stop the engine sound

 LDA #&7F               \ Set L002D = &7F
 STA L002D

 LDA #31                \ Set L0009 = 31
 STA L0009

.cras3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FinishRace
\       Type: Subroutine
\   Category: Main loop
\    Summary: Continue running the race until all the non-player drivers have
\             finished and we have a result
\
\ ------------------------------------------------------------------------------
\
\ This routine is beavering away in the background when the game displays the
\ "PLEASE WAIT" message, after we finish qualifying or racing.
\
\ It keeps running the simulation in the background until all the other drivers
\ have finished their race or qualifying laps.
\
\ ******************************************************************************

.FinishRace

 LDA #0                 \ Set playerMoving = 0 to denote that the player's car
 STA playerMoving       \ is stationary

 STA raceStarting       \ Set raceStarting = 0 so the call to MoveCars below
                        \ will move the cars round the track

 JSR HideAllCars        \ Set all the cars to be hidden

 LDX currentPlayer      \ Clear the current player's total race time if this is
 JSR ClearTotalRaceTime \ an incomplete race

.fini1

 JSR ProcessTime        \ Increment the timers and the main loop counter, and
                        \ set the speed for the next non-player driver

 LDY #0                 \ Check for SHIFT and right arrow
 JSR ProcessShiftedKeys

 LDA configStop         \ If bit 7 of configStop is set then we must be pressing
 BMI fini4              \ either SHIFT-f0 for a pit stop or SHIFT and right
                        \ arrow to restart the game, so jump to fini4 to return
                        \ from the subroutine

                        \ If we get here then the race or qualifying lap has
                        \ finished naturally, rather than being aborted, and
                        \ this is not a pit stop
                        \
                        \ So we now need to keep running the race or qualifying
                        \ lap (albeit with everything hidden from the player) to
                        \ get the final set of results for the whole pack

 JSR MoveCars           \ Move the cars around the track, to keep the race going

 JSR ApplyDriverTactics \ Apply driving tactics to all the non-player drivers

 JSR SetPlayerPositions \ Set the current player's position, plus the position
                        \ ahead and the position behind

 LDX #19                \ We now loop through the drivers, checking whether they
                        \ have finshed the race, so set a loop counter in X for
                        \ the driver number

 LDA raceStarted        \ If bit 7 of raceStarted is set then this is a race
 BMI fini2              \ rather than practice or qualifying, so jump to fini2
                        \ to work through the drivers and wait for them all to
                        \ finish the race

                        \ If we get here, then this is a qualifying lap

 CPX currentPlayer      \ If the player is not driver 19, then jump to fini4 to
 BNE fini4              \ return from the subroutine, as there is more than one
                        \ human player and this is not the first human to race,
                        \ so we already have qualifying times for all the
                        \ drivers

                        \ If we get here, then this is a qualifying lap and the
                        \ current player is driver 19, which means this is
                        \ either the only human player, or the first human to
                        \ race
                        \
                        \ In any event, we need to make sure that we run the
                        \ qualifying lap long enough to get lap times for all
                        \ the other drivers, so we run the race for at least
                        \ 14 * 256 main loop iterations
                        \
                        \ This ensures we get lap times for all the drivers,
                        \ even if the player decides to quit qualifying early

 LDA mainLoopCounterHi  \ If the high byte main loop counter < 14, loop back to
 CMP #14                \ fini1 to keep running the race
 BCC fini1

 RTS                    \ Return from the subroutine

.fini2

                        \ If we get here, then this is a race rather than
                        \ qualifying

 LDA objectStatus,X     \ If bit 6 of driver X's objectStatus is set, then
 AND #%01000000         \ driver X has finished the racem so jump to fini3
 BNE fini3              \ to check the next driver

 LDA numberOfLaps       \ If numberOfLaps >= driver X's lap number, jump to
 CMP driverLapNumber,X  \ fini1 to keep running the race, as driver X hasn't
 BCS fini1              \ finished the race yet

.fini3

 DEX                    \ Decrement the driver counter in X

 BPL fini2              \ Loop back until all the drivers have finished the race

.fini4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PushCarOffTrack
\       Type: Subroutine
\   Category: Driving model
\    Summary: Push a car off the track and out of the race
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The driver number of the car to push off the track
\
\ ******************************************************************************

.PushCarOffTrack

 CPX #20                \ If X >= 20 then this is not a valud driver, so return
 BCS BuildPlayerCar-1   \ from the subroutine (as BuildPlayerCar-1 contains an
                        \ RTS)

 LDA carRacingLine,X    \ Fetch the car's current racing line

 AND #%01111111         \ Clear bit 7 and set bits 0, 2 and 6
 ORA #%01000101

 STA carSteering,X      \ Update the car's steering byte, so the car does the
                        \ following:
                        \
                        \   * Bit 7 clear = veer to the left
                        \
                        \   * Bit 6 set = do not apply steering in MoveCars,
                        \                 just keep the car on the track
                        \
                        \   * Bits 0-5 = set steering amount to at least 5
                        \                (%101)

 LDA #%10010001         \ Set bits 0, 4 and 7 of the car's status byte, so:
 STA carStatus,X        \
                        \   * Bit 0 set = update this carStatus byte when
                        \                 applying tactics in the
                        \                 ApplyDriverTactics routine
                        \
                        \   * Bit 4 set = do not follow the segment's steering
                        \                 line in segmentSteering, so the car
                        \                 doesn't steer around corners
                        \
                        \   * Bit 7 set = apply brakes

                        \ Fall through into ClearTotalRaceTime to set the car
                        \ object to be hidden and no longer racing, and reset
                        \ the car's total race time

\ ******************************************************************************
\
\       Name: ClearTotalRaceTime
\       Type: Subroutine
\   Category: Drivers
\    Summary: Clear a specified driver's total race time following the end of an
\             incomplete race
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The driver number
\
\ ******************************************************************************

.ClearTotalRaceTime

 LDA numberOfLaps       \ Compare numberOfLaps with the driver X's lap number
 CMP driverLapNumber,X

 LDA #%11000000         \ Set bits 6 and 7 of the status byte for driver X's car
 STA objectStatus,X     \ object, so it's hidden (bit 7) and is no longer racing
                        \ (bit 6)

 BCC clap1              \ If numberOfLaps < driver X's lap number, then the
                        \ driver has finished the race, so skip the following
                        \ instruction

 STA totalRaceMinutes,X \ The player didn't finish the race, so set the player's
                        \ total race time to &C0 minutes, which is negative and
                        \ therefore not a valid time

.clap1

 RTS                    \ Return from the subnroutine

\ ******************************************************************************
\
\       Name: BuildPlayerCar
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Build the objects for the player's car
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   xPlayerCoord        The 3D coordinates of the player's car
\
\   playerRotation      The rotation of the player's car around the y-axis
\                       (left-right)
\
\ Other entry points:
\
\   BuildPlayerCar-1    Contains an RTS
\
\ ******************************************************************************

.BuildPlayerCar

 LDX currentPlayer      \ Set X to the driver number of the current player

 STX L0045              \ Set L0045 to the driver number of the current player

 STX L0042              \ Set L0042 to the driver number of the current player

 LDY segmentIndex96     \ Build the car object for the current player using
 JSR BuildCarObjects    \ track segment segmentIndex96, returning the car's 3D
                        \ coordinates in xVector4

 LDX #2                 \ We are about to copy the three axes of the resulting
                        \ vectors, so set an axis counter in X

.bpla1

 LDA xVector4Lo,X       \ Copy the car's 3D coordinates from xVector4 into
 STA xPlayerCoordLo,X   \ xPlayerCoord
 LDA xVector4Hi,X
 STA xPlayerCoordHi,X

 DEX                    \ Decrement the axis counter

 BPL bpla1              \ Loop back until we have copied all three axes

 LDA segmentIndex96     \ Set A = segmentIndex96 + 3
 CLC                    \
 ADC #3                 \ to move on to the next track segment

 CMP #120               \ If A < 120, then we haven't reached the end of the
 BCC bpla2              \ track segment buffer, so jump to bpla2 to store the
                        \ updated value

 LDA #0                 \ We just reached the end of the track segment buffer,
                        \ so set A = 0 to wrap round to the start

.bpla2

 TAY                    \ Set Y to the updated track segment index * 3

 LDX L0045              \ Set X to the driver number of the current player

 JSR BuildCarObjects    \ Build the car object for the current player using the
                        \ updated track segment, returning the object's rotation
                        \ about the y-axis in objRotation

 LDA objRotationLo,X    \ Copy the low byte of the rotation about the y-axis to
 STA playerRotationLo   \ playerRotationLo

 LDA objRotationHi,X    \ Copy the high byte of the rotation about the y-axis to
 EOR directionFacing    \ playerRotationHi, flipping the sign of the coordinate
 STA playerRotationHi   \ if we are facing backwards along the track

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetSectionCoord
\       Type: Subroutine
\   Category: Track
\    Summary: Copy a three-part 16-bit coordinate from the track section data
\
\ ------------------------------------------------------------------------------
\
\ This routine is normally called with X as a multiple of 3 in the range 0 to
\ 117, representing track segments 0 to 39. The routine copies the following
\ section coordinates from the track section data for section Y * 8:
\
\   * xTrackSectionI
\   * yTrackSectionI
\   * zTrackSectionI
\
\ and stores them in the X-th coordinate in (xSegmentCoordI, ySegmentCoordI,
\ zSegmentCoordI).
\
\ Specifically, this copies data from the Y-th track section entry:
\
\   (xTrackSectionIHi xTrackSectionILo)
\   (yTrackSectionIHi yTrackSectionILo)
\   (zTrackSectionIHi zTrackSectionILo)
\
\ and stores it in the X-th track segment:
\
\   (xSegmentCoordIHi xSegmentCoordILo)
\   (ySegmentCoordIHi ySegmentCoordILo)
\   (zSegmentCoordIHi zSegmentCoordILo)
\
\ This routine is also called with X = &FD, in which case it copies the
\ following:
\
\   Y-th (xTrackSectionIHi xTrackSectionILo) to (xVector4Hi xVector4Lo)
\   Y-th (yTrackSectionIHi yTrackSectionILo) to (yVector4Hi yVector4Lo)
\   Y-th (zTrackSectionIHi zTrackSectionILo) to (zVector4Hi zVector4Lo)
\
\ Arguments:
\
\   Y                   The number of the track section * 8 whose coordinates we
\                       want to fetch
\
\   X                   The place to store the data:
\
\                         * 0-117 = The index * 3 of the track segment where we
\                                   store the coordinates
\
\                         * &FD = Copy to (xVector4, yVector4, zVector4)
\
\ ******************************************************************************

.GetSectionCoord

 LDA xTrackSectionILo,Y \ Copy the following 16-bit coordinates:
 STA xSegmentCoordILo,X \
 LDA yTrackSectionILo,Y \   * The Y-th xTrackSectionI to the X-th xSegmentCoordI
 STA ySegmentCoordILo,X \
 LDA zTrackSectionILo,Y \   * The Y-th yTrackSectionI to the X-th ySegmentCoordI
 STA zSegmentCoordILo,X \
                        \   * The Y-th zTrackSectionI to the X-th zSegmentCoordI
                        \
                        \ starting with the low bytes

 LDA xTrackSectionIHi,Y \ And then the high bytes
 STA xSegmentCoordIHi,X
 LDA yTrackSectionIHi,Y
 STA ySegmentCoordIHi,X
 LDA zTrackSectionIHi,Y
 STA zSegmentCoordIHi,X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetSectionCoords
\       Type: Subroutine
\   Category: Track
\    Summary: Copy two three-part 16-bit coordinates from the track section data
\
\ ------------------------------------------------------------------------------
\
\ This routine is normally called with X as a multiple of 3 in the range 0 to
\ 117, representing track segments 0 to 39. The routine copies the following
\ track section coordinates from the track section data for section Y * 8:
\
\   * xTrackSectionI
\   * yTrackSectionI
\   * zTrackSectionI
\
\ and stores them in the X-th coordinate in (xSegmentCoordI, ySegmentCoordI,
\ zSegmentCoordI). It also copies the following track section coordinates:
\
\   * xTrackSectionO
\   * yTrackSectionI
\   * zTrackSectionO
\
\ and stores them in the X-th coordinate in (xSegmentCoordO, ySegmentCoordO,
\ zSegmentCoordO). Note that the y-coordinate is set to the same value as the
\ y-coordinate from the first copy.
\
\ It also sets thisVectorNumber to trackSectionFrom for the Y-th track section
\ data.
\
\ Specifically, this copies data from the Y-th track section entry:
\
\   (xTrackSectionIHi xTrackSectionILo)
\   (yTrackSectionIHi yTrackSectionILo)
\   (zTrackSectionIHi zTrackSectionILo)
\   (xTrackSectionOHi xTrackSectionOLo)
\   (yTrackSectionIHi yTrackSectionILo)
\   (zTrackSectionOHi zTrackSectionOLo)
\   trackSectionFrom
\
\ and stores it in the X-th track segment:
\
\   (xSegmentCoordIHi xSegmentCoordILo)
\   (ySegmentCoordIHi ySegmentCoordILo)
\   (zSegmentCoordIHi zSegmentCoordILo)
\   (xSegmentCoordOHi xSegmentCoordOLo)
\   (ySegmentCoordOHi ySegmentCoordOLo)
\   (zSegmentCoordOHi zSegmentCoordOLo)
\   thisVectorNumber
\
\ Arguments:
\
\   Y                   The number of the track section * 8 whose coordinates we
\                       want to fetch
\
\   X                   The index * 3 of the track segment where we store the
\                       coordinates
\
\ ******************************************************************************

.GetSectionCoords

 JSR GetSectionCoord    \ Copy the following 16-bit coordinate:
                        \
                        \   * The Y-th xTrackSectionI to the X-th xSegmentCoordI
                        \
                        \   * The Y-th yTrackSectionI to the X-th ySegmentCoordI
                        \
                        \   * The Y-th zTrackSectionI to the X-th zSegmentCoordI

 LDA xTrackSectionOLo,Y \ Copy the following 16-bit coordinate:
 STA xSegmentCoordOLo,X \
 LDA zTrackSectionOLo,Y \   * The Y-th xTrackSectionO to the X-th xSegmentCoordO
 STA zSegmentCoordOLo,X \
                        \   * The Y-th zTrackSectionO to the X-th zSegmentCoordO
                        \
                        \ starting with the low bytes

 LDA xTrackSectionOHi,Y \ And then the high bytes
 STA xSegmentCoordOHi,X
 LDA zTrackSectionOHi,Y
 STA zSegmentCoordOHi,X

 LDA trackSectionFrom,Y \ Set thisVectorNumber = the Y-th trackSectionFrom
 STA thisVectorNumber

                        \ Fall through into CopySectionData to copy the
                        \ following 16-bit coordinate:
                        \
                        \   * The Y-th yTrackSectionI to the X-th ySegmentCoordO
                        \
                        \ This works because the call to GetSectionCoord already
                        \ stored the Y-th yTrackSectionI in the X-th
                        \ ySegmentCoordI, and the following now copies that into
                        \ the X-th ySegmentCoordO

\ ******************************************************************************
\
\       Name: CopySectionData
\       Type: Subroutine
\   Category: Track
\    Summary: Copy a 16-bit y-coordinate from the track section data
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   Copy X-th (ySegmentCoordIHi ySegmentCoordILo) to
\                       (ySegmentCoordOHi ySegmentCoordOLo)
\
\ ******************************************************************************

.CopySectionData

 LDA ySegmentCoordILo,X \ Copy the following 16-bit coordinate:
 STA ySegmentCoordOLo,X \
                        \   * The X-th ySegmentCoordI to the X-th ySegmentCoordO
                        \
                        \ starting with the low byte

 LDA ySegmentCoordIHi,X \ And then the high byte
 STA ySegmentCoordOHi,X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SetSegmentIndex96
\       Type: Subroutine
\   Category: Track
\    Summary: Set the segmentIndex96 index to 96 + the current track section
\             index * 3
\
\ ******************************************************************************

.SetSegmentIndex96

 LDA segmentIndex       \ Set A = the current track segment index * 3 - 96
 SEC
 SBC #96

 BPL zsta1              \ If A < 0, set A = A + 120, so the index number wraps
 CLC                    \ around to the end of the stack
 ADC #120

.zsta1

 STA segmentIndex96     \ Set segmentIndex96 to the updated index

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetTrackSegment
\       Type: Subroutine
\   Category: Track
\    Summary: Get the track section coordinates and flags from the track data
\             and populate the current track segment
\
\ ------------------------------------------------------------------------------
\
\ This routine is called when we move into a new track section, and is used to
\ populate the current track segment with the data from the start of the new
\ track section.
\
\ Arguments:
\
\   sectionBehind       The number * 8 of the track section behind us, for when
\                       we are facing backwards
\
\   segmentIndex        The index * 3 of the current track segment
\
\   L0062               If non-zero, set L0006 = 6
\
\ Returns:
\
\   L0007               Bits 0-2 from trackSectionData, or 2 if we are facing
\                       backwards
\
\   xSegmentCoordI      Start coordinates for the inside of the track section,
\                       stored in the current track segment
\
\   xSegmentCoordO      Start coordinates for the outside of the track section,
\                       stored in the current track segment
\
\   thisVectorNumber    The vector number from the start of the track section
\
\   thisSectionFlags    The track section flags for the section containing
\                       driver 23
\
\   segmentFlags        Zeroed for the current track segment
\
\ ******************************************************************************

.GetTrackSegment

 LDX segmentIndex       \ Set X to the index * 3 of the current track segment

 LDY #6                 \ Set Y = 6

 STY newSegmentFetched  \ Set newSegmentFetched to a non-zero value to indicate
                        \ that we are fetching a new segment

 LDA L0062              \ If L0062 = 0, skip the following instruction
 BEQ gets1

 STY L0006              \ L0062 <> 0, so set L0006 = 6

.gets1

 LDA directionFacing    \ If our car is facing backwards, jump to gets2
 BMI gets2

 LDY objTrackSection+23 \ Set Y to the number * 8 of the track section for
                        \ driver 23

 JSR GetSectionCoords   \ Copy the start coordinates for the track section
                        \ into xSegmentCoordI and xSegmentCoordO, and set
                        \ thisVectorNumber to trackSectionFrom

 LDA trackSectionData,Y \ Set A = trackSectionData for the track section, so
                        \ bits 0-2 can be set as the value for L0007 below

 JMP gets3              \ Jump to gets3 to skip the following

.gets2

 LDY sectionBehind      \ Set Y to the number * 8 of the track section in
                        \ sectionBehind

 JSR GetSectionCoords   \ Copy the start coordinates for the track section
                        \ into xSegmentCoordI and xSegmentCoordO, and set
                        \ thisVectorNumber to trackSectionFrom

 JSR UpdateVectorNumber \ Update thisVectorNumber to the next vector along the
                        \ track in the direction we are facing

 LDA #2                 \ Set A = 2, to use as the value for L0007 below

.gets3

 AND #%00000111         \ Set L0007 = bits 0-2 from A
 STA L0007

 LDY objTrackSection+23 \ Set Y to the number * 8 of the track section for
                        \ driver 23

 LDA trackSectionFlag,Y \ Set thisSectionFlags to the track section flags for
 STA thisSectionFlags   \ the section containing driver 23

 LDA #0                 \ Zero the flags for the current track segment
 STA segmentFlags,X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ShuffleSegmentData
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.ShuffleSegmentData

 LDX #44                \ Set X = 44 so we start by shuffling the first batch:
                        \
                        \   * var23Lo+0-4 to var23Lo+1-5
                        \
                        \   * var23Hi+0-4 to var23Hi+1-5
                        \
                        \   * yVergeLeft+0-4 to yVergeLeft+1-5
                        \
                        \ This works because:
                        \
                        \   * var24Lo + 40 = var23Lo
                        \
                        \   * var24Hi + 40 = var23Hi
                        \
                        \   * yVergeRight + 40 = yVergeLeft

.shuf1

 LDA var24Lo,X          \ Shuffle the X-th byte of var24Lo up by one
 STA var24Lo+1,X

 LDA var24Hi,X          \ Shuffle the X-th byte of var24Hi up by one
 STA var24Hi+1,X

 LDA yVergeRight,X      \ Shuffle the X-th byte of yVergeRight up by one
 STA yVergeRight+1,X

 CPX #40                \ If X <> 40 then we are either still shuffling the
 BNE shuf2              \ first batch and haven't yet done the last shuffle, or
                        \ we are already shuffling the second batch, so in
                        \ either case jump to shuf2 to skip the following

 LDX #5                 \ We have just done the last shuffle in the first batch,
                        \ so set X = 5 so we now shuffle the second batch:
                        \
                        \   * var24Lo+0-4 to var24Lo+1-5
                        \
                        \   * var24Hi+0-4 to var24Hi+1-5
                        \
                        \   * yVergeRight+0-4 to yVergeRight+1-5

.shuf2

 DEX                    \ Decrement the loop counter

 BPL shuf1              \ Loop back until we have shuffled all the bytes in both
                        \ batches

 LDA #6                 \ Set L0005 = 6 - L0007
 SEC
 SBC L0007
 STA L0005

 JSR SetSegmentPointers \ ???

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SetSegmentPointers
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\   * L0006 = max(min(L0006 + 1, 6), L0005)
\
\   * L0006 = min(L0008 + 2, L0006)
\
\   * If L0005 <= L0008 + 1 < 6, set L0008 = L0008 + 1, else set L0008 = 5
\
\ ******************************************************************************

.SetSegmentPointers

 LDX L0006              \ Set X = L0006 + 1
 INX

 CPX #6                 \ If X < 6, jump to segp1 to skip the following
 BCC segp1

 LDX #6                 \ Set X = 6, so the maximum value of X is 6

.segp1

 CPX L0005              \ If X >= L0005, jump to segp2 to skip the following
 BCS segp2

 LDX L0005              \ Set X = L0005, so the minimum value of X is L0005

.segp2

 STX L0006              \ Store the updated value of X in L0006, so:
                        \
                        \   L0006 = max(min(L0006 + 1, 6), L0005)
                        \
                        \ i.e. L0006 + 1, restricted to the range L0005 to 6

 LDX L0008              \ Set X = L0008 + 1
 INX

                        \ Fall through into SetSegmentPointer to set L0006 and
                        \ L0008:
                        \
                        \   * L0006 = min(L0008 + 2, L0006)
                        \
                        \   * If L0005 <= L0008 + 1 < 6, set L0008 = L0008 + 1,
                        \     else set L0008 = 5

\ ******************************************************************************
\
\       Name: SetSegmentPointer
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\   * L0006 = min(X + 1, L0006)
\
\   * If L0005 <= X < 6, set L0008 = X, else set L0008 = 5
\
\ ******************************************************************************

.SetSegmentPointer

 INX                    \ Set X = X + 1

 CPX L0006              \ If X >= L0006, jump to sseg1 to skip the following
 BCS sseg1

 STX L0006              \ X < L0006, so set L0006 = X, so L0006 is set to the
                        \ lower of X and L0006

.sseg1

 DEX                    \ Set X = X - 1
                        \
                        \ so X is back to its original value
                        
                        \ If L0005 <= X < 6, set L0008 = X, else set L0008 = 5

 CPX L0005              \ If X >= L0005, jump to sseg2 to skip the following
 BCS sseg2

 LDX #5                 \ X < L0005, so set X = 5, so we set L0008 = 5 below

.sseg2

 CPX #6                 \ If X < 6, jump to sseg3 to skip the following
 BCC sseg3

 LDX #5                 \ X >= 6, so set X = 5, so we set L0008 = 5 below

.sseg3

 STX L0008              \ Store the updated value of X in L0008

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MovePlayerForward
\       Type: Subroutine
\   Category: Driving model
\    Summary: Move the player's car forwards
\
\ ******************************************************************************

.MovePlayerForward

 CLC                    \ Clear the C flag so the call to MovePlayer moves the
                        \ player's car in the direction it is pointing

 JSR MovePlayer         \ Drive the player's car forwards

                        \ Fall through into SetTrackSegment to set up the
                        \ next track segment

\ ******************************************************************************
\
\       Name: SetTrackSegment (Part 1 of 1)
\       Type: Subroutine
\   Category: Track
\    Summary: Set up the next track segment
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates the coordinates, flags and cornering data for the next
\ track segment. It does this in three parts:
\
\   1. Initialise up the new track segment, and fetch the track vector for the
\      new track segment
\
\   2. Set the flags for the new track segment
\
\   3. Add the track vector from part 1 to the coordinates for the current track
\      segment to get the coordinates for the next track segment
\
\ This part does the following:
\
\   * Move the index on to the next track segment
\
\   * Initialise the new track segment if we are entering a new track section
\
\   * Set pastHalfway
\
\   * Set (SS T), (TT U) and (UU V) to the xTrackVectorI, yTrackVectorI and
\     zTrackVectorI vectors
\
\ ******************************************************************************

.SetTrackSegment

 LDA segmentIndex       \ Set A to the index * 3 of the current track segment

 STA segmentIndexPrev   \ Store A in segmentIndexPrev, as we are about to move
                        \ on to the next track segment

 CLC                    \ Set A = segmentIndex + 3
 ADC #3                 \
                        \ to move on to the next track segment

 CMP #120               \ If A < 120, then we haven't reached the end of the
 BCC sets1              \ track segment buffer, so jump to sets1 to store the
                        \ updated value

 LDA #0                 \ We just reached the end of the track segment buffer,
                        \ so set A = 0 to wrap round to the start

.sets1

 STA segmentIndex       \ Set segmentIndex to the index * 3 of the new track
                        \ segment

 LDX #23                \ Set X to driver 23

 LDA directionFacing    \ If our car is facing backwards, jump to sets3
 BMI sets3

 LDA trackSectionCount  \ Set A to half the total number of track sections * 4
 LSR A

 AND #%11111000         \ Reduce A to the nearest multiple of 8

 CMP objTrackSection,X  \ If A <> the number of the track section * 8 for driver
 BNE sets2              \ 23, then we are not halfway through all the track
                        \ sections, so jump to sets2

                        \ If we get here then driver 23 is at the halfway point
                        \ round the track in terms of track section numbers

 LDA #1                 \ Set pastHalfway = 1, to denote that driver 23 is in
 STA pastHalfway        \ the second half of the track

.sets2

 JSR MoveObjectForward  \ Move driver 23 forwards along the track, setting the
                        \ C flag if this moves the driver into the next track
                        \ section

 BCC sets4              \ If driver 23 is still in the same track section, jump
                        \ to sets4

 JSR GetTrackSegment    \ Otherwise we just moved into a new track section, so
                        \ get the track section coordinates and flags from the
                        \ track data and populate the current track segment,
                        \ setting thisVectorNumber to the number of the track
                        \ vector for the new track segment

 JMP sets13             \ Jump to sets13 to finish setting up the track segment,
                        \ skipping the part that sets the coordinates and flags,
                        \ as those have just been set when creating the entry
                        \ for the new track section

.sets3

                        \ If we get here then our car is facing backwards

 LDA objTrackSection+23 \ Set sectionBehind to the number * 8 of the track
 STA sectionBehind      \ section for driver 23

 JSR MoveObjectBack     \ Move driver 23 backwards along the track, setting the
                        \ C flag if this moves the driver into the next track
                        \ section

 BCC sets4              \ If driver 23 is still in the same track section, jump
                        \ to sets4

 JSR GetTrackSegment    \ Otherwise we just moved into a new track section, so
                        \ get the track section coordinates and flags from the
                        \ track data and populate the current track segment,
                        \ setting thisVectorNumber to the number of the track
                        \ vector for the new track segment

.sets4

 LDY thisVectorNumber   \ Set Y to the number of the track vector for the new
                        \ track segment

 JSR GetTrackData       \ Set (SS T), (TT U) and (UU V) to the coordinates of
                        \ the track vector for the new track segment, so:
                        \
                        \   [ (SS T) ]   [ xTrackVectorI ]
                        \   [ (TT U) ] = [ yTrackVectorI ]
                        \   [ (UU V) ]   [ zTrackVectorI ]
                        \
                        \ In other words, they contain the vector that we need
                        \ to add to the previous track segment's coordinates in
                        \ order to get the coordinates for the new track segment
                        \
                        \ Or, even simpler, they contain the vector from the
                        \ previous track segment's coordinates to the new one

\ ******************************************************************************
\
\       Name: SetTrackSegment (Part 2 of 3)
\       Type: Subroutine
\   Category: Track
\    Summary: Set the flags for the new track segment
\
\ ------------------------------------------------------------------------------
\
\ This part does the following:
\
\   * Set the flags for the new track segment
\
\ Set the flags for the new track segment to the flags for the track section
\ from the track data, but with these changes:
\
\ Curve:
\
\   * If driver 23 is not exactly halfway through the section, clear bits 3-5
\
\ Straight:
\
\   * If driver 23's progress through the section is not in the range 1 to 9,
\     clear bits 1, 2
\
\   * If the distance yet to cover in this section = 14 or 21, clear bit 5
\
\   * If the distance yet to cover in this section <> 7, 14 or 21, clear bits
\     3, 4, 5
\
\ ******************************************************************************

 LDX segmentIndex       \ Set X to the index * 3 of the new track segment

 LDA thisSectionFlags   \ Store bit 0 of the current section's flags on the
 LSR A                  \ stack using the C flag
 PHP

 LDA thisSectionFlags   \ Set A to the current section's flags

 BCS sets6              \ If bit 0 of the current section's flag byte is set,
                        \ then this is a curved section, so jump to sets6 with
                        \ A set to the current section's flags, so the new
                        \ track segment retains the same flags

                        \ If we get here then this is a straight track section

 LDY objSectionCount+23 \ Set Y to driver 23's progress through the track
                        \ section

 CPY #1                 \ If Y < 1, jump to sets5
 BCC sets5

 CPY #10                \ If Y < 10, jump to sets6 with A set to
 BCC sets6              \ thisSectionFlags

.sets5

                        \ If we get here then Y < 1 or Y >= 10

 AND #%11111001         \ Clear bits 1 and 2 of the current section's flags in A

.sets6

 STA W                  \ Store A in W, so W contains:
                        \
                        \   * The current section's flags if this is a curve, or
                        \     if this is a straight and driver 23's progress
                        \     through the track section is in the range 1 to 9
                        \
                        \   * The current section's flags with bits 1 and 2
                        \     cleared otherwise (i.e. if this is a straight and
                        \     driver 23's progress through the track section is
                        \     not in the range 1 to 9)
                        \
                        \ We use W to build the flags for the new track segment

 LDY objTrackSection+23 \ Set Y to the number * 8 of the track section for
                        \ driver 23

 LDA trackSectionSize,Y \ Set A to the size of the track section for driver 23

 PLP                    \ If bit 0 of the current section's flag byte is clear,
 BCC sets7              \ then this is a straight section, so jump to sets7 with
                        \ A set to the size of the track section for driver 23

                        \ If we get here then this is a curved track section

 LSR A                  \ Set Y = A / 2
 TAY                    \
                        \ So Y contains half the size of the curved section

 LDA W                  \ Set A = W, which contains the flags we are building
                        \ for the new track segment

 CPY objSectionCount+23 \ If Y = driver 23's progress through the track section,
 BEQ sets10             \ then the driver is exactly halfway round the curve, so
                        \ jump to sets10 to store A in the track segment's flags

 BNE sets8              \ Otherwise jump to sets8 to clear bits 3-5 of A before
                        \ storing it in the track segment's flags

.sets7

                        \ If we get here then this is a straight section and A
                        \ is set to the size of the track section for driver 23

 SEC                    \ Set Y = A - driver 23's progress through the track
 SBC objSectionCount+23 \ section
 TAY                    \
                        \ So Y contains the length of the track section that
                        \ driver 23 has yet to cover

 LDA W                  \ Set A = W, which contains the flags we are building
                        \ for the new track segment

 CPY #7                 \ If Y = 7, jump to sets10 to store A in the track
 BEQ sets10             \ segment's flags

 CPY #14                \ If Y = 14 or 21, jump to sets9 to clear bit 5 of A
 BEQ sets9              \ and store it in the track segment's flags
 CPY #21
 BEQ sets9

                        \ Otherwise we clear bits 3-5 of A and store it in the
                        \ track segment's flags

.sets8

 AND #%11100111         \ Clear bits 3 and 4 of A

.sets9

 AND #%11011111         \ Clear bit 5 of A

.sets10

 AND thisSectionFlags   \ Clear any bits in A that are already clear in the
                        \ current section's flags, to ensure that the track
                        \ segment's flags only have flags set if they are set in
                        \ the track section's flags

 STA segmentFlags,X     \ Set the flags for the new track segment to A

\ ******************************************************************************
\
\       Name: SetTrackSegment (Part 3 of 3)
\       Type: Subroutine
\   Category: Track
\    Summary: Set the inner and outer track coordinates for the new track
\             segment
\
\ ------------------------------------------------------------------------------
\
\ This part calculates the inner track section coordinates for the new track
\ segment, as follows:
\
\   [ xSegmentCoordI ]   [ previous xSegmentCoordI ]   [ xTrackVectorI ]
\   [ ySegmentCoordI ] = [ previous ySegmentCoordI ] + [ yTrackVectorI ]
\   [ zSegmentCoordI ]   [ previous zSegmentCoordI ]   [ zTrackVectorI ]
\
\ It then calculates the outer track section coordinates for the new track
\ segment, as follows:
\
\   [ xSegmentCoordO ]   [ xSegmentCoordI ]   [ xTrackVectorO ]
\   [ ySegmentCoordO ] = [ ySegmentCoordI ] + [       0       ] * 4
\   [ zSegmentCoordO ]   [ zSegmentCoordI ]   [ zTrackVectorO ]
\
\ ******************************************************************************

 LDY segmentIndexPrev   \ Set Y to the index * 3 of the previous track segment

 JSR AddVectors         \ Add the (SS T), (TT U) and (UU V) vectors to the
                        \ inner track section coordinates for the previous
                        \ track segment and store the result in the current
                        \ track segment:
                        \
                        \                                 [ (SS T) ]
                        \   this entry = previous entry + [ (TT U) ]
                        \                                 [ (UU V) ]
                        \
                        \ This correctly sets the inner track coordinates for
                        \ the new track segment, as we set the (SS T), (TT U)
                        \ and (UU V) vectors at the end of part 1 to the vector
                        \ from the previous track segment's coordinates to the
                        \ new one
                        \
                        \ In other words, this does the following:
                        \
                        \   [ xSegmentCoordI ]   [ previous xSegmentCoordI ]
                        \   [ ySegmentCoordI ] = [ previous ySegmentCoordI ]
                        \   [ zSegmentCoordI ]   [ previous zSegmentCoordI ]
                        \
                        \                        [ xTrackVectorI ]
                        \                      + [ yTrackVectorI ]
                        \                        [ zTrackVectorI ]

 JSR CopySectionData    \ Copy the X-th ySegmentCoordI to ySegmentCoordO

                        \ We now set the outer track coordinates for the new
                        \ track segment, as follows:
                        \ 
                        \   [ xSegmentCoordO ]   [ xSegmentCoordI ]   
                        \   [ ySegmentCoordO ] = [ ySegmentCoordI ]
                        \   [ zSegmentCoordO ]   [ zSegmentCoordI ]
                        \
                        \                        [ xTrackVectorO ]
                        \                      + [       0       ] * 4
                        \                        [ zTrackVectorO ]
                        \
                        \ Note that we don't have to do the y-coordinate
                        \ addition, as ySegmentCoordO was already set to
                        \ ySegmentCoordI when the track segment was set up

 LDY thisVectorNumber   \ Set Y to the number of the track vector for the new
                        \ track segment

 LDA #0                 \ Set SS = 0, to use as the high byte in (SS A) below
 STA SS

 STA UU                 \ Set UU = 0, to use as the high byte in (UU A) below

 LDA xTrackVectorO,Y    \ Set A = the 3D x-coordinate of the outer track vector
                        \ for the new track segment

 BPL sets11             \ If A is negative, decrement SS to &FF so (SS A) has
 DEC SS                 \ the correct sign

.sets11

 ASL A                  \ Set (SS A) = (SS A) * 4
 ROL SS                 \            = xTrackVectorO * 4
 ASL A
 ROL SS

 CLC                    \ Add the inner track section x-coordinate and the outer
 ADC xSegmentCoordILo,X \ x-coordinate * 4 to get the outer x-coordinate for the
 STA xSegmentCoordOLo,X \ new track segment, starting with the low bytes

 LDA SS                 \ And then the high bytes
 ADC xSegmentCoordIHi,X
 STA xSegmentCoordOHi,X

 LDA zTrackVectorO,Y    \ Set A = the z-coordinate of the outer track vector for
                        \ the new track segment

 BPL sets12             \ If A is negative, decrement UU to &FF so (UU A) has
 DEC UU                 \ the correct sign

.sets12

 ASL A                  \ Set (UU A) = (UU A) * 4
 ROL UU                 \            = zTrackVectorO * 4
 ASL A
 ROL UU

 CLC                    \ Add the inner track section z-coordinate and the outer
 ADC zSegmentCoordILo,X \ z-coordinate * 4 to get the outer z-coordinate for the
 STA zSegmentCoordOLo,X \ new track segment, starting with the low bytes

 LDA UU                 \ And then the high bytes
 ADC zSegmentCoordIHi,X
 STA zSegmentCoordOHi,X

 JSR UpdateCurveVector  \ If this is a curved track section, update the value of
                        \ thisVectorNumber to the next track vector along the
                        \ track in the direction we are facing

.sets13

 LDX segmentIndex       \ Set X to the index * 3 of the new track segment

 LDA thisVectorNumber   \ Set segmentVector for the new track segment to the
 STA segmentVector,X    \ number of the track vector for the track section
                        \ (which will be unchanged from the previous section if
                        \ this is a straight, or the next track vector if this
                        \ is a curve)

 JSR SetSegmentIndex96  \ Update the segmentIndex96 index to be 96 ahead of
                        \ segmentIndex

 JSR GetBestRacingLine  \ Set segmentSteering for the new track segment to the
                        \ best racing line to take at this point in the section

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UpdateCurveVector
\       Type: Subroutine
\   Category: Track
\    Summary: Move to the next track vector along in the direction we are
\             facing, but only for curved track sections
\
\ ******************************************************************************

.UpdateCurveVector

 LDA thisSectionFlags   \ If bit 0 of the track section's flag byte is clear,
 AND #1                 \ then this is a straight track section, so return from
 BEQ sub_C13FB-1        \ the subroutine (as sub_C13FB-1 contains an RTS)

                        \ Otherwise this is a curved track section, so fall
                        \ through into UpdateVectorNumber to update the value
                        \ of thisVectorNumber to the number of the next vector
                        \ along the track

\ ******************************************************************************
\
\       Name: UpdateVectorNumber
\       Type: Subroutine
\   Category: Track
\    Summary: Move to the next track vector along in the direction we are facing
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   thisVectorNumber    Set to the number of the next track vector along the
\                       track in the direction in which we are facing
\
\ ******************************************************************************

.UpdateVectorNumber

 LDA directionFacing    \ If our car is facing backwards, jump to uvec1
 BMI uvec1

 LDY thisVectorNumber   \ Set Y to the current track vector number

 INY                    \ Increment Y to point to the next track vector number
                        \ along the track

 CPY trackVectorCount   \ If Y <> trackVectorCount, then we have not reached the
 BNE uvec3              \ last vector, so jump to uvec3 to store the new value
                        \ of thisVectorNumber

 LDY #0                 \ If we get here then we have reached the last vector,
                        \ so set Y = 0 to wrap around to the first vector

 BEQ uvec3              \ Jump to uvec3 to set thisVectorNumber = 0 (this BEQ is
                        \ effectively a JMP as Y is always zero)

.uvec1

                        \ If we get here then our car is facing backwards

 LDY thisVectorNumber   \ Set Y to the current track vector number

 BNE uvec2              \ If Y <> 0, then we are not on the first track vector,
                        \ so jump to uvec2 to decrement to the previous vector

 LDY trackVectorCount   \ Set Y = trackVectorCount, so we wrap around to the
                        \ last vector

.uvec2

 DEY                    \ Decrement Y to point to the previous track vector
                        \ number, i.e. backwards along the track

.uvec3

 STY thisVectorNumber   \ Update thisVectorNumber with the new value that we set
                        \ above

.uvec4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C13FB
\       Type: Subroutine
\   Category: Driving model
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   sub_C13FB-1         Contains an RTS
\
\ ******************************************************************************

.sub_C13FB

 LDA #6                 \ Set L0006 = 6
 STA L0006

 LDX #64                \ Set X = 64, so the call to TurnPlayerAround
                        \ initialises 64 track segments in the new direction

 STX L001A              \ Set L001A = 64

 JSR TurnPlayerAround   \ Turn the player around and initialise 64 track
                        \ segments in the new direction

 LDA #0                 \ Set L001A = 0
 STA L001A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MovePlayerBack
\       Type: Subroutine
\   Category: Driving model
\    Summary: Move the player's car backwards (i.e. in reverse gear)
\
\ ------------------------------------------------------------------------------
\
\ This routine reverses the player, updating the track segments in both
\ directions.
\
\ ******************************************************************************

.MovePlayerBack

 SEC                    \ Set the C flag so the call to MovePlayer moves the
                        \ player's car in the opposite direction to which it is
                        \ pointing

 JSR MovePlayer         \ Drive the player's car backwards (i.e. reverse it)

 LDX #40                \ Set X = 40, so the call to TurnPlayerAround
                        \ initialises 64 track segments in the new direction

 STX L0062              \ Set L0062 to a non-zero value, so the following calls
                        \ set L0006 to 6

 JSR TurnPlayerAround   \ Turn the player around and initialise 40 track
                        \ segments in the new direction

 LDX #39                \ Set X = 39, so the call to TurnPlayerAround
                        \ initialises 64 track segments in the new direction

 JSR TurnPlayerAround   \ Turn the player back around and initialise 39 track
                        \ segments in the new direction

 LDA #0                 \ Set L0062 = 0
 STA L0062

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: TurnPlayerAround
\       Type: Subroutine
\   Category: Driving model
\    Summary: Turn the player around and initialise the specified number of
\             track segments in the new direction
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of track segments to initialise in the new
\                       direction
\
\ Returns:
\
\   directionFacing     Bit 7 is flipped to point us in the opposite direction
\
\ ******************************************************************************

.TurnPlayerAround

 LDA directionFacing    \ Flip bit 7 of directionFacing to denote that our car
 EOR #%10000000         \ is facing in the other direction
 STA directionFacing

 JSR UpdateCurveVector  \ If this is a curved track section, update the value of
                        \ thisVectorNumber to the next track vector along the
                        \ track in the new direction we are facing

 STX segmentCounter     \ We now want to initialise X track segments in the new
                        \ direction, so set a loop counter in segmentCounter
                        \ that starts from X and counts down

.turn1

 JSR SetTrackSegment    \ Initialise the next track segment

 DEC segmentCounter     \ Decrement the look counter

 BNE turn1              \ Loop back until we have set all the stack entries

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MovePlayer
\       Type: Subroutine
\   Category: Driving model
\    Summary: Move the player's car forwards or backwards
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   C flag              Controls the direction of movement:
\
\                         * Clear = move the car in the direction it is pointing
\                           (i.e. drive forwards)
\
\                         * Set = reverse the car
\
\ ******************************************************************************

.MovePlayer

 LDX currentPlayer      \ Set X to the driver number of the current player

 ROR A                  \ If just one of the C flag and bit 7 of directionFacing
 EOR directionFacing    \ is set (but not both), jump to play1 to move the car
 BMI play1              \ backwards along the track
                        \
                        \ In other words, we move backwards if:
                        \
                        \   * C is clear and the car is facing backwards along
                        \     the track, in which case it is driving forwards
                        \     but going backwards around the track
                        \
                        \   * C is set and the car is facing forwards along the
                        \     track, in which case it is reversing along the
                        \     track while facing forwards

 JSR MoveObjectForward  \ Move the current player forwards along the track

 RTS                    \ Return from the subroutine

.play1

 JSR MoveObjectBack     \ Move current player backwards along the track

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetTrackData
\       Type: Subroutine
\   Category: Track
\    Summary: Fetch a three-axis coordinate from the track data
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The index of the coordinate in the track data blocks
\
\ Returns:
\
\   (SS T)              The Y-th entry from xTrackVectorI as a 16-bit signed
\                       integer
\
\   (TT U)              The Y-th entry from yTrackVectorI as a 16-bit signed
\                       integer
\
\   (UU V)              The Y-th entry from zTrackVectorI as a 16-bit signed
\                       integer
\
\ ******************************************************************************

.GetTrackData

 LDA #0                 \ Zero the high bytes of (SS T), (TT U) and (UU V)
 STA SS
 STA TT
 STA UU

 LDA xTrackVectorI,Y    \ Set T = the Y-th entry from xTrackVectorI
 STA T

 BPL coor1              \ If the byte we just fetched is negative, decrement
 DEC SS                 \ the high byte in SS to &FF, so (SS T) has the correct
                        \ sign

.coor1

 LDA yTrackVectorI,Y    \ Set U = the Y-th entry from yTrackVectorI
 STA U

 BPL coor2              \ If the byte we just fetched is negative, decrement
 DEC TT                 \ the high byte in TT to &FF, so (TT U) has the correct
                        \ sign

.coor2

 LDA zTrackVectorI,Y    \ Set V = the Y-th entry from zTrackVectorI
 STA V

 BPL coor3              \ If the byte we just fetched is negative, decrement
 DEC UU                 \ the high byte in UU to &FF, so (UU V) has the correct
                        \ sign

.coor3

 LDA directionFacing    \ If our car is facing fowards, jump to coor5 to return
 BEQ coor5              \ from the subroutine

                        \ We are facing backwards, so we need to negate the
                        \ coordinate we just fetched

 LDX #2                 \ We are about to negate the following 16-bit variables:
                        \
                        \   (SS T)
                        \   (TT U)
                        \   (UU V)
                        \
                        \ so set a counter in X to use as an index that loops
                        \ through 2, 1 and 0, as:
                        \
                        \   (TT U) = (SS+1 U+1)
                        \   (UU V) = (SS+2 U+2)
                        \
                        \ The following comments are for (SS T), but the same
                        \ process applies for (TT U) and (UU V)

.coor4

 LDA #0                 \ Set (SS T) = 0 - (SS T)
 SEC                    \
 SBC T,X                \ starting with the low bytes
 STA T,X

 LDA #0                 \ And then the high bytes
 SBC SS,X
 STA SS,X

 DEX                    \ Decrement the loop counter to move on to the next
                        \ variable

 BPL coor4              \ Loop back until we have negated all three 16-bit
                        \ variables

.coor5

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MoveObjectForward
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Move a specified object forwards along the track
\
\ ------------------------------------------------------------------------------
\
\ Moves object X forwards, updating objTrackSection, objSectionCount and
\ objProgress accordingly, as well as the lap number and lap time (but only if
\ this is a driver and bit 7 of updateLapTimes is clear).
\
\ Arguments:
\
\   X                   Driver number (0-23)
\
\   updateLapTimes      If bit 7 is set, the call to UpdateLaps has no effect,
\                       so we do not update the lap number or lap time
\
\ Returns:
\
\   C flag              Whether the driver has moved into a new section:
\
\                         * Clear if the driver is still within the same track
\                           section as before
\
\                         * Set if the driver has now moved into the next track
\                           section
\
\ ******************************************************************************

.MoveObjectForward

 LDY objTrackSection,X  \ Set Y to the track section number * 8 for object X

 LDA objSectionCount,X  \ Set A = objSectionCount + 1
 CLC                    \
 ADC #1                 \ This increments the track section counter, which keeps
                        \ track of the object's progress through the current
                        \ track section, so it moves forwards

 CMP trackSectionSize,Y \ If A < Y-th trackSectionSize, then the object is still
 PHP                    \ within the current track section, so clear the C flag
                        \ and store it on the stack, otherwise the object has
                        \ now reached the end of the current section, so set the
                        \ C flag and store it on the stack

 BCC fore2              \ If A < Y-th trackSectionSize, then the object is still
                        \ within the current track section, so jump to fore2 to
                        \ update the track section counter with the new value

 TYA                    \ Set A = Y + 8
 CLC                    \
 ADC #8                 \ So A contains the track section number * 8 of the next
                        \ track section

 CMP trackSectionCount  \ If A < trackSectionCount then this isn't the last
 BCC fore1              \ section before we wrap round to zero again, so jump to
                        \ fore1 to skip the following instruction

 LDA #0                 \ Set A = 0, so the track section number wraps round to
                        \ zero when we reach the last section

.fore1

 STA objTrackSection,X  \ Update the object's track section number to the new
                        \ one that they just moved into

 LDA #0                 \ The object just entered a new track section, so we
                        \ need to zero the section counter, which keeps track of
                        \ how far through the current section the object is, so
                        \ set A to 0 to set as its new value below

.fore2

 STA objSectionCount,X  \ Set the track section counter to the new value

                        \ We now need to increment the object's progress in
                        \ (objProgressHi objProgressLo)

 INC objProgressLo,X    \ Increment (objProgressHi objProgressLo) for object X,
                        \ starting with the low byte

 BNE fore3              \ And then the high byte, if the low byte overflows
 INC objProgressHi,X

.fore3

 LDA objProgressLo,X    \ If objProgress <> trackLength, then the object has not
 CMP trackLengthLo      \ yet reached the end of the track, so jump to fore4 to
 BNE fore4              \ return from the subroutine as we are done
 LDA objProgressHi,X
 CMP trackLengthHi
 BNE fore4

 LDA #0                 \ The object has just reached the end of the track, so
 STA objProgressLo,X    \ set (objProgressHi objProgressLo) = 0 to wrap round to
 STA objProgressHi,X    \ the start again

 JSR UpdateLaps         \ Increment the lap number and lap times for object X,
                        \ for when this object is a car

.fore4

 PLP                    \ Retrieve the C flag from the stack so we can return it
                        \ from the subroutine, so it is clear if the driver is
                        \ still within the same track section, set otherwise

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MoveObjectBack
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Move a specified object backwards along the track
\
\ ------------------------------------------------------------------------------
\
\ Moves object X backwards, updating objTrackSection, objSectionCount,
\ objProgress and the current lap number accordingly.
\
\ Arguments:
\
\   X                   Object number (0-23)
\
\ Returns:
\
\   C flag              Whether the object has moved into a new section:
\
\                         * Clear if the object is still within the same track
\                           section as before
\
\                         * Set if the object has now moved back into the
\                           previous track section
\
\ ******************************************************************************

.MoveObjectBack

 LDY objTrackSection,X  \ Set Y to the track section number * 8 for object X

 LDA objSectionCount,X  \ Set A = objSectionCount, which keeps track of the
                        \ object's progress through the current track section

 CLC                    \ If A is non-zero then the object can move backwards by
 BNE back2              \ one step while staying in the same track section, so
                        \ clear the C flag and jump to back2 to store this
                        \ result on the stack

                        \ Otherwise moving backwards will move the object into
                        \ the previous track section

 TYA                    \ Store the current track section number * 8 in A

 BNE back1              \ If the track section number is non-zero, then skip the
                        \ following instruction

                        \ If we get here then the object is in the first track
                        \ section and is moving backwards into the previous
                        \ track section, so we have to wrap around to the end
                        \ of the track to move into the very last track section

 LDA trackSectionCount  \ Set A = trackSectionCount
                        \
                        \ So A contains the number * 8 of the last track section
                        \ plus 1 (as the track sections count from zero)

.back1

                        \ By this point, A contains the number * 8 of the
                        \ current track section, updated to cater for wrapping
                        \ round at the end

 SEC                    \ Set A = A - 8
 SBC #8                 \
                        \ So A is now the number * 8 of the previous track
                        \ section, which is where the driver is moving to

 STA objTrackSection,X  \ Update the object's track section number to the new
                        \ one that they just moved into

 TAY                    \ Set A to the size of the new track section, so A
 LDA trackSectionSize,Y \ contains the track section counter for the end of the
                        \ new track section (so the object moves to the end of
                        \ the new track section)

 SEC                    \ Set the C flag to indicate that the object has moved
                        \ into a different track section

.back2

 PHP                    \ Store the C flag on the stack, which will be clear if
                        \ the object is still within the same track section, set
                        \ otherwise

 SEC                    \ A contains the object's progress through the current
 SBC #1                 \ track section, so subtract 1 to move the object
                        \ backwards

 STA objSectionCount,X  \ Set the track section counter to the new value

.back3

                        \ We now need to decrement the object's progress in
                        \ (objProgressHi objProgressLo)

 LDA objProgressLo,X    \ If the low byte of objProgress for object X is
 BNE back4              \ non-zero, then jump to back4 to decrement the low
                        \ byte, and we are done

 DEC objProgressHi,X    \ Otherwise decrement the high byte

 BPL back4              \ If the high byte is positive, jump to back4 to
                        \ decrement the low byte to &FF, and we are done

                        \ If we get here then we just decremented the 16-bit
                        \ value in (objProgressHi objProgressLo) into negative
                        \ territory, so the object just moved backwards across
                        \ the starting line, into the previous lap

 LDA trackLengthLo      \ Set objProgress for driver X = trackLength
 STA objProgressLo,X    \
 LDA trackLengthHi      \ So objProgress wraps around to the progress value for
 STA objProgressHi,X    \ the end of the track, as trackLength contains the
                        \ length of the full track (in terms of progress)

 CPX currentPlayer      \ If object X is not the current player, jump to back3
 BNE back3              \ to decrement the newly wrapped progress figure

 LDA driverLapNumber,X  \ If the current lap number for the current player is
 BEQ back3              \ zero (i.e. this is the first lap) then jump to back3
                        \ to decrement the newly wrapped progress figure

 DEC driverLapNumber,X  \ Otherwise this is not the current player's first lap,
                        \ and they just moved backwards, across the starting
                        \ line and into the previous lap, so decrement the
                        \ current lap number for the current player

 JMP back3              \ Jump to back3 to decrement the newly wrapped progress
                        \ figure

.back4

 DEC objProgressLo,X    \ Decrement the low byte of the object's progress to
                        \ move them backwards

 PLP                    \ Retrieve the C flag from the stack so we can return it
                        \ from the subroutine, so it is clear if the object is
                        \ still within the same track section, set otherwise

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetBestRacingLine
\       Type: Subroutine
\   Category: Track
\    Summary: Calculate the best racing line to take for the current track
\             segment
\
\ ------------------------------------------------------------------------------
\
\ This routine populates segmentSteering for a track segment, depending on a
\ large number of factors.
\
\ ******************************************************************************

.GetBestRacingLine

 LDY objTrackSection+23 \ Set Y to the number * 8 of the track section for
                        \ driver 23

 TYA                    \ Set X = Y / 8
 LSR A                  \
 LSR A                  \ So X contains the number of the track section for
 LSR A                  \ driver 23
 TAX

 LDA turnCounter        \ If turnCounter is non-zero, then a turn is already in
 BNE rlin5              \ progress, so jump to rlin5

                        \ We get here if turnCounter is zero

 LDA thisSectionFlags   \ If bit 0 of thisSectionFlags is set then this is a
 LSR A                  \ curved track section, so jump to rlin2
 BCS rlin2

 LDA objSectionCount+23 \ If driver 23's progress through the track section is
 CMP trackSectionTurn,Y \ >= the trackSectionTurn for the section, jump to rlin3
 BCS rlin3              \ to move on to the next track section

                        \ If we get here, then:
                        \
                        \   * turnCounter is zero
                        \
                        \   * Bit 0 of thisSectionFlags is clear, so this is a
                        \     straight track section
                        \
                        \   * Driver 23's progress through the track section is
                        \     less than the trackSectionTurn value for the
                        \     section
                        \
                        \ So we are not already turning from a previous call, we
                        \ are on a straight, and we haven't yet reached the
                        \ point at the end of the straight where we should be
                        \ turning
                        \
                        \ So now we keep on driving straight

.rlin1

 LDA bestRacingLine,X   \ Set A to the best racing line for section X, with
 ORA #%01000000         \ bit 6 set, so we do not apply any steering in MoveCars
                        \ but instead just apply acceleration or braking

 BNE rlin7              \ Jump to rlin7 to store A in segmentSteering for this
                        \ section and return from the subroutine (this BNE is
                        \ effectively a JMP as A is never zero)

.rlin2

                        \ If we get here then this is a curved track section and
                        \ turnCounter is zero

 LDA previousSpeed7     \ If bit 7 of previousSpeed7 is set, jump to rlin4
 BMI rlin4

                        \ If we get here then this is a curved track section and
                        \ turnCounter is zero, and bit 7 of previousSpeed7 is
                        \ clear

.rlin3

                        \ If we jump here, then driver 23 is past the
                        \ trackSectionTurn point in this section, so we start
                        \ looking at the next section for the best racing line

 TYA                    \ Set Y = Y + 8
 CLC                    \
 ADC #8                 \ So Y contains the number * 8 of the next track section
 TAY

 INX                    \ Increment X, so X contains the number of the next
                        \ track section

.rlin4

 LDA trackSectionFlag,Y \ If bit 0 of the track section's flag byte is clear,
 AND #1                 \ then this is a straight section, so jump to rlin1 to
 BEQ rlin1              \ disable steering in MoveCars and keep on driving
                        \ straight

 LDA trackSectionTurn,Y \ Set turnCounter = track section's trackSectionTurn
 STA turnCounter

 BEQ rlin1              \ If the track section's trackSectionTurn is zero, jump
                        \ to rlin1 to disable steering in MoveCars and keep on
                        \ driving straight

 LDA trackDriverSpeed,Y \ Set previousSpeed7 = track section's driver speed,
 STA previousSpeed7     \ which we only use to check bit 7

 AND #%01111111         \ Set previousSpeed = bits 0-6 of the track section's
 STA previousSpeed      \ driver speed

 LDA bestRacingLine,X   \ Set A to the best racing line for the track section

 STA previousRacingLine \ Set previousRacingLine to the best racing line for the
                        \ track section

 JMP rlin7              \ Jump to rlin7 to store A in segmentSteering for this
                        \ section and return from the subroutine (this BNE is
                        \ effectively a JMP as A is never zero)

.rlin5

                        \ If we get here then turnCounter is non-zero, so a
                        \ turn is already in progress

 DEC turnCounter        \ Decrement the turn counter in turnCounter

 LDA turnCounter        \ Set T = turnCounter / 8
 LSR A
 LSR A
 LSR A
 STA T

 LDA turnCounter        \ Set A = turnCounter - previousSpeed
 SEC
 SBC previousSpeed

 BCS rlin6              \ If the subtraction didn't underflow, i.e.
                        \
                        \   turnCounter >= previousSpeed
                        \
                        \ then jump to rlin6 to set segmentSteering to
                        \ previousRacingLine and return from the subroutine

                        \ If we get here then turnCounter < previousSpeed and
                        \ A is negative

 ADC T                  \ Set A = A + T
                        \       = turnCounter - previousSpeed + turnCounter / 8

 LDA #0                 \ Set A = 0

 BCS rlin7              \ If the addition overflowed, then because A was
                        \ negative, we must have the following:
                        \
                        \   A = A + T >= 0
                        \
                        \ So jump to rlin7 to store 0 in segmentSteering for
                        \ this section and return from the subroutine
                        \
                        \ Otherwise store previousRacingLine in segmentSteering
                        \ for this section and return from the subroutine

.rlin6

 LDA previousRacingLine \ Set A = previousRacingLine

 BCS rlin7              \ If the C flag is clear, flip bit 7 of A
 EOR #%10000000

.rlin7

 LDY segmentIndex       \ Set segmentSteering for this track segment to A
 STA segmentSteering,Y

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ProcessDrivingKeys (Part 1 of 6)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process joystick steering
\
\ ------------------------------------------------------------------------------
\
\ This routine scans for key presses, or joystick (when configured), and updates
\ the following variables accordingly:
\
\   * Steering: (steeringHi steeringLo)
\
\   * Brake/throttle: throttleBrakeState, throttleBrake
\
\   * Gear changes: gearChangeKey, gearChange, gearNumber
\
\ ******************************************************************************

.ProcessDrivingKeys

 LDA #0                 \ Set V = 0, which we will use to indicate whether any
 STA V                  \ steering is being applied (0 indicates that none is
                        \ being applied, which we may change later)

 STA T                  \ Set T = 0, which we will use to record whether SPACE
                        \ is being pressed, which makes the steering wheel turn
                        \ more quickly

 STA gearChangeKey      \ Set gearChangeKey = 0, which we will use to indicate
                        \ whether any gear change are being applied (0 indicates
                        \ that no gear changes are being applied, which we may
                        \ change later)

IF _ACORNSOFT

 BIT configJoystick     \ If bit 7 of configJoystick is clear then the joystick
 BPL keys2              \ is not configured, so jump to keys2 to check for key
                        \ presses for the steering

 LDX #&9D               \ Scan the keyboard to see if SPACE is being pressed, as
 JSR ScanKeyboard       \ this will affect the speed of any steering changes

 PHP                    \ Store the result of the scan on the stack

ELIF _SUPERIOR

 LDX #&9D               \ Scan the keyboard to see if SPACE is being pressed, as
 JSR ScanKeyboard       \ this will affect the speed of any steering changes

 PHP                    \ Store the result of the scan on the stack

 BIT configJoystick     \ If bit 7 of configJoystick is clear then the joystick
 BPL keys2              \ is not configured, so jump to keys2 to check for key
                        \ presses for the steering

ENDIF

 LDX #1                 \ Read the joystick x-axis into A and X (A is set to the
 JSR GetADCChannel      \ high byte of the channel, X is set to the sign of A
                        \ where 1 = negative/left, 0 = positive/right)

 STA U                  \ Store the x-axis high byte in U

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = A * A
                        \           = A^2
                        \           = x-axis^2

 PLP                    \ Retrieve the result of the keyboard scan above, when
                        \ we scanned for SPACE

 BEQ keys1              \ If SPACE is being pressed, jump to keys1 so the value
                        \ of (A T) will be four times higher

 LSR A                  \ Set (A T) = (A T) / 4
 ROR T                  \           = x-axis^2 / 4
 LSR A
 ROR T

.keys1

IF _ACORNSOFT

 PHA                    \ Store A on the stack so we can retrieve it later

ELIF _SUPERIOR

 STA U                  \ Set (U T) = (A T)

ENDIF

 LDA T                  \ Clear bit 0 of T
 AND #%11111110
 STA T

 TXA                    \ Set bit 0 of T to the sign bit in X (1 = left,
 ORA T                  \ 0 = right), so this sets (A T) to the correct sign
 STA T                  \ for a steering measurement

IF _ACORNSOFT

 PLA                    \ Retrieve the value of A that we stored on the stack

 JMP keys11             \ Jump to the end of part 2 to update the steering value
                        \ in (steeringHi steeringLo) to (A T)

ELIF _SUPERIOR

 LDA U                  \ Set (A T) = (U T)
                        \
                        \ so (A T) contains the joystick x-axis high byte,
                        \ squared, divided by 4 if SPACE is not being pressed,
                        \ and converted into a sign-magnitude number with the
                        \ sign in bit 0 (1 = left, 0 = right)

 JMP AssistSteering     \ Jump to AssistSteering to apply Computer Assisted
                        \ Steering (CAS), which in turn jumps back to keys7 or
                        \ keys11 in part 2

 NOP                    \ These instructions are unused, and are included to
 NOP                    \ pad out the code from when the CAS code was inserted
                        \ into the original version

ENDIF

\ ******************************************************************************
\
\       Name: ProcessDrivingKeys (Part 2 of 6)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process keyboard steering
\
\ ******************************************************************************

.keys2

 LDX #&A9               \ Scan the keyboard to see if "L" is being pressed
 JSR ScanKeyboard

 BNE keys3              \ If "L" is not being pressed, jump to keys3

 LDA #2                 \ Set V = 2
 STA V

.keys3

 LDX #&A8               \ Scan the keyboard to see if ";" is being pressed
 JSR ScanKeyboard

 BNE keys4              \ If ";" is not being pressed, jump to keys4

 INC V                  \ Set V = 1

.keys4

                        \ By this point, we have:
                        \
                        \   * V = 1 if ";" is being pressed (steer right)
                        \
                        \   * V = 2 if "L" is being pressed (steer left)
                        \
                        \   * V = 0 if neither is being pressed
                        \
                        \ We now calculate the amount of steering change into
                        \ (A T), so we can apply it to (steeringHi steeringLo),
                        \ which is a sign-magnitude number with the sign bit in
                        \ bit 0
                        \
                        \ In the following, we swap the steering change between
                        \ (A T) and (U T) quite a bit, and in the Superior
                        \ Software variant of the game, we also apply Computer
                        \ Assisted Steering (CAS)

 LDA #3                 \ Set U = 3
 STA U                  \
                        \ So (U T) = (3 0) = 768, which is the value we use for
                        \ steering when the SPACE key is held down

IF _ACORNSOFT

 LDX #&9D               \ Scan the keyboard to see if SPACE is being pressed
 JSR ScanKeyboard

ELIF _SUPERIOR

 PLP                    \ Retrieve the result of the keyboard scan above, when
                        \ we scanned for SPACE

ENDIF

 BEQ keys6              \ If SPACE is being pressed, jump to keys6 with
                        \ (U T) = 768

                        \ SPACE is not being pressed, so we need to calculate
                        \ the correct value of (U T) depending on the steering
                        \ wheel position

 LDA #0                 \ Set A = 0

 LDX #2                 \ If steeringHi > 2, jump to keys5 to skip the following
 CPX steeringHi         \ instruction
 BCC keys5

 LDA #1                 \ Set A = 1

.keys5

 STA U                  \ Set U = A, which will be 1 if steeringHi > 2, or
                        \ 0 otherwise

 LDA #128               \ Set T = 128
 STA T

.keys6

                        \ By this point, (U T) is:
                        \
                        \   * (3 0) = 768 if the SPACE key is being held down
                        \
                        \   * (1 128) = 384 if steeringHi > 2
                        \
                        \   * (0 128) = 128 if steeringHi <= 2

 LDA V                  \ If V = 0 then no steering is being applied, so jump to
 BEQ keys7              \ keys7

 CMP #3                 \ If V = 3, jump to keys13 to move on to the throttle
 BEQ keys13             \ and brake keys without applying any steering

                        \ If we get here then V = 1 or 2, so steering is being
                        \ applied, so we set the sign of (U T) to match the
                        \ position of the wheel, before jumping down to keys8
                        \ or keys9

 EOR steeringLo         \ If bit 0 of steeringLo is clear, jump to keys9
 AND #1
 BEQ keys9

 JSR Negate16Bit+2      \ Otherwise (steeringHi steeringLo) is negative, so
                        \ set (A T) = -(U T)

 JMP keys8              \ Jump to keys8 to store the negated value in (U T)

.keys7

                        \ If we get here then no steering is being applied

 LDA var09Lo            \ Set T = var09Lo AND %11110000
 AND #%11110000
 STA T

 LDA var09Hi            \ Set (A T) = (var09Hi var09Lo) AND %11110000
                        \           = var09 AND %11110000

 JSR Absolute16Bit      \ Set (A T) = |A T|

 LSR A                  \ Set (A T) = (A T) >> 2
 ROR T                  \           = |A T| / 4
 LSR A                  \           = (|var09| AND %11110000) / 4
 ROR T

IF _ACORNSOFT

 CMP #12                \ If A < 12, skip the following instruction
 BCC keys8

 LDA #12                \ Set A = 12, so A has a maximum value of 12, and |A T|
                        \ is set to a maximum value of 12 * 256

ELIF _SUPERIOR

 CMP steeringHi         \ If A < steeringHi, clear the C flag, so the following
                        \ call to SetSteeringLimit does nothing

 JSR SetSteeringLimit   \ If A >= steeringHi, set:
                        \
                        \   (A T) = |steeringHi steeringLo|
                        \
                        \ so this is the maximum value of |A T|

ENDIF

.keys8

 STA U                  \ Set (U T) = (A T)

.keys9

IF _ACORNSOFT

 LDA steeringLo         \ Set A = steeringLo

ELIF _SUPERIOR

 JMP AssistSteeringKeys \ Jump to AssistSteeringKeys, which in turn jumps back
                        \ to keys10, so this is effectively a JSR call
                        \
                        \ The routine returns with A = steeringLo

ENDIF

.keys10

 SEC                    \ Set (A T) = (steeringHi steeringLo) - (U T)
 SBC T                  \
 STA T                  \ starting with the high bytes

 LDA steeringHi         \ And then the low bytes
 SBC U

 CMP #200               \ If the high byte in A < 200, skip the following
 BCC keys11             \ instructions

                        \ Otherwise the high byte in A >= 200, so we negate
                        \ (A T)

 JSR Negate16Bit        \ Set (A T) = -(A T)

 STA U                  \ Set (U T) = (A T)

 LDA T                  \ Flip the sign bit in bit 0 of T
 EOR #1
 STA T

 LDA U                  \ Set (A T) = (U T)

.keys11

 CMP #145               \ If the high byte in A < 145, skip the following
 BCC keys12             \ instruction

 LDA #145               \ Set A = 145, so A has a maximum value of 145

.keys12

 STA steeringHi         \ Set (steeringHi steeringLo) = (A T)
 LDA T
 STA steeringLo

\ ******************************************************************************
\
\       Name: ProcessDrivingKeys (Part 3 of 6)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process joystick brake and throttle
\
\ ******************************************************************************

.keys13

 LDA leaveTrackTimer    \ If leaveTrackTimer is non-zero then the leave track
 BNE keys19             \ timer is counting down, so jump to keys19 to skip the
                        \ whole brake/throttle section

 BIT configJoystick     \ If bit 7 of configJoystick is clear then the joystick
 BPL keys15             \ is not configured, so jump to keys15 to check for key
                        \ presses for the brake/throttle

 LDX #2                 \ Read the joystick y-axis into A and X, clearing the
 JSR GetADCChannel      \ C flag if A < 10, setting A to the high byte, and
                        \ setting X to 1 if the stick is up, or 0 if the stick
                        \ is down

 BCC keys19             \ If A < 10 then the joystick is pretty close to the
                        \ centre, so jump to keys19 so we don't register any
                        \ throttle or brake activity

 STA T                  \ Set T = A / 2
 LSR T

 ASL A                  \ Set A = A * 2

 ADC T                  \ Set A = A + T
                        \       = A * 2 + A / 2
                        \       = 2.5 * A

 BCS keys14             \ If the addition overflowed, the the joystick has moved
                        \ a long way from the centre, so jump to keys14 to apply
                        \ the brakes or throttle at full power

 CMP #250               \ If A < 250, jump to keys20 to store A in throttleBrake
 BCC keys20             \ and X in throttleBrakeState, so we store the amount of
                        \ brakes or throttle to apply

.keys14

 CPX #0                 \ If X = 0 then the joystick y-axis is positive (down),
 BEQ keys18             \ so jump to keys18 to apply the brakes

 BNE keys16             \ Otherwise the joystick y-axis is negative (up), so
                        \ jump to keys16 to increase the throttle (this BNE is
                        \ effectively a JMP as we already know X is non-zero)

\ ******************************************************************************
\
\       Name: ProcessDrivingKeys (Part 4 of 6)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process keyboard brake and throttle
\
\ ******************************************************************************

.keys15

 LDX #&AE               \ Scan the keyboard to see if "S" is being pressed (the
 JSR ScanKeyboard       \ throttle key)

 BNE keys17             \ If "S" is not being pressed, jump to keys17 to check
                        \ the next key

 LDX #1                 \ Set X = 1 to store in throttleBrakeState below

.keys16

 LDA #255               \ Set A = 255 to store in throttleBrake below

 BNE keys20             \ Jump to keys20 (this BNE is effectively a JMP as A is
                        \ never zero)

.keys17

 LDX #&BE               \ Scan the keyboard to see if "A" is being pressed (the
 JSR ScanKeyboard       \ brake key)

 BNE keys19             \ If "A" is not being pressed, jump to keys19

 LDX #0                 \ Set X = 0 to store in throttleBrakeState below

.keys18

 LDA #250               \ Set A = 250 to store in throttleBrake below

 BNE keys20             \ Jump to keys20 (this BNE is effectively a JMP as A is
                        \ never zero)

.keys19

                        \ If we get here then neither of the throttle keys are
                        \ being pressed, or the joystick isn't being moved
                        \ enough to register a change

 LDX #%10000000         \ Set bit 7 of X to store in throttleBrakeState below

 LDA revCount           \ Set A = 5 + revCount / 4
 LSR A                  \
 LSR A                  \ to store in throttleBrake below
 CLC
 ADC #5

.keys20

 STX throttleBrakeState \ Store X in throttleBrakeState

 STA throttleBrake      \ Store A in throttleBrake

                        \ By the time we get here, one of the following is true:
                        \
                        \   * There is no brake or throttle action from keyboard
                        \     or joystick:
                        \
                        \       throttleBrakeState = bit 7 set
                        \       throttleBrake = 5 + revCount / 4
                        \
                        \   * Joystick is enabled and 2.5 * y-axis < 250 (so
                        \     joystick is in the zone around the centre)
                        \
                        \       throttleBrakeState = 0 for joystick down, brake
                        \                            1 for joystick up, throttle
                        \       throttleBrake = 2.5 * y-axis
                        \
                        \   * "S" (throttle) is being pressed (or joystick has
                        \     2.5 * y-axis >= 250):
                        \
                        \       throttleBrakeState = 1
                        \       throttleBrake = 255
                        \
                        \   * "A" (brake) is being pressed (or joystick has
                        \     2.5 * y-axis >= 250)
                        \
                        \       throttleBrakeState = 0
                        \       throttleBrake = 250

\ ******************************************************************************
\
\       Name: ProcessDrivingKeys (Part 5 of 6)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process joystick gear change
\
\ ******************************************************************************

 BIT configJoystick     \ If bit 7 of configJoystick is clear then the joystick
 BPL keys21             \ is not configured, so jump to keys21 to skip the
                        \ following joystick-specific gear checks

 LDX #0                 \ Call OSBYTE with A = 128 and X = 0 to fetch the ADC
 LDA #128               \ channel that was last used for ADC conversion,
 JSR OSBYTE             \ returning the channel number in Y, and the status of
                        \ the two fire buttons in X

 TXA                    \ If bit 0 of X is zero, then no fire buttons are being
 AND #1                 \ pressed, so jump to keys22 to check the next key
 BEQ keys22

 LDY throttleBrakeState \ If throttleBrakeState <> 1, then the throttle is not
 DEY                    \ being applied, so jump to keys23
 BNE keys23

                        \ If we get here then the fire button is being pressed
                        \ and the throttle is being applied, which is the
                        \ joystick method for changing gear, so now we jump to
                        \ the correct part below to change up or down a gear

 LDA throttleBrake      \ If the throttle amount is >= 200, jump to keys24 to
 CMP #200               \ change up a gear
 BCS keys24

 BCC keys23             \ Otherwise jump to keys23 to change down a gear

\ ******************************************************************************
\
\       Name: ProcessDrivingKeys (Part 6 of 6)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process keyboard gear change
\
\ ******************************************************************************

.keys21

 LDX #&9F               \ Scan the keyboard to see if TAB is being pressed
 JSR ScanKeyboard

 BEQ keys23             \ If TAB is being pressed, jump to keys23

 LDX #&EF               \ Scan the keyboard to see if "Q" is being pressed
 JSR ScanKeyboard

 BEQ keys24             \ If "Q" is being pressed, jump to keys24

.keys22

                        \ If we get here then the gear is not being changed

 LDA #0                 \ Set gearChange = 0 to indicate that we are not in the
 STA gearChange         \ process of changing gear

 BEQ keys28             \ Jump to keys28 to return from the subroutine (this BEQ
                        \ is effectively a JMP as A is always zero)

.keys23

                        \ If we get here then either TAB is being pressed, or
                        \ the joystick fire button is being pressed while the
                        \ stick is in the "change down" part of the joystick
                        \ range, so we need to change down a gear

 LDA #&FF               \ Set A = -1 so we change down a gear

 BNE keys25             \ Jump to keys25 to change the gear

.keys24

                        \ If we get here then either "Q" is being pressed, or
                        \ the joystick fire button is being pressed while the
                        \ stick is in the "change up" part of the joystick
                        \ range, so we need to change up a gear

 LDA #1                 \ Set A = 1 so we change up a gear

.keys25

 DEC gearChangeKey      \ Set bit 7 of gearChangeKey (as we set gearChangeKey to
                        \ zero above)

 LDX gearChange         \ If gearChange is non-zero then we are already changing
 BNE keys28             \ gear, so jump to keys28 to return from the subroutine

 STA gearChange         \ Set gearChange to -1 or 1

 CLC                    \ Add A to the current gearNumber to get the number of
 ADC gearNumber         \ the new gear, after the change

 CMP #&FF               \ If the gear change will result in a gear of -1, jump
 BEQ keys26             \ to keys26 to set the gear number to 0 (the lowest gear
                        \ number)

 CMP #7                 \ If the new gear is not 7, jump to keys27 to change to
 BNE keys27             \ this gear

 LDA #6                 \ Otherwise set A to 6, which is the highest gear number
 BNE keys27             \ allowed, and jump to keys27 to set this as the new
                        \ gear number (this BNE is effectively a JMP as A is
                        \ never zero)

.keys26

 LDA #0                 \ If we get here then we just tried to change down too
                        \ far, so set the number of the new gear to zero

.keys27

 STA gearNumber         \ Store the new gear number in gearNumber

 JSR PrintGearNumber    \ Print the new gear number on the gear stick

.keys28

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MainDrivingLoop (Part 1 of 5)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Main driving loop: Switch to the track and start the main loop
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   configStop          Contains details of why we are exiting the driving loop:
\
\                         * Bit 5 set = retire from race/lap
\                           (SHIFT-f7 pressed)
\
\                         * Bit 7 and bit 6 set = pit stop
\                           (SHIFT-f0 pressed)
\
\                         * Bit 7 set and bit 6 clear = restart game
\                           (SHIFT and right arrow pressed)
\
\ ******************************************************************************

.MainDrivingLoop

 JSR SetCustomScreen    \ Switch to the custom screen mode, which also sets
                        \ screenSection to -2, so the interrupt handler doesn't
                        \ do any palette switching just yet, but leaves the
                        \ palette mapped to black, so the screen is blank

 LDA #0                 \ Set printMode = 0 so text printing pokes directly into
 STA printMode          \ screen memory

 JSR CopyDashData       \ Copy the dash data from the main game code to screen
                        \ memory

 JSR DrawTrackView      \ Copy the data from the dash data blocks to the screen
                        \ to draw the track view
                        \
                        \ As the screen is currently mapped to black, this
                        \ doesn't show anything, but it does zero all the dash
                        \ data blocks, so they are ready to be filled with the
                        \ track view

 BIT configStop         \ If bit 6 of configStop is set then we are returning to
 BVS main4              \ the track after visiting the pits, so jump to main4
                        \ to reset the pit stop flag and enter the driving loop

.main1

                        \ We jump back here when restarting practice laps

 LDX #0                 \ Zero the clock timer, as there is no time limit on the
 JSR ZeroTimer          \ practice session

.main2

                        \ We jump back here when restarting qualifying laps

 JSR ResetVariables     \ Reset a number of variables for driving, and print the
                        \ top two text lines

.main3

                        \ We jump back here when restarting a Novice race

 JSR BuildPlayerCar     \ Build the objects for the player's car

.main4

 LDA #0                 \ Set configStop = 0 so we clear out any existing
 STA configStop         \ stop-related key presses

 JSR ScaleWingSettings  \ Scale the wing settings and calculate the wing balance
                        \ for use in the driving model

\ ******************************************************************************
\
\       Name: MainDrivingLoop (Part 2 of 5)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Main driving loop: The body of the main loop
\
\ ******************************************************************************

.main5

                        \ The main driving loop starts here, and we loop back to
                        \ here from part 5

 JSR ProcessTime        \ Increment the timers and the main loop counter, and
                        \ set the speed for the next non-player driver

 JSR ShowStartLights    \ If this is a race, show the starting lights on the
                        \ right of the screen

 JSR ProcessDrivingKeys \ Check for and process the main driving keys

 JSR sub_C46A1

 JSR GetTrackAndMarkers \ Calculate the coordinates for the track sides and
                        \ corner markers

 JSR sub_C4626

 JSR MovePlayerCar      \ Move the player's car in the correct direction

 JSR UpdateLapTimers    \ Update the lap timers and display timer-related
                        \ messages at the top of the screen

 JSR MakeDrivingSounds  \ Make the relevant sounds for the engine and tyres

 JSR ResetTrackLines    \ Reset the blocks at leftVergeStart, leftTrackStart,
                        \ rightVergeStart, rightGrassStart and backgroundColour

 JSR DrawTrack          \ Draw the track into the screen buffer

 JSR MakeDrivingSounds  \ Make the relevant sounds for the engine and tyres

 JSR DrawBackground     \ Set the background colour for all the track lines in
                        \ the track view

 JSR BuildRoadSign      \ Build the road sign (if one is visible) in driver 23

 LDX #23                \ Draw any visible road signs
 JSR DrawCarOrSign

 JSR DrawCornerMarkers  \ Draw any visible corner markers

 JSR MoveAndDrawCars    \ Move the cars around the track and draw any that are
                        \ visible, up to a maximum of five

 JSR CopyTyreDashEdges  \ Copy the pixels from the edges of the left tyre and
                        \ right dashboard so they can be used when drawing the
                        \ track view around the tyres and dashboard, and fill
                        \ the blocks to the right of the edges with the
                        \ appropriate content

 JSR UpdateMirrors      \ Update the view in the wing mirrors

 JSR MakeDrivingSounds  \ Make the relevant sounds for the engine and tyres

 JSR MoveHorizon        \ Move the position of the horizon palette switch up or
                        \ down, depending on the current track height

 JSR ProcessContact     \ Process any car-on-car contact, if there has been any

 JSR CheckForCrash      \ Check to see if we have crashed into the fence, and if
                        \ so, display the fence, make the crash sound and set
                        \ crashedIntoFence = &FF

 JSR DrawTrackView      \ Copy the data from the dash data blocks to the screen
                        \ to draw the track view, fitting it around the tyres
                        \ and dashboard

\ ******************************************************************************
\
\       Name: MainDrivingLoop (Part 3 of 5)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Main driving loop: Process rejoining the race or lap after a crash
\
\ ******************************************************************************

 LDA screenSection      \ If screenSection is positive, jump to main6 to skip
 BPL main6              \ the following instruction

 INC screenSection      \ If screenSection is negative, then we increment it
                        \
                        \ This kickstarts the custom screen interrupt handler
                        \ on the first time round the main driving loop, as the
                        \ call to SetCustomScreen at the start of the routine
                        \ sets screenSection to -2, and this increment bumps it
                        \ up to -1, which makes the screen handler start
                        \ applying the custom screen effect
                        \
                        \ In other words, this displays the driving screen for
                        \ the first time, after waiting for all the drawing
                        \ routines in part 2 to finish, so we don't get to see
                        \ the screen being drawn

.main6

 LDA crashedIntoFence   \ If crashedIntoFence = 0 then we have not crashed into
 BEQ main10             \ the fence, so jump to main10 to continue with the main
                        \ driving loop in part 5

 INC crashedIntoFence   \ Otherwise crashedIntoFence must be &FF, which means we
                        \ have crashed into the fence, so increment it back to
                        \ zero, to clear the "we have crashed" flag

                        \ We now pause for a few seconds, before jumping back to
                        \ the relevant starting point for the loop

 LDA #156               \ Set irqCounter = 156
 STA irqCounter

.main7

 LDA irqCounter         \ Fetch irqCounter, which gets incremented every time
                        \ the IRQ routine reaches section 4 of the custom screen

 BMI main7              \ Loop back to main7 until irqCounter increments round
                        \ to zero (so we wait for it to go from 156 to 0, which
                        \ takes around three seconds at 50 ticks per second)

.main8

 LDA qualifyingTime     \ If bit 7 of qualifyingTime is set then this is a
 BMI main1              \ practice lap (i.e. qualifyingTime = 255), so jump back
                        \ to main1

 LDA raceStarted        \ If bit 7 of raceStarted is clear then this is either
 BPL main2              \ a practice or qualifying lap, but we didn't just jump
                        \ to main1, so this must be qualifying, so jump back to
                        \ main2

 LDA raceClass          \ If raceClass = 0 then this is a Novice race, so jump
 BEQ main3              \ back to main3

                        \ Otherwise this is an Amateur or a Professional race,
                        \ and not a Novice race, practice or a qualifying lap

\ ******************************************************************************
\
\       Name: MainDrivingLoop (Part 4 of 5)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Main driving loop: Leave the track
\
\ ******************************************************************************

.main9

                        \ If we get here then either:
                        \
                        \   * We have quit the race or lap by pressing SHIFT-f4
                        \     (in which case we jumped here from part 5)
                        \
                        \   * This is either an Amateur or a Professional race
                        \     and we crashed (in which case we fell through from
                        \     part 3)
                        \
                        \   * leaveTrackTimer = 1 (in which case we jumped here
                        \     from part 5 after the leave track timer ran down)
                        \
                        \ In all cases, we are done racing and need to leave
                        \ the track

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers

 LDA qualifyingTime     \ If bit 7 of qualifyingTime is set then this is a
 BMI main8              \ practice lap (i.e. qualifyingTime = 255), so jump to
                        \ main1 via main8, so we start a new practice lap

 LDX #48                \ Blank out the first text line at the top of the screen
 JSR PrintSecondLineGap \ and print token 48 on the second line, to give:
                        \
                        \    "                                      "
                        \    "             PLEASE  WAIT             "

 JSR FinishRace         \ Continue running the race until all the non-player
                        \ drivers have finished and we have a result

 LDA configStop         \ If bit 7 of configStop is set then we must be pressing
 BMI main13             \ either SHIFT-f0 for a pit stop or SHIFT and right
                        \ arrow to restart the game, so jump to main13 to leave
                        \ the track

 LDA #%00100000         \ Set bit 5 of configStop to indicate that we have
 STA configStop         \ retired from the race (so we leave the track
                        \ permanently rather than just visiting the pits)

 BNE main13             \ Jump to main13 to leave the track (this BNE is
                        \ effectively a JMP as A is never zero)

\ ******************************************************************************
\
\       Name: MainDrivingLoop (Part 5 of 5)
\       Type: Subroutine
\   Category: Main loop
\    Summary: Main driving loop: Process driving keys, potentially leaving the
\             track, and loop back to part 2
\
\ ******************************************************************************

.main10

IF _ACORNSOFT

 LDY #9                 \ Check for all the shifted keys (i.e. those that need
 JSR ProcessShiftedKeys \ SHIFT holding down to trigger) and process them
                        \ accordingly

ELIF _SUPERIOR

 LDY #11                \ Check for all the shifted keys (i.e. those that need
 JSR ProcessShiftedKeys \ SHIFT holding down to trigger) and process them
                        \ accordingly

ENDIF

 LDA configStop         \ If configStop = 0, then we aren't pressing one of the
 BEQ main11             \ keys that stops the race, so jump to main11 to keep
                        \ iterating round the main driving loop

 BPL main9              \ If bit 7 of configStop is clear then we must be
                        \ pressing SHIFT-f7 to retire from the race, so jump to
                        \ main9 to leave the track

 AND #%01000000         \ If bit 6 of configStop is clear (and we know bit 7 is
 BEQ main13             \ set), then we must be pressing SHIFT and right arrow,
                        \ so jump to main13 to leave the track and restart the
                        \ game

                        \ If we get here then we know both bit 6 and bit 7 must
                        \ be set, so we must be pressing SHIFT-f0 to return to
                        \ the pits

 LDA playerMoving       \ If playerMoving = 0 then the player's car is
 BEQ main13             \ stationary, so jump to main13 to leave the track and
                        \ return to the pits

 LDA #0                 \ We can't enter the pits if the car is moving, so set
 STA configStop         \ configStop = 0 so we clear out the SHIFT-f4 key press

.main11

 LDX leaveTrackTimer    \ Set X to the current value of the leave track timer

 BEQ main12             \ If X = 0 then the leave track timer is not running, so
                        \ jump to main12 to continue with the main driving loop

 DEX                    \ The leave track timer is running, so decrement the
                        \ timer value in X

 BEQ main9              \ If X = 0 then the leave track timer was 1 before the
                        \ decrement and has now run down, so jump to main9 to
                        \ leave the track

 STX leaveTrackTimer    \ Store the decremented leave track timer so that it
                        \ continues counting down towards 1

.main12

 JSR MakeDrivingSounds  \ Make the relevant sounds for the engine and tyres

 JSR UpdateDashboard    \ Update the rev counter on the dashboard

 JMP main5              \ Loop back to main5 to repeat the main driving loop

.main13

                        \ If we get here then we leave the track and switch back
                        \ to mode 7, either to visit the pits or because the
                        \ driving is done

 LDA #%10000000         \ Copy the dash data from screen memory back to the main
 JSR CopyDashData       \ game code

 JSR KillCustomScreen   \ Disable the custom screen mode and switch to mode 7

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: AddTimeToTimer
\       Type: Subroutine
\   Category: Drivers
\    Summary: Add time to the specified timer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The timer to increment:
\
\                         * 0 = the clock timer
\                               (clockMinutes clockSeconds clockTenths)
\
\                         * 1 = the lap timer
\                               (lapMinutes lapSeconds lapTenths)
\
\ Returns:
\
\   C flag              Denotes whether the number of seconds has changed:
\
\                         * Set if the time just ticked on to the next second
\
\                         * Clear if the time is unchanged
\
\ ******************************************************************************

.AddTimeToTimer

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

 LDA #&09               \ Set A = &09, so we add 9/100 of a second below

 LDY timerAdjust        \ If timerAdjust <> trackTimerAdjust (which is 24 for
 CPY trackTimerAdjust   \ the Silverstone track), jump to time1 to skip the
 BNE time1              \ following

                        \ If we get here then timerAdjust = trackTimerAdjust, so
                        \ we need to apply the clock adjustment, as this gets
                        \ applied every trackTimerAdjust iterations around the
                        \ main driving loop
                        \
                        \ The clock adjustment speeds the clock up by advancing
                        \ the clock twice as fast as usual, for this tick only

 LDA #&18               \ Set A = &18, so we add 18/100 of a second below

.time1

 CLC                    \ Add A to the tenths for the timer
 ADC clockTenths,X      \
 STA clockTenths,X      \ starting with the tenths of a second

 PHP                    \ Store the C flag on the stack, so we can return it
                        \ from the subroutine below (the C flag will be set
                        \ if the lap time just ticked on to the next second)

 LDA clockSeconds,X     \ Then we add the seconds into A
 ADC #0

 CMP #&60               \ If A < &60, then the number of seconds is still valid,
 BCC time2              \ so jump to time2 to skip the following instruction

 LDA #0                 \ Otherwise set A = 0, so 60 seconds on the timer
                        \ increments back round to 0 seconds

.time2

 STA clockSeconds,X     \ Update the seconds value for the timer

 LDA clockMinutes,X     \ Finally, we add the minutes
 ADC #0
 STA clockMinutes,X

 BPL time3              \ If the updates minutes value for the timer is
                        \ positive, jump to time3 to skip the following

 JSR ZeroTimer          \ Otherwise the timer just reached the maximum possible
                        \ value, so wrap it back round to zero

 LDY currentPlayer      \ Set the total race time for the current player to -1,
 LDA #&80               \ as otherwise the driver might finish with a very low
 STA totalRaceMinutes,Y \ time just because the race timer looped back to zero

.time3

 PLP                    \ Retrieve the C flag from the stack, which will be set
                        \ if the addition of tenths overflowed (in other words,
                        \ if the lap time just ticked on to the next second)

 CLD                    \ Clear the D flag to switch arithmetic to normal

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintSecondLineGap
\       Type: Subroutine
\   Category: Text
\    Summary: Prints a text token on the second text line at the top of the
\             driving screen, with an empty gap on the line above
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The token number (0 to 54) to print on the second text
\                       line at the top of the screen
\
\ ******************************************************************************

.PrintSecondLineGap

 JSR PrintSecondLine    \ Print token X on the second text line at the top of
                        \ the screen

 LDX #45                \ Print token 45 (38 spaces) on the first text line of
 JSR PrintFirstLine     \ at the top of the screen, which blanks the top line

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ResetVariables
\       Type: Subroutine
\   Category: Main Loop
\    Summary: Reset a number of variables for driving, and print the top two
\             text lines
\
\ ******************************************************************************

.ResetVariables

 LDA #0                 \ Set A = 0, so we can use it to reset variables to zero
                        \ in the following loops

 LDX #&68               \ We start by zeroing all zero-page variables from
                        \ playerMoving to processContact, so set up a loop
                        \ counter in X

.rese1

 STA playerMoving,X     \ Zero the X-th byte from playerMoving

 DEX                    \ Decrement the loop counter

 BPL rese1              \ Loop back until we have zeroed all variables from
                        \ playerMoving to processContact

 LDX #&7F               \ We now zero all variables from xPlayerCoordLo to
                        \ L62FF, so set up a loop counter in X

.rese2

 STA xPlayerCoordLo,X   \ Zero the X-th byte from xPlayerCoordLo

 DEX                    \ Decrement the loop counter

 BPL rese2              \ Loop back until we have zeroed all variables from
                        \ xPlayerCoordLo to L62FF

 JSR DefineEnvelope     \ Define the first (and only) sound envelope

 LDX #23                \ We now zero the 24-byte blocks at objTrackSection and
                        \ objSectionCount, and initialise all 24 bytes in
                        \ (objProgressHi objProgressLo), so set up a loop
                        \ counter in X

 STX previousSignNumber \ Set previousSignNumber = 23

.rese3

 LDA trackPracticeHi    \ Set the X-th byte of (objProgressHi objProgressLo) to
 STA objProgressHi,X    \ the 16-bit value in (trackPracticeHi trackPracticeLo),
 LDA trackPracticeLo    \ which is &034B for the Silverstone track
 STA objProgressLo,X

 LDA #0                 \ Zero the X-th byte of objTrackSection
 STA objTrackSection,X

 STA objSectionCount,X  \ Zero the X-th byte of objSectionCount

 DEX                    \ Decrement the loop counter

 BPL rese3              \ Loop back until we have zeroed or copied all 24
                        \ variable bytes

 JSR SetPlayerPositions \ Set the current player's position in currentPosition,
                        \ plus the number of the position ahead in positionAhead
                        \ and number of the position behind in positionBehind

 LDA #1                 \ Set A = 1, to pass to ResetCarsOnTrack as the spacing
                        \ for the cars when this is a race

 BIT raceStarted        \ If bit 7 of raceStarted is set then this is a race
 BMI rese4              \ rather than practice or qualifying, so jump to rese4
                        \ to skip the following

                        \ This is a practice or qualifying lap, so we set the
                        \ player's position as specified in the track data

 LDX trackStartPosition \ Set X to trackStartPosition, the starting position for
                        \ practice or qualifying laps, which is 4 for the
                        \ Silverstone track

 LDY currentPosition    \ Set Y to the current player's position

 JSR SwapDriverPosition \ Swap the positions of drivers in positions X and Y in
                        \ the driversInOrder table, so for Silverstone this sets
                        \ the current player's position to 4

 JSR SetPlayerPositions \ Set the current player's position in currentPosition,
                        \ plus the number of the position ahead in positionAhead
                        \ and number of the position behind in positionBehind

 LDA trackCarSpacing    \ Set A to trackCarSpacing, to pass to ResetCarsOnTrack
                        \ as the spacing for the cars when this is a qualifying
                        \ lap (this value is 40 for the Silverstone track)

.rese4

                        \ By this point, A = 1 if this is a race, or the value
                        \ of trackCarSpacing if this is practice or qualifying
                        \ (40 for Silverstone)

 JSR ResetCarsOnTrack   \ Reset the cars on the track, placing them on the
                        \ starting grid if this is a race, or spread out along
                        \ the track if this is a qualifying lap

 LDX #19                \ We now zero the 20-byte blocks at driverLapNumber,
                        \ carSteering, carProgress, (carSpeedHi carSpeedLo) and
                        \ carStatus, and initialise the 20-byte blocks at
                        \ objectStatus, totalRaceMinutes and carSectionSpeed,
                        \ so set up a loop counter in X

.rese5

 LDA #%10000000         \ Set the X-th byte of objectStatus to %10000000, so the
 STA objectStatus,X     \ object is hidden

 STA totalRaceMinutes,X \ Set the X-th byte of totalRaceMinutes to -1

 LDA #0                 \ Zero the X-th byte of driverLapNumber
 STA driverLapNumber,X

 STA carSteering,X      \ Zero the X-th byte of carSteering

 STA carProgress,X      \ Zero the X-th byte of carProgress

 STA carSpeedHi,X       \ Zero the X-th byte of carSpeedHi

 STA carStatus,X        \ Zero the X-th byte of carStatus

 STA carSpeedLo,X       \ Zero the X-th byte of carSpeedLo

 LDA #255               \ Set the X-th byte of carSectionSpeed to 255
 STA carSectionSpeed,X

 DEX                    \ Decrement the loop counter

 BPL rese5              \ Loop back until we have zeroed or initialised all 20
                        \ bytes in each block

 LDA #1                 \ Set gearNumber = 1, to set the gears to neutral
 STA gearNumber

 STA pastHalfway        \ Set pastHalfway = 1, so the player is in the second
                        \ half of the track (which is true for both practice
                        \ and qualifying, as well as the starting grid)

 LDX #7                 \ Set L0009 = 7
 STX L0009

 DEX                    \ Set L0006 = 6
 STX L0006

 STX L0008              \ Set L0008 = 6

 DEX                    \ We now zero the six bytes at mirrorContents to clear
                        \ all six segments of the wing mirrors, so set X = 5 to
                        \ use as a loop counter

.rese6

 STA mirrorContents,X   \ Clear the contents of the X-th wing mirror segment

 DEX                    \ Decrement the loop counter

 BPL rese6              \ Loop back until we have zeroed all six mirror segments

 JSR PrintGearNumber    \ Print the new gear number on the gear stick (neutral)

 LDA raceStarted        \ If bit 7 of raceStarted is set then this is a race
 BMI rese7              \ rather than practice or qualifying, so jump to rese7
                        \ with bit 7 of A set and bit 6 of A clear, to print the
                        \ race header at the top of the screen

 LDX #40                \ Blank out the first text line at the top of the screen
 JSR PrintSecondLineGap \ and print token 40 on the second line, to give:
                        \
                        \    "                                      "
                        \    "Lap Time   :         Best Time        "

 LDX #1                 \ Zero the lap timer
 JSR ZeroTimer

 JSR PrintBestLapTime   \ Print the best lap time and the current lap time at
                        \ the top of the screen

 LDA #&DF               \ Set firstLapStarted = -33
 STA firstLapStarted

 RTS                    \ Return from the subroutine

.rese7

 STA updateDrivingInfo  \ Set bit 7 and clear bit 6 of updateDrivingInfo so the
                        \ lap number gets printed at the top of the screen

 STA updateDriverInfo   \ Set bit 7 of updateDriverInfo so the driver names get
                        \ printed at the top of the screen

 LDX #43                \ Print token 43 on the first text line at the top of
 JSR PrintFirstLine     \ the screen and token 44 on the second line, to give:
 LDX #44                \
 JSR PrintSecondLine    \    "Position        In front:             "
                        \    "Laps to go        Behind:                  "
                        \
                        \ Token 44 includes five extra spaces at the end, though
                        \ I'm not sure why

 LDA currentPosition    \ Set A to the current player's position

 JSR ConvertNumberToBCD \ Convert the number in A into binary coded decimal
                        \ (BCD), adding 1 in the process

 STA positionChangeBCD  \ Set positionChangeBCD to the current player's position
                        \ in BCD

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawBackground
\       Type: Subroutine
\   Category: Graphics
\    Summary: Set the background colour for all the track lines in the track
\             view
\  Deep dive: Drawing the track view
\
\ ******************************************************************************

.DrawBackground

 LDX L0051              \ Set X = L0051

 LDY horizonLine        \ Set Y to the track line number of the horizon

 LDA var23Hi,X          \ Set A = X-th entry in var23Hi + 20
 CLC
 ADC #20

 BPL bgnd1              \ If A is positive, jump to bgnd1 to set the lines below
                        \ the horizon to the colour of grass

 LDA var24Hi,X          \ Set A = X-th entry in var24Hi + 20
 CLC
 ADC #20

 BMI bgnd1              \ If A is negative, jump to bgnd1 to set the lines below
                        \ the horizon to the colour of grass

 LDA #%00100000         \ Set A = %00100000 (colour 0, black) for the horizon
                        \ line and all lines below it, so the view below the
                        \ horizon is all track

 BNE bgnd2              \ Jump to bgnd2 (this BNE is effectively a JMP as A is
                        \ never zero)

.bgnd1

 LDA #%00100011         \ Set A = %00100011 (colour 3, green) for the horizon
                        \ line and all lines below it, so the view below the
                        \ horizon is all grass

.bgnd2

 STA backgroundColour,Y \ Set the colour of the horizon line to A, which also
                        \ sets the horizon line to the only non-zero line colour
                        \ (as backgroundColour is all zeroes at this point)

 LDA #%00100001         \ Set A = %00100011 (colour 1, blue) to use as the line
                        \ colour for lines above the horizon, i.e. the sky

 LDY #79                \ We now loop through all the track lines, starting from
                        \ line 79 at the top of the track view down to 0 at the
                        \ bottom, so set a counter in Y

.bgnd3

 LDX backgroundColour,Y \ Set X to the background colour for track line Y

 BEQ bgnd4              \ If it is zero, then this can't be the horizon line (as
                        \ we set that to a non-zero value above), so jump to
                        \ bgnd4 as we have not already set the colour

 TXA                    \ If we get here then X is non-zero, so we must have
                        \ reached the horizon line, so set A to the value we
                        \ stored for the horizon line above, so that all the
                        \ rest of the lines get set to this colour

.bgnd4

 STA backgroundColour,Y \ Set the background colour for track line Y to A

 DEY                    \ Decrement the loop counter to move down to the next
                        \ track line

 BPL bgnd3              \ Loop back until we have set the line colour for all
                        \ 80 track lines

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CopyDashData
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Copy the dash data from the main game code to screen memory, and
\             vice versa
\  Deep dive: The jigsaw puzzle binary
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The direction of the copy:
\
\                         * Bit 7 clear = copy from game code to screen memory
\
\                         * Bit 7 set = copy from screen memory to game code
\
\ ******************************************************************************

.CopyDashData

 STA T                  \ Store A in T, so bit 7 of T determines the direction
                        \ of the copy

 LDX #3                 \ First, we copy the four bytes at dashDataAddress to
                        \ P, Q, R and S, so set a loop counter in X for the four
                        \ bytes

.dash1

 LDA dashDataAddress,X  \ Copy the X-th byte of dashDataAddress to the X-th
 STA P,X                \ byte of P

 DEX                    \ Decrement the loop counter

 BPL dash1              \ Loop back until we have copied all four bytes

                        \ So we now have the following:
                        \
                        \   (Q P) = the location of the first block in the main
                        \           game code
                        \
                        \   (S R) = the location of the first block in screen
                        \           memory (i.e. at the end of screen memory, as
                        \           the first block in the game code is the last
                        \           block in screen memory)
                        \
                        \ We now copy 41 blocks of memory from one address to
                        \ the other, with the direction determined by the value
                        \ of bit 7 in T (which we set above)
                        \
                        \ We work through each block by starting at offset 79
                        \ from the start of (Q P) and (S R), and decrementing
                        \ the offset until it matches the dashDataOffset value
                        \ for this block
                        \
                        \ We store the block number (which goes from 0 to 40)
                        \ in X, and the offset (which goes from 79 down to
                        \ dashDataOffset,X + 1) in Y

 LDX #0                 \ Set a block counter in X to count through 41 blocks

.dash2

 LDY #79                \ Each block we want to copy ends at the start address
                        \ plus 79, so set an index counter in Y, which we can
                        \ use to work our way backwards through each byte in
                        \ the block

 LDA #0                 \ Set V = 0 to act as a byte counter to go from 0 to the
 STA V                  \ number of bytes copied

.dash3

 BIT T                  \ If bit 7 of T is set, skip the following two
 BMI dash4              \ instructions so we copy from (S R) to (Q P)

 LDA (P),Y              \ Copy the Y-th byte of (Q P) to the Y-th byte of (S R)
 STA (R),Y

.dash4

 LDA (R),Y              \ Copy the Y-th byte of (S R) to the Y-th byte of (Q P)
 STA (P),Y

 INC V                  \ Increment the byte counter

 DEY                    \ Decrement the index counter

 TYA                    \ If Y <> the dashDataOffset value for block X, loop
 CMP dashDataOffset,X   \ to keep copying the contents of this block
 BNE dash3

                        \ We have copied a block of memory, so we now need to
                        \ update (Q P) and (S R) to point to the next block to
                        \ copy
                        \
                        \ When in screen memory, the blocks are stored one after
                        \ the other, in reverse order, so the address of the
                        \ next block to copy is the start address of the block
                        \ we just copied in (S R), minus the size of the block
                        \ we just copied, which is in V, so the next block will
                        \ be at (S R) - V

 LDA R                  \ Set (S R) = (S R) - V
 SEC                    \
 SBC V                  \ starting with the low bytes
 STA R

 BCS dash5              \ And decrementing the high byte of (S R) if the low
 DEC S                  \ byte wraps around

.dash5

                        \ When in the main game code, the blocks are stored
                        \ every &80 bytes, so the address of the next block is
                        \ (Q P) + &80
                        \
                        \ Note that each block takes up a different amount of
                        \ memory, as follows:
                        \
                        \   Block starts at: (Q P) + dashDataOffset,X + 1
                        \   Block ends at:   (Q P) + 79
                        \
                        \ It's the value of (Q P) that is spaced out by &80 for
                        \ each block, rather than the actual data in the block
                        \ (for each block, (Q P) to (Q P) + dashDataOffset,X
                        \ is used for other purposes)

 LDA P                  \ Set (Q P) = (Q P) + &80
 CLC                    \
 ADC #&80               \ starting with the low bytes
 STA P

 BCC dash6              \ And incrementing the high byte of (Q P) if the low
 INC Q                  \ byte overflows

.dash6

 INX                    \ Increment the block counter to point to the next block
                        \ to copy

 CPX #41                \ Loop back to copy the next block until we have copied
 BNE dash2              \ all 41 blocks

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: dashDataAddress
\       Type: Variable
\   Category: Dashboard
\    Summary: Addresses for copying the first block of dash data between the
\             main game code and screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashDataAddress

 EQUW dashData          \ The location of the first block in the game code

 EQUW &8000 - 80        \ The location of the first block in screen memory

\ ******************************************************************************
\
\       Name: sub_C1933
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C1933

 LDA var24Hi,X
 CLC
 ADC #&14
 CMP #&28
 ROR V
 RTS

\ ******************************************************************************
\
\       Name: sub_C193E
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C193E

 STA P196F+1
 STY L004B
 DEY
 STY U
 JSR sub_C1933
 LDY horizonLine
 JMP C1977

.C194E

 LDA V
 BPL C1955
 JSR sub_C1933

.C1955

 LDA yVergeRight,X
 CMP #&50
 BCS C1980
 BIT V
 BPL C1965
 CMP yVergeRight+1,X
 BEQ C19A5

.C1965

 CMP N
 BCS C19A5

.C1969

 STA RR
 TXA
 JMP C1973

.P196F

 STA L0400,Y
 DEY

.C1973

 CPY RR
 BNE P196F

.C1977

 STY N

.C1979

 INX
 BMI C1996
 CPX U
 BCC C194E

.C1980

 LDA yVergeRight,X
 BMI C198E
 CMP N
 BCC C198E
 LDA N
 STA yVergeRight,X

.C198E

 TXA
 ORA #&80
 TAX
 LDA #0
 BEQ C1969

.C1996

 LDX L0050

.P1998

 LDA L5EE0,X
 BPL C19A2
 INX
 CPX U
 BCC P1998

.C19A2

 STX L0050
 RTS

.C19A5

 LDA #&80
 ORA L5EE0,X
 STA L5EE0,X
 BMI C1979

\ ******************************************************************************
\
\       Name: sub_C19AF
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   0 to 3
\
\ ******************************************************************************

.sub_C19AF

 STY L0027
 STA L004C
 CMP L004B
 BCS C1A1F
 CLC
 ADC L30FC,Y
 STA L004F

 LDA var29Hi,Y          \ Modify the following instruction at mod_C2F4E and
 STA mod_C2F4E+2        \ mod_C2F90, depending on the value of Y:
 STA mod_C2F90+2        \
 LDA var29Lo,Y          \   * 0 = STA &7000,Y -> STA leftVergeStart,Y
 STA mod_C2F4E+1        \   * 1 = STA &7000,Y -> STA leftTrackStart,Y
 STA mod_C2F90+1        \   * 2 = STA &7000,Y -> STA rightVergeStart,Y
                        \   * 3 = STA &7000,Y -> STA rightGrassStart,Y

 LDX L004F
 LDY L004C
 SEC
 JSR sub_C2B26

.C19D7

 INX
 INY
 CPY L004B
 BCS C1A1F
 LDA L5EE0,Y
 BMI C19D7
 LDA L004C
 CMP L0050
 BCC C19F8
 BNE C19FD
 LDA L5EE0-1,Y
 AND #3
 BNE C1A10
 STY L0050
 SEC
 LDA L0027
 BEQ C1A15

.C19F8

 LDA KK
 CLC
 BCC C1A15

.C19FD

 LDA L5EE0-1,Y
 AND #3
 BNE C1A10
 LDA L0027
 CMP #1
 BEQ C1A15
 CMP #2
 BEQ C1A15
 LDA #0

.C1A10

 ASL A
 ASL A
 CLC
 ADC L0032

.C1A15

 JSR sub_C2B26
 STY L004C
 STX L004F
 JMP C19D7

.C1A1F

 RTS

\ ******************************************************************************
\
\       Name: DrawTrack
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the track into the screen buffer
\
\ ******************************************************************************

.DrawTrack

 LDA #&80
 STA P
 LDA L0051
 CLC
 ADC #&28
 TAX
 CMP #&31
 BCS dtra1
 LDA #&31

.dtra1

 STA L0050
 LDA #LO(L0400)
 STA R
 STA MM
 LDY L0012
 JSR sub_C193E
 LDY #0
 STY L0032
 LDA L0050
 JSR sub_C19AF
 LDA #8
 STA L0032
 LDY #0
 STY KK
 INY
 LDA L0051
 CLC
 ADC #&28
 JSR sub_C19AF
 LDA L0050
 LDX #4
 JSR sub_C1A98
 STY L002C
 LDA L0051
 TAX
 CMP #9
 BCS dtra2
 LDA #9

.dtra2

 STA L0050
 LDX L0051
 LDA #LO(L0450)
 LDY L0015
 JSR sub_C193E
 LDA #&1C
 STA KK
 LDA #&10
 STA L0032
 LDY #2
 LDA L0051
 JSR sub_C19AF
 LDA #&1C
 STA L0032
 LDY #3
 LDA L0050
 JSR sub_C19AF
 LDA L0050
 LDX #&14
 JSR sub_C1A98
 STY L0029
 RTS

\ ******************************************************************************
\
\       Name: sub_C1A98
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C1A98

 STX GG
 STA U
 DEC L004B
 LDA L62F2
 CMP #&28
 BCC C1B05
 BCS C1B0B

.C1AA7

 LDY yVergeRight,X
 CPY #&50
 BCS C1B03
 LDA L5EE0,X
 BMI C1B03
 LDA GG
 CMP #&14
 BEQ C1AC4
 LDA var25Hi,X
 STA W
 LDA var24Hi,X
 JMP C1ACC

.C1AC4

 LDA var24Hi,X
 STA W
 LDA var25Hi,X

.C1ACC

 CLC
 ADC #&14
 BMI C1B03
 LDA W
 CLC
 ADC #&14
 BPL C1B03

.P1AD8

 LDA L5EE0+1,X
 BPL C1AE4
 INX
 INC U
 CPX L004B
 BCC P1AD8

.C1AE4

 LDA backgroundColour,Y
 STA T
 LDA backgroundColour,Y
 BEQ C1AF9
 AND #&1C
 CMP GG
 BEQ C1AF9
 ROR A
 EOR T
 BMI C1B03

.C1AF9

 LDA L5EE0,X
 AND #3
 ORA GG
 STA backgroundColour,Y

.C1B03

 INC U

.C1B05

 LDX U
 CPX L004B
 BCC C1AA7

.C1B0B

 LDX L0050
 LDY yVergeRight,X
 INY
 RTS

\ ******************************************************************************
\
\       Name: DrawCornerMarkers
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw any visible corner markers
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   markersToDraw       The number of corner markers to draw - 1
\
\ ******************************************************************************

.DrawCornerMarkers

 LDY #0                 \ We work our way through the markers we need to draw,
                        \ using Y as the marker number, counting up from 0 to
                        \ markersToDraw - 1

.corn1

 CPY markersToDraw      \ If Y = markersToDraw, then we have drawn all the
 BEQ corn7              \ markers, so jump to corn7 to reset markersToDraw to
                        \ zero and return from the subroutine

 LDX L62B4,Y            \ Set X = L62B4 for marker Y

 STY temp1              \ Store the marker number in temp1, so we can retrieve
                        \ it at the end of the loop

 LDA L6299,Y            \ If bit 5 of L6299 for marker Y is clear, then the
 AND #%00100000         \ marker is white, so skip the following two
 BEQ corn2              \ instructions

 LDA #%00001111         \ Map logical colour 2 in the colour palette to physical
 STA colourPalette+2    \ colour 1 (red in the track view)

.corn2

 LDA var27Hi,Y          \ Set (U A) = (var27Hi var27Lo) for marker Y
 STA U
 LDA var27Lo,Y

 ASL A                  \ Set (U A) = (U A) << 1
 ROL U                  \           = var27 << 1

 STA T                  \ Set (U T) = (U A)
                        \           = var27 << 1

 CLC                    \ Set (A V) = (U A) + X-th value from var24
 ADC var24Lo,X          \
 STA V                  \ starting with the low bytes

 LDA var24Hi,X          \ And then the high bytes
 ADC U

 CMP #24                \ If A < 24, jump to corn3
 BCC corn3

 CMP #232               \ If A < 232, i.e. 24 <= A < 232, jump to corn6 to move
 BCC corn6              \ on to the next loop

.corn3

                        \ If we get here then A < 24 or A >= -24

 ASL V                  \ Set (A V) = (A V) << 2
 ROL A                  \
 ASL V                  \ so A < 96 or A >= -96
 ROL A

 CLC                    \ Set xCoord = A + 80
 ADC #80                \
 STA xCoord             \ where 80 is the x-coordinate of the middle of the
                        \ screen (as the screen is 160 pixels wide)

 LDA yVergeRight,X      \ Set yCoord = X-th value from yVergeRight
 STA yCoord

 LDY #2                 \ Set Y = 2 so the following loop shifts (U T) left by
                        \ two places

.corn4

 ASL T                  \ Set (U T) = (U T) << 1
 ROL U

 DEY                    \ Decrement the shift counter

 BNE corn4              \ Loop back until we have left-shifted by Y places

 LDA U                  \ Set A = U

 BPL corn5              \ If A is positive, jump to corn5 to skip the following

 EOR #&FF               \ A is negative, so negate A using two's complement, so
 CLC                    \ A now contains |U|
 ADC #1

.corn5

 STA scaleUp            \ Set scaleUp = |U|

 LDA #6                 \ Set objectType = 6, the object type for a corner
 STA objectType         \ marker

 JSR DrawObject         \ Draw the corner marker

.corn6

 LDA #%11110000         \ Map logical colour 2 in the colour palette to physical
 STA colourPalette+2    \ colour 1 (white in the track view), which sets it back
                        \ to the default value

 LDY temp1              \ Set Y to the marker counter that we stored in temp1 at
                        \ the start of the loop

 INY                    \ Increment the marker counter to draw the next loop

 JMP corn1              \ Loop back to corn1

.corn7

 LDA #0                 \ Reset markersToDraw to zero as we have drawn all the
 STA markersToDraw      \ corner markers

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UpdatePositionInfo
\       Type: Subroutine
\   Category: Text
\    Summary: Apply any position changes and update the position information at
\             the top of the screen
\
\ ******************************************************************************

.UpdatePositionInfo

 LDA positionChangeBCD  \ Set A = positionChangeBCD

 BEQ posi1              \ If A = 0 then the race position has not changed, so
                        \ jump to posi1 to skip updating the position number

                        \ Otherwise we need to add the position change to the
                        \ current position number, so we can update the number
                        \ at the top of the screen

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

 CLC                    \ Set A = currentPositionBCD + A
 ADC currentPositionBCD \       = currentPositionBCD + positionChangeBCD

 STA currentPositionBCD \ Set currentPositionBCD = A

 CLD                    \ Clear the D flag to switch arithmetic to normal

 BEQ posi1              \ If A = 0, jump to posi1

 CMP #&21               \ If A >= &21, jump to posi1
 BCS posi1

 LDX #0                 \ Set positionChangeBCD = 0, as we have now applied the
 STX positionChangeBCD  \ change of position to currentPositionBCD

 STX G                  \ Set G = 0 so the call to Print2DigitBCD below will
                        \ print the second digit and will not print leading
                        \ zeroes when printing the position number

 LDX #10                \ Print the position number in A at column 10, pixel
 LDY #24                \ row 24, on the first text line at the top of the
 JSR Print2DigitBCD-6   \ screen

.posi1

 BIT updateDriverInfo   \ If bit 7 of updateDriverInfo is clear, jump to posi2
 BPL posi2              \ to skip printing the driver names at the top of the
                        \ screen

 LDY positionAhead      \ Set Y to the position of the driver in front of us

 LDA #24                \ Print the name of driver Y in the "In front:" part of
 JSR PrintNearestDriver \ the header

 LDY positionBehind     \ Set Y to the position of the driver behind us

 LDA #33                \ Print the name of driver Y in the "Behind:" part of
 JSR PrintNearestDriver \ the header

.posi2

 LSR updateDriverInfo   \ Clear bit 7 of updateDriverInfo so we don't update the
                        \ driver names until the value of updateDriverInfo
                        \ changes

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ProcessContact
\       Type: Subroutine
\   Category: Driving model
\    Summary: Process collosions between the player and the other cars
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   V                   Bit 7 is set if there is a collision
\
\ ******************************************************************************

.ProcessContact

 LDA processContact     \ If processContact is zero then there no other cars
 BEQ DrawObjectEdge-1   \ close enough to the player's car for there to be any
                        \ contact, so return from the subroutine (as
                        \ DrawObjectEdge-1 contains an RTS)

 LDA #0                 \ Set processContact = 0 to reset the flag, so we only
 STA processContact     \ check for contact when a car is flagged as being close

 SEC                    \ Set bit 7 of V
 ROR V

 LDA #37                \ Set A = 37 - objectDistanceLo
 SEC                    \
 SBC objectDistanceLo   \ The value of (objectDistanceHi objectDistanceLo) is
                        \ left over from the last call to CheckForContact, which
                        \ was last called for the nearest car in front of us
                        \ when building object for the five cars in front of us,
                        \ from furthest to nearest, as part of this chain of
                        \ routines:
                        \
                        \   MoveAndDrawCars > BuildVisibleCar > BuildCarObjects
                        \                   > GetObjectAngles > CheckForContact
                        \
                        \ Note that BuildVisibleCar does get called once more at
                        \ the end of MoveAndDrawCars, for the car behind us, but
                        \ as that car is not visible, it doesn't set the object
                        \ distance
                        \
                        \ So, in short, objectDistanceLo is the low byte of the
                        \ distance between the player and the nearest car, which
                        \ is the car we want to process for a collision
                        \
                        \ This means that a higher value of A means a closer
                        \ collision, so this is effectively a measure of how
                        \ dangerous this collision is, in the range 0 to 37

 BCS cont1              \ If the above subtraction didn't underflow then the
                        \ other car is at a distance of 37 or less, so jump to
                        \ cont1 to skip the following instruction

 LDA #5                 \ The subtraction underflowed, so the other car is a bit
                        \ of a distance away, so set A = 5 so have a minor
                        \ collision

.cont1

 ASL A                  \ Set A = A * 2
                        \
                        \ so the damage measure is now in the range 0 to 74

 STA U                  \ Set U = A, so U now contains the damage measure in the
                        \ range 0 to 74

 LDX collisionDriver    \ Set X to the driver number of the car being hit (the
                        \ "other car")

 LDY currentPlayer      \ Set Y to the driver number of the current player

 CMP #40                \ If A < 40, then the collision is not bad enough to
 BCC cont2              \ push the other car off the track, so jump to cont2

 LDA raceStarted        \ If bit 7 of raceStarted is clear then this is either
 BPL cont2              \ a practice or qualifying lap, so jump to cont2 to skip
                        \ the following instruction

 JSR PushCarOffTrack    \ If we get here then the collision is close enough to
                        \ push the other car off the track, and this is a race,
                        \ so we push the other car off the track and out of the
                        \ race

.cont2

 LDA objRotationHi,X    \ Set A to the rotation about the y-axis for the other
 SEC                    \ car minus the rotation about the y-axis for the
 SBC playerRotationHi   \ player, which we will call dRotation

 ASL A                  \ Set A = A * 4
 ASL A                  \       = dRotation * 4

 PHP                    \ Push the N flag onto the stack, which contains the
                        \ sign of dRotation

 LDA carSpeedHi,Y       \ Set A to the high byte of the player's speed

 CPX #20                \ If the driver number of the other car is >= 20, then
 BCS cont4              \ jump to cont4 as this is not a computer-controlled
                        \ driver, so we do not adjust its speed

 CMP carSpeedHi,X       \ If the high byte of the player's speed is >= the high
 BCS cont3              \ byte of the other driver's speed, jump to cont3 with
                        \ A containing the higher of the two speeds, so the
                        \ other car gets bumped to a slightly higher speed than
                        \ the faster car (by adding 12, as the C flag is set)

 LDA carSpeedHi,X       \ Set A to the high byte of the other driver's speed, so
                        \ A now contains the higher of the two speeds

 BNE cont4              \ Jump to cont4 to leave the speed of the other car
                        \ alone, as it is going faster than the player (this BNE
                        \ is efftively a JMP, as we know from the above that
                        \ carSpeedHi,Y < carSpeedHi,X, which implies that the
                        \ value of carSpeedHi,X must be non-zero)

.cont3

                        \ If we get here, it's because the player is going
                        \ faster than the other car, and we jumped here via a
                        \ BCS, so the C flag is set, which means the following
                        \ adds 12 to the other car's speed

 ADC #11                \ Increase the high byte of the other driver's speed by
 STA carSpeedHi,X       \ 12, to speed it up after being hit by the faster
                        \ player's car

.cont4

                        \ By this point, A contains the speed of the faster car
                        \ following the collision, as the high byte of the speed

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = carSpeedHi * damage measurement (0 to 74)
                        \
                        \ So (A T) is higher with closer and faster collisions

 CMP #16                \ If A < 16, jump to cont5 to skip the following
 BCC cont5

 LDA #16                \ A >= 16, so set A to 16 as the maximum value of A

.cont5

                        \ By this point, (A T) is a measurement of how dangerous
                        \ the collision was, on a scale of 0 to 16

 PLP                    \ Restore the sign of dRotation, which we stored on the
                        \ stack above, so the N flag is positive if the other
                        \ car's rotation angle is larger (i.e. the other car is
                        \ to the right of the player's car), or negative if the
                        \ other car's rotation angle is smaller (i.e. the other
                        \ car is to the left of the player's car)

 JSR Absolute16Bit      \ Set the sign of (A T) to match the result of the
                        \ subtraction above, so A is now in the range -16 to
                        \ +16, with the sign reflecting the position of the
                        \ other car:
                        \
                        \   * -16 to 0 if the other car is to the left
                        \
                        \   * 0 to +16 if the other car is to the right

                        \ Fall through into SquealTyres to set spinSpeedHi and
                        \ make the sound of squealing tyres

\ ******************************************************************************
\
\       Name: SquealTyres
\       Type: Subroutine
\   Category: Driving model
\    Summary: Make the tyres squeal
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The new value for spinSpeedHi
\
\ ******************************************************************************

.SquealTyres

 STA spinSpeedHi        \ Set spinSpeedHi = A

 LDA #%10000000         \ Set bit 7 in L62A6 and L62A7, so the tyres squeal
 STA L62A6
 STA L62A7

 LDA #4                 \ Make sound #4 (crash/contact) at the current volume
 JSR MakeSound-3        \ level

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawObjectEdge (Part 1 of 5)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Draw the specified edge of an object part
\  Deep dive: Creating objects from edges
\
\ ------------------------------------------------------------------------------
\
\ This part of the routine calculates the pixel x-coordinate of the edge, plus
\ the block number and pixel x-coordinate of the next edge (if there is one), so
\ we can use them in the next call to DrawObjectEdge.
\
\ Arguments:
\
\   topTrackLine        Top track line of the edge (higher value, 0 to 79)
\
\   bottomTrackLine     Bottom track line of the edge (lower value, 0 to 79)
\
\   thisEdge            This edge (as a scaled scaffold measurement)
\
\   nextEdge            The next edge (as a scaled scaffold measurement)
\
\   xCoord              The pixel x-coordinate of the centre of the object
\
\   colourData          Colour data:
\
\                         * Bits 0-1 = logical fill colour
\
\                         * Bits 2-3 = logical edge colour
\
\                         * Bit 4 = if set and this is a left or right edge,
\                           then use the fill colour instead of the edge colour
\                           if this is an outside edge (i.e. a left edge in the
\                           left half of the screen, or a right edge in the
\                           right half of the screen), so the edge is
\                           effectively hidden
\
\   A                   The fill colour to the right of the edge to draw:
\
\                         * For left edges: bits 0-1 contain the fill colour
\                           from bits 0-1 of the colour data
\
\                         * For right edges: contains 0
\
\                         * For extra edges: bits 0-1 contain the fill colour
\                           from bits 0-1 of the colour data
\
\   Y                   Edge type:
\
\                         * 0 = second or third edge in a four-edge object part
\                               (an "extra edge")
\
\                         * 1 = left edge
\
\                         * 2 = right edge
\
\   rightOfEdge         The fill byte to the right of the previous edge (or, if
\                       this is the first edge, the background colour to the
\                       left of the first edge)
\
\                       If this is a second call to DrawObjectEdge and we need
\                       to draw this edge in the same pixel byte as the previous
\                       edge, this contains the pixel byte from the previous
\                       call with the first edge already drawn
\
\   blockNumber         For extra or right edges only: the dash data block
\                       number of the previous edge drawn by DrawObjectEdge
\
\   nextEdgeCoord       For extra or right edges only: the pixel x-coordinate
\                       of the edge to draw (as returned by the previous call to
\                       DrawObjectEdge)
\
\   nextBlockNumber     For extra or right edges only: the data block number of
\                       the edge to draw (returned by the previous call to
\                       DrawObjectEdge)
\
\   prevEdgeInByte      Determines whether we have already inserted the previous
\                       edge into the pixel byte we are building
\
\                         * 0 = there is no other edge in the pixel byte we are
\                               building
\
\                         * Non-zero = the previous edge is already in the pixel
\                                      byte we are building, and the current
\                                      edge needs to go in the same byte
\
\   edgePixelMask       For extra or right edges only:
\
\                         * 0 = there is no other edge in the pixel byte we are
\                               building
\
\                         * Non-zero = the pixel mask of the edge that was drawn
\                                      into rightOfEdge in the previous call
\
\ Returns:
\
\   blockNumber         The dash data block number that was drawn into
\
\   rightOfEdge         The fill byte to the right of the edge we just drew:
\
\                         * If we just successfully drew an edge and drew the
\                           result on-screen, this contains the fill colour of
\                           the object
\
\                         * If we created a pixel byte but the next edge needs
\                           to be drawn in the same byte, this contains the
\                           pixel byte from this call
\
\   edgePixelMask       The pixel mask of the edge that was drawn, which will:
\
\                         * Be empty if the previous edge was already drawn
\                           and we do not need to share this pixel byte with
\                           the previous edge
\
\                         * Contain set pixels for the previous edge if both
\                           this edge and the previous edge need to share the
\                           same pixel byte
\
\   nextEdgeCoord       The pixel x-coordinate for the next edge
\
\   nextBlockNumber     The dash data block number for the next edge
\
\   prevEdgeInByte      The correct setting for the next edge:
\
\                         * 0 if the next edge is not in the same byte as the
\                           one we just drew
\
\                         * Non-zero (bit 7 is set) if the next edge is in the
\                           same byte as the one we just drew (in which case the
\                           screen has not been updated, and the next call to
\                           DrawObjectEdge needs to insert the next edge into
\                           the pixel byte in rightOfEdge, using the pixel
\                           mask in edgePixelMask)
\
\ Other entry points:
\
\   DrawObjectEdge-1    Contains an RTS
\
\ ******************************************************************************

.DrawObjectEdge

 STY J                  \ Set J to the edge type in Y, so we can fetch it later

 LDX rightOfEdge        \ Set leftOfEdge = rightOfEdge, so we effectively step
 STX leftOfEdge         \ along the line, from the previous edge to this edge
                        \ (so the fill byte to the right of the previous edge
                        \ becomes the fill byte to the left of this edge)

 AND #3                 \ Set X to bits 0-1 of A, which contains the logical
 TAX                    \ colour of the object's fill colour

 LDA objectPalette,X    \ Set rightOfEdge to logical colour X from the object
 STA rightOfEdge        \ palette, so we fill the object to the right of this
                        \ edge with the colour in A

 LDA blockNumber        \ Set prevBlockNumber to the dash data block number that
 STA prevBlockNumber    \ was left over from the previous call to DrawObjectEdge
                        \ so we can use it if this isn't a left edge

 LDA colourData         \ Set X to bits 2-3 of colourData, which contains the
 AND #%00001100         \ logical colour of the edge we want to draw
 LSR A
 LSR A
 TAX

 LDA objectPalette,X    \ Set edgePixel to logical colour X from the object
 STA edgePixel          \ palette, which we will mask later to contain just the
                        \ single pixel required to draw the edge

 LDA #0                 \ Set P = 0, for use as the low byte of (Q P), in which
 STA P                  \ we are going to build the address we need to draw into
                        \ in the dash data

                        \ We now set thisEdge and blockNumber according to the
                        \ edge type:
                        \
                        \   * Left edge, set:
                        \
                        \       thisEdge = xCoord + thisEdge / 2
                        \       blockNumber = thisEdge / 4
                        \
                        \   * Right or extra edge, set:
                        \
                        \       thisEdge = nextEdgeCoord
                        \       blockNumber = blockNumberForNext

 CPY #1                 \ If Y <> 1, jump to draw3
 BNE draw3

                        \ If we get here then Y = 1, so we are drawing the left
                        \ edge

 LDA thisEdge           \ Set A to the scaled scaffold measurement for the left
                        \ edge, which was passed to the routine in thisEdge

                        \ We now set A = A / 2, retaining the sign in A and
                        \ rounding towards zero

 BPL draw1              \ If A is positive, jump to draw1

 SEC                    \ Set A = A / 2, inserting a set bit into bit 7 to
 ROR A                  \ retain the sign of A, and rounding the division up
 ADC #0                 \ towards zero by adding bit 0 of A to the result

 JMP draw2              \ Jump to draw2 to skip the following instruction

.draw1

 LSR A                  \ Set A = A / 2, which will retain the sign of A as we
                        \ know A is positive, rounding the result down towards
                        \ zero

.draw2

 CLC                    \ Set thisEdge = A + xCoord
 ADC xCoord             \              = thisEdge / 2 + xCoord
 STA thisEdge

 LSR A                  \ Set blockNumber = A / 4
 LSR A                  \                 = thisEdge / 4
 STA blockNumber

 JMP draw4              \ Jump to draw4

.draw3

                        \ We jump here if Y <> 1, i.e. Y = 0 or 2, so we are
                        \ either drawing an extra edge or the right edge

 LDA nextBlockNumber    \ Set blockNumber = nextBlockNumber
 STA blockNumber

 LDA nextEdgeCoord      \ Set thisEdge = nextEdgeCoord
 STA thisEdge

 CPY #0                 \ If Y <> 0, jump to draw7
 BNE draw7

.draw4

                        \ We have now set thisEdge and blockNumber according to
                        \ the edge type, so now we set nextEdgeCoord and
                        \ nextBlockNumber as follows:
                        \
                        \   nextEdgeCoord = xCoord + nextEdge / 2
                        \
                        \   nextBlockNumber = nextEdgeCoord / 4

 LDA nextEdge           \ Set A to the scaled scaffold measurement for the next
                        \ edge

                        \ We now set A = A / 2, retaining the sign in A and
                        \ rounding towards zero

 BPL draw5              \ If A is positive, jump to draw5

 SEC                    \ Set A = A / 2, inserting a set bit into bit 7 to
 ROR A                  \ retain the sign of A, and rounding the division up
 ADC #0                 \ towards zero by adding bit 0 of A to the result

 JMP draw6              \ Jump to draw6 to skip the following instruction

.draw5

 LSR A                  \ Set A = A / 2, which will retain the sign of A as we
                        \ know A is positive, rounding the result down towards
                        \ zero

.draw6

 CLC                    \ Set nextEdgeCoord = A + xCoord
 ADC xCoord             \        = nextEdge / 2 + xCoord
 STA nextEdgeCoord

 LSR A                  \ Set nextBlockNumber = A / 4
 LSR A                  \        = nextEdgeCoord / 4
 STA nextBlockNumber

                        \ By this point we have:
                        \
                        \   * Left edge:
                        \
                        \       thisEdge = xCoord + thisEdge / 2
                        \       blockNumber = thisEdge / 4
                        \
                        \   * Right or extra edge, set:
                        \
                        \       thisEdge = nextEdgeCoord
                        \       blockNumber = blockNumberForNext
                        \
                        \ and we also have the following:
                        \
                        \   nextEdgeCoord = xCoord + nextEdge / 2
                        \   nextBlockNumber = nextEdgeCoord / 4
                        \
                        \ So we have:
                        \
                        \   * leftOfEdge contains the fill colour of the object,
                        \     or if the previous edge is within the same pixel
                        \     byte and we are now drawing the next edge, it
                        \     contains the pixel byte from the previous call,
                        \     which contains the previous edge
                        \
                        \   * rightOfEdge contains the fill colour, or (if we
                        \     need to draw this edge in the same pixel byte as
                        \     the previous edge), it contains the pixel byte
                        \     from the previous call
                        \
                        \   * edgePixel contains a four-pixel byte in the edge
                        \     colour passed in bits 2-3 of colourData, which we
                        \     will mask later to a single pixel
                        \
                        \   * thisEdge contains the pixel x-coordinate of the
                        \     edge to draw
                        \
                        \   * blockNumber contains the dash data block number
                        \     for the edge to draw (as each dash data block is
                        \     four pixels wide)
                        \
                        \   * nextEdgeCoord and nextBlockNumber contain the
                        \     pixel x-coordinate and dash data block number of
                        \     the next edge, ready to be used in the next call
                        \     to DrawObjectEdge

\ ******************************************************************************
\
\       Name: DrawObjectEdge (Part 2 of 5)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate the screen address for the edge we want to draw
\  Deep dive: Creating objects from edges
\
\ ******************************************************************************

.draw7

 LDA blockNumber        \ Set A to the dash data block number for the edge to
                        \ draw, which we stored in blockNumber in part 1

 CMP #20                \ If blockNumber >= 20, set bit 0 of T, otherwise clear
 ROL T                  \ it, so bit 0 of T is clear if the edge is in the left
                        \ half of the screen, and set if the edge is in the
                        \ right half

 LSR A                  \ Set (A P) = (A P) >> 1
 ROR P                  \           = (blockNumber 0) >> 1
                        \           = blockNumber * 128
                        \           = blockNumber * &80

 CLC                    \ Set (Q P) = (A P) + dashData
 ADC #HI(dashData)      \
 STA Q                  \ This addition works because the low byte of dashData
                        \ is zero

                        \ So we now have:
                        \
                        \   (Q P) = dashData + blockNumber * &80
                        \
                        \ which is the start address of the dash data block,
                        \ because the dash data blocks occur every &80 bytes
                        \ from dashData

IF _ACORNSOFT

 STA draw27+2           \ Modify the following instruction at draw27:
 LDA P                  \
 STA draw27+1           \   LDX &3000,Y -> LDX #(Q P),Y
                        \
                        \ This is pseudo-code, but it means we have modified the
                        \ instruction to load the Y-th byte from the dash data
                        \ block address we just calculated, i.e. load the Y-th
                        \ byte of the dash data block for the edge to draw

ENDIF

 LDX blockNumber        \ Set X to the dash data block number for the edge to
                        \ draw

 CPX #40                \ If blockNumber < 40 then blockNumber is a valid dash
 BCC draw8              \ data block number in the range 0 to 39, so jump to
                        \ draw8 to keep going

 JMP draw32             \ Otherwise blockNumber is not a valid dash data block
                        \ number and is off the right edge of the screen, so
                        \ jump to draw32 to work out whether we need to fill
                        \ the object all the way to the right edge of the screen

.draw8

 LDA bottomTrackLine    \ Set A = bottomTrackLine, which is the number of the
                        \ track line at the bottom of the object, and which is
                        \ the same as the offset into the dash data block for
                        \ the bottom edge

 CMP dashDataOffset,X   \ If A >= the dash data offset for our dash data block,
 BCS draw9              \ then A is pointing to dash data, so jump to draw9 to
                        \ skip the following instruction

 LDA dashDataOffset,X   \ Set A to the dash data offset for our dash data block,
                        \ so it points to the first byte of the block's dash
                        \ data (i.e. the lowest byte of the dash data block
                        \ on-screen)

.draw9

 STA blockOffset        \ Set blockOffset = A, so blockOffset contains the dash
                        \ data block offset for the bottom track line of the
                        \ edge we want to draw

 CMP topTrackLine       \ If A < topTrackLine, then the track lines are the
 BCC draw11             \ right way around, so jump to draw11 to keep going in
                        \ part 3

 CPY #1                 \ If Y <> 1, then we are drawing either a right edge or
 BNE draw10             \ an extra edge, so jump to draw29 via draw10 to check
                        \ whether we need to fill to the left of this edge, and
                        \ then move on to the next edge

                        \ If we get here then A >= topTrackLine and Y = 1, so
                        \ we are drawing the left edge and the bottom track line
                        \ is higher than the top track line, which means there
                        \ is nothing to draw, so we return from the subroutine

 RTS                    \ Return from the subroutine

.draw10

 JMP draw29             \ Jump to draw29 to check whether we need to fill to the
                        \ left of this edge, and then move on to the next edge

\ ******************************************************************************
\
\       Name: DrawObjectEdge (Part 3 of 5)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Construct a pixel byte for the edge we want to draw
\  Deep dive: Creating objects from edges
\
\ ******************************************************************************

.draw11

 LDA colourData         \ If bit 4 of colourData is clear, jump to draw12 to
 AND #%00010000         \ keep the edge colour we set at the start of part 1
 BEQ draw12

 TYA                    \ If Y = 0, then we are drawing an extra edge, so jump
 BEQ draw12             \ to draw12 to keep the edge colour we set at the start
                        \ of part 1

                        \ Otherwise bit 4 of colourData is set and this is a
                        \ left or right edge, which means we use the fill colour
                        \ instead of the edge colour, but only if this is an
                        \ outside edge (i.e. a left edge in the left half of the
                        \ screen, or a right edge in the right half of the
                        \ screen), so the edge is effectively hidden by merging
                        \ it into the object's fill

 EOR T                  \ Set A = bit 0 of Y EOR bit 0 of T
 AND #1

 BEQ draw12             \ If A = 0, then one of the following is true:
                        \
                        \   * Y = 2 (%10) and bit 0 of T = 0, in which case we
                        \     are drawing a right edge in the left half of the
                        \     screen
                        \
                        \   * Y = 1 (%01) and bit 0 of T = 1, in which case we
                        \     are drawing a left edge in the right half of the
                        \     screen
                        \
                        \ In either case, jump to draw12 to keep the colour we
                        \ set in edgePixel at the start of part 1, as this is
                        \ not an outside edge

                        \ If we get here then bit 4 of colourData is set, and we
                        \ are drawing a left or right edge as an outside edge,
                        \ so we set the edge colour to the logical colour in
                        \ bits 0-1 of colourData, i.e. the fill colour

 LDA colourData         \ Set X to bits 0-1 of colourData, which contains the
 AND #%00000011         \ fill colour of the object part we are drawing
 TAX

 LDA objectPalette,X    \ Set edgePixel to the fill colour, so the edge merges
 STA edgePixel          \ into the object's background

.draw12

 LDA thisEdge           \ Set A to thisEdge, which we set in part 1 to the
                        \ pixel x-coordinate of the edge to draw

 AND #3                 \ Set X = A mod 4, which is the number of the pixel of
 TAX                    \ the edge we want to draw within the four-pixel byte
                        \ (i.e. 0 to 3, left to right)

 LDA yLookupLo+8,X      \ Set A to the X-th pixel mask from yLookupLo+8, which
                        \ is a pixel byte with the X-th pixel clear

 EOR #&FF               \ Invert A so it contains a pixel byte with only the
                        \ X-th pixel set

 AND edgePixel          \ Apply the pixel mask to the edge colour in edgePixel,
 STA edgePixel          \ so edgePixel now contains a pixel byte with only the
                        \ X-th pixel set, and that pixel is set to the edge
                        \ colour

 CPY #1                 \ If Y >= 1, then we are drawing a left or right edge,
 BCS draw16             \ so jump to draw16

                        \ If we get here then Y = 0, so we are drawing one of
                        \ the extra edges as part of a four-edge object part

 LDA pixelsToLeft,X     \ Set A to the X-th pixel mask from pixelsToLeft, which
                        \ is a pixel byte with all the pixels set to the left of
                        \ the X-th pixel

 AND leftOfEdge         \ Set these pixels to leftOfEdge, which is either the
 STA T                  \ fill colour of the object (if there is just this edge
                        \ in the pixel byte), or it's the pixel byte with the
                        \ previous edge already drawn (if we have both edges in
                        \ the same byte)
                        \
                        \ In either case, this fills the pixel byte with the
                        \ correct contents to the left of this edge and stores
                        \ them in T

 LDA rightOfEdge        \ Set A to a pixel byte with the pixels to the right of
 AND pixelsEdgeRight,X  \ the X-th pixel set to rightOfEdge, so this is the same
                        \ thing but with the bytes to the right of the edge

 ORA T                  \ OR the two together so we have a pixel byte with the
                        \ correct bytes to the left and right of this edge

 AND yLookupLo+8,X      \ Apply the X-th pixel mask from yLookupLo+8, so this
                        \ clears the X-th pixel in the pixel byte

 ORA edgePixel          \ We set up edgePixel above to contain a single pixel
                        \ for the edge in position X, set to the edge colour,
                        \ so this sets the X-th pixel in A to the edge colour,
                        \ so the pixel byte in A now contains the edge itself

 STA I                  \ A now contains a pixel byte with the correct bytes set
                        \ to the left and right of the edge, plus the correct
                        \ colour set for the edge pixel, so store this pixel
                        \ byte in I

 LDA prevEdgeInByte     \ If prevEdgeInByte = 0 then this edge is the first one
 BEQ draw13             \ in this byte, so jump to draw13 to potentially draw
                        \ this edge using a quick-draw routine that doesn't
                        \ worry about any existing background content (as this
                        \ is always overwritten by the extra parts in the middle
                        \ of the object part)

                        \ If we get here then prevEdgeInByte is non-zero, so
                        \ this pixel byte contains both the previous edge and
                        \ this edge

 LDA #0                 \ Set prevEdgeInByte = 0, to reset it for the next call
 STA prevEdgeInByte     \ to DrawObjectEdge, as we have moved on to the next
                        \ edge since it was made non-zero

 LDA edgePixelMask      \ Set L to the pixel mask for the previous edge, which
 STA L                  \ we set in the previous call to DrawObjectEdge to have
                        \ bits set for the pixels to the right of the previous
                        \ edge, so once the extra edges are done we can use it
                        \ when filling the last part of the extra section

 EOR #&FF               \ Set A to the inverse, so it has bits set for the
                        \ pixels of the previous edge and everything to its left

 AND I                  \ Insert the pixels from I so the left part of our pixel
                        \ byte is given the correct edge and everything to the
                        \ left

 JMP draw17             \ Jump to draw17 to draw the edge using this pixel byte

.draw13

                        \ If we get here then we are not sharing this pixel byte
                        \ with the previous edge, so we can use a quick-draw
                        \ routine that doesn't worry about any existing
                        \ background content (as this is an extra edge)

 LDX blockNumber        \ If blockNumber <> nextBlockNumber, then the next edge
 CPX nextBlockNumber    \ isn't in the same dash data block (i.e. in the same
 BNE draw14             \ column), so jump to draw14 to draw this edge

                        \ Otherwise the next edge is in the same byte as this
                        \ one, so we need to return from the subroutine via
                        \ draw29 (i.e. first check whether we need to fill to
                        \ the left of this edge, and then return)

 LDA I                  \ Store the pixel byte in rightOfEdge so the next call
 STA rightOfEdge        \ to DrawObjectEdge can add the next edge to it

 JMP draw29             \ Jump to draw29 to check whether we need to fill to the
                        \ left of this edge, and then move on to the next edge

.draw14

                        \ We now draw this edge using a quick-draw routine that
                        \ doesn't worry about any existing background content

 LDA I                  \ Set A to the pixel byte for the edge we want to draw

 BNE draw15             \ If the pixel byte is non-zero, jump to draw15 to skip
                        \ the following instruction

 LDA #&55               \ Set A = &55 to use as the value of WW below (&55 in
                        \ the screen buffer represents colour 0, or black)

.draw15

 LDY topTrackLine       \ Set Y = topTrackLine, which is the number of the
                        \ track line at the top of the object, which is the
                        \ same as the offset into the dash data block for the
                        \ top edge

 JMP DrawEdge           \ Jump to DrawEdge to draw the edge from topTrackLine
                        \ down to blockOffset, which we set in part 2 to the
                        \ bottom track line of the edge we want to draw, and
                        \ rejoin the routine at draw29 for the next edge

.draw16

                        \ If we get here then we are drawing either a left or
                        \ right edge, and Y is 1 or 2 respectively

 BNE draw18             \ We did a CPY #1 before jumping here, so this jumps to
                        \ draw18 if Y <> 1, i.e. Y = 2, so we jump to draw18 if
                        \ we are drawing a right edge

                        \ If we get here then we are drawing a left edge in
                        \ pixel X within the pixel byte, so we now calculate the
                        \ pixel byte for the left edge

 LDA pixelsToLeft,X     \ Set A to the X-th pixel mask from pixelsToLeft, which
                        \ is a pixel byte with all the pixels set to the left of
                        \ the X-th pixel - in other words, with all the pixels
                        \ outside of the object (to the left of the left edge)
                        \ set

 STA L                  \ Store this pixel mask in L, so L contains a pixel mask
                        \ containing the pixels to the left of the left edge

 EOR #&FF               \ Invert A so it contains a pixel byte with the X-th
                        \ pixel set, plus all the pixels to the right - in other
                        \ words, with the edge and the inside of the object set

 AND rightOfEdge        \ Set the object pixels to rightOfEdge, which contains
                        \ the fill colour for the object (as at this point we
                        \ won't be sharing a pixel byte with the previous edge,
                        \ as there is no previous edge)

 AND yLookupLo+8,X      \ Apply the X-th pixel mask from yLookupLo+8, so this
                        \ clears the X-th pixel in the pixel byte

 ORA edgePixel          \ We set up edgePixel above to contain a single pixel
                        \ for the edge in position X, set to the edge colour,
                        \ so this sets the X-th pixel in A to the edge colour,
                        \ so the pixel byte in A now contains the edge itself

.draw17

                        \ If we get here then we are either drawing a left edge,
                        \ or this is a four-edge object part and we are sharing
                        \ this pixel byte with the previous edge

 LDX blockNumber        \ If blockNumber <> nextBlockNumber, then the next edge
 CPX nextBlockNumber    \ isn't in the same dash data block (i.e. in the same
 BNE draw19             \ column) as this one, so jump to draw19 to draw this
                        \ edge

                        \ If we get here then:
                        \
                        \   * The next edge is in the same pixel byte as the
                        \     edge we are currently drawing, so we don't draw
                        \     this byte yet, but instead return from the routine
                        \     so the next call to DrawObjectEdge can pick up the
                        \     baton and insert the next edge into the byte we
                        \     just created
                        \
                        \   * The C flag is set, as the above comparison was
                        \     blockNumber = nextBlockNumber

 STA rightOfEdge        \ Set rightOfEdge to the pixel byte in A, ready for
                        \ the next call to DrawObjectEdge to pick it up

 LDA L                  \ Set edgePixelMask to the pixel mask in L, which
 STA edgePixelMask      \ contains the pixels to the left of the left edge, to
                        \ pass to the next call to DrawObjectEdge

 ROR prevEdgeInByte     \ Set bit 7 of prevEdgeInByte, so it is non-zero for the
                        \ next call to DrawObjectEdge, to indicate that the next
                        \ edge needs to be inserted into the pixel byte that we
                        \ just built, alongside the current edge

 RTS                    \ Return from the subroutine

.draw18

                        \ If we get here then we are drawing a right edge in
                        \ pixel X within the pixel byte, so we now calculate the
                        \ pixel byte for the right edge
                        \
                        \ This routine draws the right edge in the pixel byte,
                        \ making sure we keep any previous edge that's already
                        \ drawn in the same pixel byte

 LDA edgePixelMask      \ Set A to the edge pixel mask of the previous edge,
                        \ which will:
                        \
                        \   * Be empty if the previous edge was already drawn
                        \     and we do not need to share this pixel byte with
                        \     the previous edge
                        \
                        \   * Contain set pixels for the previous edge if both
                        \     this edge and the previous edge need to share the
                        \     same pixel byte

 ORA pixelsToRight,X    \ The pixelsToRight table contains pixel bytes with all
                        \ the pixels set to the right of the X-th pixel, so this
                        \ sets all the pixels to the right of the X-th pixel

                        \ A now contains a pixel byte with pixels set to the
                        \ right of this edge, and if the previous edge is in the
                        \ same byte, pixels are also set to the left of that
                        \ edge

 STA L                  \ Store this pixel mask in L so we can use it in part 4,
                        \ so L contains a pixel mask containing the pixels to
                        \ the right of the right edge (and the left of the
                        \ previous edge, if it's in the same byte)

 EOR #&FF               \ Invert A so it contains the pixels of this edge, plus
                        \ the previous edge if this was drawn in the same byte

 AND leftOfEdge         \ Set these pixels to leftOfEdge, which is either the
                        \ fill colour of the object (if there is just this edge
                        \ in the pixel byte), or it's the pixel byte of the
                        \ previous edge (if we have both edges in the same byte)
                        \
                        \ In either case, this fills the pixel byte with the
                        \ correct contents

 AND yLookupLo+8,X      \ Apply the X-th pixel mask from yLookupLo+8, so this
                        \ clears the X-th pixel in the pixel byte

 ORA edgePixel          \ We set up edgePixel above to contain a single pixel
                        \ for the edge in position X, set to the edge colour,
                        \ so this sets the X-th pixel in A to the edge colour,
                        \ so the pixel byte in A now contains the edge itself

                        \ So we now have a pixel byte in A that contains this
                        \ edge in the correct colour, and if this pixel byte
                        \ also contains the previous edge, that's in there too

\ ******************************************************************************
\
\       Name: DrawObjectEdge (Part 4 of 5)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Draw the edge into the screen buffer, merging with any content
\             already in the buffer
\  Deep dive: Creating objects from edges
\
\ ******************************************************************************

.draw19

                        \ By this point, we have the following:
                        \
                        \   * A contains the pixel byte we need to use to draw
                        \     this edge (incorporating the previous edge if it's
                        \     close enough to to be in the same pixel byte)
                        \
                        \   * L contains a pixel mask containing set pixels for
                        \     those pixels outside of the object and its fill,
                        \     so to the left of the left edge, or to the right
                        \     of the right edge, or to the left and right
                        \     of pixel byte that contains two edges
                        \
                        \   * (Q P) contains the address of the dash data block
                        \     containing the edge we want to draw
                        \
                        \   * blockOffset contains the dash data block offset
                        \     for the bottom track line of the edge we want to
                        \     draw
                        \
                        \   * topTrackLine contains the number of the track line
                        \     at the top of the edge we want to draw
                        \
                        \ So now we actually draw the edge

 STA I                  \ Set I to the pixel byte for the edge we want to draw

IF _ACORNSOFT

 BNE draw20             \ If the pixel byte is non-zero, jump to draw20 to skip
                        \ the following instruction

 LDA #&55               \ Set A = &55 to use as the value of WW below (&55 in
                        \ the screen buffer represents colour 0, or black)

.draw20

 STA WW                 \ Set WW to the pixel byte (or &55 if the pixel byte is
                        \ zero)

 LDA #0                 \ Set edgePixelMask = 0, so the next call to
 STA edgePixelMask      \ DrawObjectEdge ignores any edges from this call (as
                        \ we are about to draw them on-screen)

 LDY blockOffset        \ Set W to the current screen buffer byte at the bottom
 LDA (P),Y              \ of the edge that we want to draw
 STA W

 LDA #&AA               \ Replace the byte at the bottom of the edge with &AA,
 STA (P),Y              \ to use as a marker

 LDY topTrackLine       \ Set Y = topTrackLine, which is the number of the
                        \ track line at the top of the object, which is the
                        \ same as the offset into the dash data block for the
                        \ top edge

 JMP draw24             \ Jump into the following loop at the entry point draw24
                        \ to draw the edge from the top byte to the bottom byte
                        \
                        \ We jump into the loop with the following set:
                        \
                        \   * Y contains the offset of the top of the edge we
                        \     want to draw, which we now use as a loop counter
                        \     to work our way from the top of the edge to the
                        \     bottom (i.e. Y gets decremented as we draw each
                        \     pixel byte)
                        \
                        \   * The bottom track line of the edge contains the
                        \     marker byte &AA
                        \
                        \   * W contains the original byte that was in the
                        \     marker's location

.draw21

                        \ We loop back here if we fetch the next byte down from
                        \ the screen buffer into A and find that it is non-zero

 CMP #&55               \ If the current byte is &55, then this represents black
 BNE draw22             \ (colour 0), so set A = 0 so it's the correct pixel
 LDA #0                 \ byte for the current buffer contents

.draw22

 AND L                  \ The bit mask in L contains set pixels for those
                        \ outside of the edge and its fill, and clear pixels for
                        \ the edge and object fill, so this clears the pixels
                        \ where we want to draw the edge and object fill

 ORA I                  \ Replace those cleared bits with the edge and fill that
                        \ we want to draw

 BNE draw23             \ If the result is non-zero, then jump to draw23 to skip
                        \ the following instruction

 LDA #&55               \ The result is zero, i.e. colour 0 (black), so set
                        \ A = &55, which is the value we use to represent
                        \ colour 0 (black) in the screen buffer

.draw23

 STA (P),Y              \ Draw the resulting pixel byte into the screen buffer
                        \ by writing it to the Y-th byte of the relevant dash
                        \ data block

 DEY                    \ Decrement the track line counter in Y to move down to
                        \ the next pixel line on-screen

.draw24

                        \ This is the entry point for the loop, which is between
                        \ draw21 and the loop's end logic at draw28

 LDA (P),Y              \ If the current byte in the screen buffer is non-zero,
 BNE draw28             \ then it is not empty, so jump to draw28 to merge the
                        \ pixel byte with the non-empty byte that's already in
                        \ the screen buffer

.draw25

 JSR GetColour          \ The current byte in the screen buffer is zero, which
                        \ means it should inherit the colour of the byte to the
                        \ left, so call GetColour to work out what this byte's
                        \ colour would be on-screen, and put it into A

 AND L                  \ The bit mask in L contains set pixels for those
                        \ outside of the edge and its fill, and clear pixels for
                        \ the edge and object fill, so this clears the pixels
                        \ where we want to draw the edge and object fill

 ORA I                  \ Replace those cleared bits with the edge and fill that
                        \ we want to draw

 BNE draw26             \ If the result is non-zero, then jump to draw23 to skip
                        \ the following instruction

 LDA #&55               \ The result is zero, i.e. colour 0 (black), so set
                        \ A = &55, which is the value we use to represent
                        \ colour 0 (black) in the screen buffer

.draw26

 STA (P),Y              \ Draw the resulting pixel byte into the screen buffer
                        \ by writing it to the Y-th byte of the relevant dash
                        \ data block

 DEY                    \ Decrement the track line counter in Y to move down to
                        \ the next pixel line on-screen

.draw27

 LDX &3000,Y            \ Set X to the Y-th byte in the screen buffer, which is
                        \ the next byte down the screen after the one we just
                        \ draw
                        \
                        \ Gets modified at the start of part 2 as follows:
                        \
                        \   LDX &3000,Y -> LDX #(Q P),Y
                        \
                        \ In other words, we have modified the instruction to
                        \ load the Y-th byte from the dash data block address
                        \ for the edge we are drawing, i.e. load the Y-th byte
                        \ of dash data block blockNumber

 BEQ draw26             \ If the next byte down the screen is zero, then loop
                        \ back to draw26 to draw the edge in this byte as well,
                        \ so we keep drawing the edge downwards while the
                        \ existing contents of the screen buffer are empty

 TXA                    \ The next byte down the screen is non-zero, so copy the
                        \ value into A

.draw28

 CMP #&AA               \ If this is not the marker for the bottom of the edge,
 BNE draw21             \ loop back to draw21 to draw the next pixel byte over
                        \ the top of this non-empty byte in the screen buffer

                        \ We just reached a value that matches the marker at the
                        \ bottom of the edge, which is either our marker or a
                        \ valid entry in the screen buffer that happens to have
                        \ this value

 LDA #0                 \ Overwrite the &AA value with 0, though this appears to
 STA (P),Y              \ have no effect, as if we loop back to draw25 in the
                        \ following conditional, this value will be overwritten,
                        \ and if we fall through to the LDA W below, it will
                        \ be overwritten there

 CPY blockOffset        \ If Y <> blockOffset then this can't be our marker, as
 BNE draw25             \ the marker is on line blockOffset, so jump back to
                        \ draw25 to merge this byte with the correct background
                        \ colour

                        \ If we get here then we have reached our marker at the
                        \ bottom of the edge

 LDA W                  \ Restore the entry in the dash data block that we
 STA (P),Y              \ overwrote with the marker, whose original contents we
                        \ stored in W

 LDX J                  \ If the edge type in J = 1, then we have just drawn the
 CPX #1                 \ left edge, so jump to draw31 to return from the
 BEQ draw31             \ subroutine as we are done drawing

                        \ If we get here then we have just drawn an extra or
                        \ right edge, so we need to fill the next column to the
                        \ right of the edge we just drew (i.e. in the next block
                        \ along), so that the background colour is restored
                        \ after the object

 INC blockNumber        \ Fill the column to the right of the edge we just drew,
 JSR FillAfterObject    \ so the correct background colour is shown to the right
 DEC blockNumber        \ of the object part

ELIF _SUPERIOR

 LDA #0                 \ Set edgePixelMask = 0, so the next call to
 STA edgePixelMask      \ DrawObjectEdge ignores any edges from this call (as
                        \ we are about to draw them on-screen)

 LDY topTrackLine       \ Set Y = topTrackLine, which is the number of the
                        \ track line at the top of the object, which is the
                        \ same as the offset into the dash data block for the
                        \ top edge

 JMP sraw6              \ Jump into the following loop at the entry point sraw6
                        \ to draw the edge from the top byte to the bottom byte
                        \
                        \ We jump into the loop with the following set:
                        \
                        \   * Y contains the offset of the top of the edge we
                        \     want to draw, which we now use as a loop counter
                        \     to work our way from the top of the edge to the
                        \     bottom (i.e. Y gets decremented as we draw each
                        \     pixel byte)
                        \
                        \   * The bottom track line of the edge contains the
                        \     marker byte &AA
                        \
                        \   * W contains the original byte that was in the
                        \     marker's location

.sraw1

 LDA (P),Y              \ If the current byte in the screen buffer is zero, then
 BEQ sraw2              \ jump to sraw2 to work out what colour it would be
                        \ on-screen

 CMP #&55               \ If the current byte is not &55, then the current byte
 BNE sraw3              \ in the scren buffer contains something, so jump to
                        \ sraw3 with the contents in A

 LDA I                  \ The current byte in the screen buffer is &55, or
                        \ black, so set A to the pixel byte we want to draw

 BNE sraw5              \ If we want to draw something that isn't black (i.e.
                        \ which is non-zero), jump to sraw5 to store it in the
                        \ screen buffer

 BEQ sraw4              \ If we get here then we want to draw a black pixel
                        \ byte, so jump to sraw4 to store &55 in the screen
                        \ buffer (which is the screen buffer value for black)

.sraw2

 JSR GetColourS         \ The current byte in the screen buffer is zero, which
                        \ means it should inherit the colour of the byte to the
                        \ left, so call GetColourS to work out what this byte's
                        \ colour would be on-screen, and put it into A

.sraw3

                        \ At this point A contains the byte in the screen
                        \ buffer, converted into the byte it represents when
                        \ the buffer is copied to the screen

 AND L                  \ The bit mask in L contains set pixels for those
                        \ outside of the edge and its fill, and clear pixels for
                        \ the edge and object fill, so this clears the pixels
                        \ where we want to draw the edge and object fill

 ORA I                  \ Replace those cleared bits with the edge and fill that
                        \ we want to draw

 BNE sraw5              \ If the result is non-zero, then jump to sraw5 to skip
                        \ the following instruction

.sraw4

 LDA #&55               \ Set A = &55, which is the value we use to represent
                        \ colour 0 (black) in the screen buffer

.sraw5

 STA (P),Y              \ Draw the resulting pixel byte into the screen buffer
                        \ by writing it to the Y-th byte of the relevant dash
                        \ data block

 DEY                    \ Decrement the track line counter in Y to move down to
                        \ the next pixel line on-screen

.sraw6

                        \ This is the entry point for the loop, which is between
                        \ sraw1 and the loop's end logic in the next instruction

 CPY blockOffset        \ If Y <> blockOffset then this can't be our marker, as
 BNE sraw1              \ the marker is on line blockOffset, so jump back to
                        \ sraw1 to merge this byte with the correct background
                        \ colour

 LDX J                  \ If the edge type in J = 1, then we have just drawn the
 CPX #1                 \ left edge, so jump to draw31 to return from the
 BEQ draw31             \ subroutine as we are done drawing

                        \ If we get here then we have just drawn an extra or
                        \ right edge, so we need to fill the next column to the
                        \ right of the edge we just drew (i.e. in the next block
                        \ along), so that the background colour is restored
                        \ after the object

 INC blockNumber        \ Fill the column to the right of the edge we just drew,
 JSR FillAfterObject    \ so the correct background colour is shown to the right
 DEC blockNumber        \ of the object part

ENDIF

\ ******************************************************************************
\
\       Name: DrawObjectEdge (Part 5 of 5)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Fill the object if required and loop back for the next edge
\  Deep dive: Creating objects from edges
\
\ ******************************************************************************

.draw29

                        \ We have finished drawing the edge, so now we need to
                        \ fill the inside of the object part, from the previous
                        \ block to the current one

 LDA prevBlockNumber    \ If prevBlockNumber < 40, then it is a valid block
 CMP #40                \ number in the range 0 to 39, so jump to draw30 to skip
 BCC draw30             \ the following instruction and fill the object from
                        \ this block onwards

                        \ If we get here then prevBlockNumber is off-screen,
                        \ which means it must be off the left edge of the screen
                        \ (as we are working from left to right), so we now need
                        \ to fill from the left edge of the screen to the edge
                        \ we just drew

 LDA #&FF               \ Set prevBlockNumber = -1, so the following subtraction
 STA prevBlockNumber    \ sets:
                        \
                        \   A = blockNumber - prevBlockNumber - (1 - C)
                        \     = blockNumber - -1 - 1
                        \     = blockNumber
                        \
                        \ so the following fills this many blocks, which means
                        \ it fills all the blocks from the left edge of the
                        \ screen to the edge we just drew

.draw30

 LDA blockNumber        \ Set A = blockNumber - prevBlockNumber - (1 - C)
 CLC                    \       = blockNumber - prevBlockNumber - 1
 SBC prevBlockNumber

 BEQ draw31             \ If A <= 0, then:
 BMI draw31             \
                        \   blockNumber - prevBlockNumber - 1 <= 0
                        \
                        \   blockNumber - prevBlockNumber <= 1
                        \
                        \ so the current block and the previous block are either
                        \ the same block or neighbours, in which case there is
                        \ no gap to fill between the edges, so jump to draw31 to
                        \ return from the subroutine as we are done drawing

                        \ If we get here then A > 0, so from the above:
                        \
                        \   blockNumber - prevBlockNumber > 1
                        \
                        \ so there is at least one full block between the
                        \ current block and the previous block
                        \
                        \ We therefore need to fill this gap with the relevant
                        \ fill colour, with the number of blocks between the
                        \ two edges given in A (without including the edges
                        \ themselves)

 TAX                    \ Set X = A, so X contains the number of blocks we need
                        \ to fill to the left of the edge we just drew

 JSR FillInsideObject   \ Fill the inside of the object (i.e. all the blocks
                        \ between the previous edge and the edge we just drew)

.draw31

 RTS                    \ Return from the subroutine

.draw32

                        \ We jump here if the block number in blockNumber
                        \ is >= 40, which means we the edge we are trying to
                        \ draw is off the right of the screen, so now we need
                        \ to work out whether we need to fill the object up to
                        \ the edge of the screen

 LDY J                  \ If the edge type in J = 1, then we are drawing the
 CPY #1                 \ left edge, so jump to draw31 to return from the
 BEQ draw31             \ subroutine as the whole object part is off-screen

 LDA prevBlockNumber    \ If prevBlockNumber >= 40, then the dash data block
 CMP #40                \ number from the previous call to DrawObjectEdge is
 BCS draw31             \ also past the right edge of the screen, so jump to
                        \ draw31 to return from the subroutine as the whole
                        \ part between this edge and the previous edge is
                        \ off-screen

                        \ Otherwise we are drawing a right edge or an extra edge
                        \ and the previous call to DrawObjectEdge was on-screen,
                        \ so we need to fill between the previous edge and the
                        \ right edge of the screen

 LDA #40                \ Set blockNumber = 40 to represent the block beyond the
 STA blockNumber        \ right edge of the screen in the calculation at draw30,
                        \ which works out whether to call FillInsideObject to
                        \ fill from the previous edge to this block number

 BNE draw30             \ Jump to draw30 (this BNE is effectively a JMP as A is
                        \ never zero)

\ ******************************************************************************
\
\       Name: GetTyreDashEdge
\       Type: Subroutine
\   Category: Graphics
\    Summary: Copy the pixel bytes along the tyre and dashboard edges so they
\             can be feathered
\
\ ------------------------------------------------------------------------------
\
\ Modify the FillAfterObject routine before calling it.
\
\ Arguments:
\
\   X                   Sets the destination address for the copy
\
\   Y                   Alters the routine flow to either fill or copy
\
\   A                   The value to use when copying black pixel bytes
\
\ ******************************************************************************

IF _ACORNSOFT

.GetTyreDashEdge

 STX edge7+1            \ Modify the following instruction at edge7:
                        \
                        \   STA (P),Y -> STA (R),Y          when X = LO(R)
                        \
                        \   STA (P),Y -> STA (P),Y          when X = LO(P)

 STY edge11+1           \ Modify the following instruction at edge11:
                        \
                        \   BNE edge3 -> BNE edge1          when Y = &DF
                        \
                        \   BNE edge3 -> BNE edge3          when Y = &E7

 STA edge6+1            \ Modify the following instruction at edge6:
                        \
                        \   LDA #&55 -> LDA #0              when A = 0
                        \
                        \   LDA #&55 -> LDA #&55            when A = &55

                        \ Fall through into FillAfterObject to copy the edge
                        \ data to the location specified in (S R)

ENDIF

\ ******************************************************************************
\
\       Name: FillAfterObject
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Fill the block to the right of an object
\  Deep dive: Creating objects from edges
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   blockNumber         The dash data block number to draw in (i.e. the block
\                       to the right of the object)
\
\   blockOffset         The dash data offset for the bottom of the edge to draw
\
\   topTrackLine        Top track line number, i.e. the number of the start byte
\                       in the dash data block
\
\ ******************************************************************************

IF _ACORNSOFT

.FillAfterObject

 LDA blockNumber        \ Set A to the dash data block number in blockNumber

 CMP #40                \ If A >= 40 then this is not a valid dash data block
 BCS edge12             \ number, so jump to edge12 to return from the
                        \ subroutine

                        \ We now calculate the start address of dash data block
                        \ A, which will be at dashData + &80 * A (because the
                        \ dash data blocks occur every &80 bytes from dashData)
                        \
                        \ We do this using the following simplification:
                        \
                        \     dashData + &80 * A
                        \   = dashData + 256 / 2 * A
                        \   = HI(dashData) << 8 + LO(dashData) + A << 7
                        \
                        \ LO(dashData) happens to be zero (as dashData = &3000),
                        \ so we can keep going:
                        \
                        \   = HI(dashData) << 8 + A << 7
                        \   = (HI(dashData) << 1 + A) << 7
                        \   = ((HI(dashData) << 1 + A) << 8) >> 1
                        \
                        \ In other words, if we build a 16-bit number with the
                        \ high byte set to HI(dashData) << 1 + A, and then shift
                        \ the whole thing right by one place, we have our result
                        \
                        \ We do this below, storing the 16-bit number in (Q P)

 CLC                    \ Set A = A + HI(dashData) << 1
 ADC #HI(dashData)<<1   \
                        \ so our 16-bit number is (A 0), and we want to shift
                        \ right by one place

 LSR A                  \ Shift (A 0) right by 1, shifting bit 0 of A into the
                        \ C flag

 STA Q                  \ Set Q = A, to store the high byte of the result in Q

 STA edge9+2            \ Modify the high byte of the address in the instruction
                        \ at edge9 to Q

 LDA #0                 \ Shift the C flag into bit 7 of A, so A now contains
 ROR A                  \ the low byte of our result

 STA P                  \ Set P = A, to store the low byte of the result in P,
                        \ giving the result we wanted in (Q P)

 STA edge9+1            \ Modify the low byte of the address in the instruction
                        \ at edge9 to P, so if we have the following:
                        \
                        \   LDX &3000,Y -> LDX #(Q P),Y
                        \
                        \ This is pseudo-code, but it means we have modified the
                        \ instruction to load the Y-th byte from the dash data
                        \ block address we just calculated, i.e. load the Y-th
                        \ byte of dash data block A (i.e. dash data block
                        \ blockNumber)

 LDY blockOffset        \ Set Y to the dash data offset for the edge to draw

 LDA (P),Y              \ Set W to the byte in the dash data offset from this
 STA W                  \ block, which is the byte before the actual dash data

 LDA #&AA               \ Store &AA in this byte, so it can act as a marker for
 STA (P),Y              \ when we work our way through the data below

 LDY topTrackLine       \ Set Y to the number of the top track line, so we work
                        \ down from this byte within the data block, moving down
                        \ in memory until we reach the marker
                        \
                        \ So we are working down the screen, going backwards in
                        \ memory from byte topTrackLine to the marker that we
                        \ just placed at the start of the dash data

 JMP edge4              \ Jump into the following loop at the entry point edge4
                        \ to draw the fill from the top byte to the bottom byte

.edge1

                        \ This part of the loop, between edge1 and edge5, is
                        \ only used by the GetTyreDashEdge routine, which
                        \ modifies the loop to copy pixels instead of filling
                        \ them

 CMP #&55               \ If the current byte is &55, then this represents black
 BNE edge2              \ (colour 0), so set A = 0 so it's the correct pixel
 LDA #0                 \ byte for the current buffer contents

.edge2

 STA (R),Y              \ Store the pixel byte we fetched from the screen buffer
                        \ in the Y-th byte of (S R), which copies the byte from
                        \ the screen buffer into the address set up in the
                        \ CopyTyreDashEdges routine (i.e. this copies the edges
                        \ into tyreRightEdge or dashRightEdge)

.edge3

 DEY                    \ Decrement the byte counter to move down the screen
                        \ within the dash data block

.edge4

 LDA (P),Y              \ Fetch the Y-th byte from the dash data block

 BNE edge10             \ If the current byte in the screen buffer is non-zero,
                        \ then it is not empty, so jump to edge10 to move on to
                        \ the next byte, as we only need to fill empty bytes

.edge5

 JSR GetColour          \ The current byte in the screen buffer is zero, which
                        \ means it should inherit the colour of the byte to the
                        \ left, so call GetColour to work out what this byte's
                        \ colour would be on-screen, and put it into A

 BNE edge7              \ If the colour byte is non-zero, skip the following
                        \ instruction

.edge6

 LDA #&55               \ Set A = &55, which is the value we use to represent
                        \ colour 0 (black) in the screen buffer
                        \
                        \ Gets modified by the GetTyreDashEdge routine:
                        \
                        \   * LDA #0   when GetTyreDashEdge is called with
                        \              A = 0
                        \
                        \   * LDA #&55 when GetTyreDashEdge is called with
                        \              A = &55

.edge7

 STA (P),Y              \ Draw the resulting pixel byte into the screen buffer
                        \ by writing it to the Y-th byte of the relevant dash
                        \ data block
                        \
                        \ Gets modified by the GetTyreDashEdge routine:
                        \
                        \   * STA (R),Y when GetTyreDashEdge is called with
                        \               X = LO(R)
                        \
                        \   * STA (P),Y when GetTyreDashEdge is called with
                        \               X = LO(P)

.edge8

 DEY                    \ Decrement the byte counter to move down the screen
                        \ within the dash data block

.edge9

 LDX &3000,Y            \ Set X to the Y-th byte in the screen buffer, which is
                        \ the next byte down the screen after the one we just
                        \ draw
                        \
                        \ Gets modified at the start of part 2 as follows:
                        \
                        \   LDX &3000,Y -> LDX #(Q P),Y
                        \
                        \ In other words, we have modified the instruction to
                        \ load the Y-th byte from the dash data block address
                        \ for the edge we are drawing, i.e. load the Y-th byte
                        \ of dash data block blockNumber


 BEQ edge7              \ If the next byte down the screen is zero, then loop
                        \ back to edge7 to draw the edge in this byte as well,
                        \ so we keep drawing the edge downwards while the
                        \ existing contents of the screen buffer are empty

 TXA                    \ The next byte down the screen is non-zero, so copy the
                        \ value into A

.edge10

 CMP #&AA               \ Check to see if the next byte is the marker for the
                        \ bottom of the edge

.edge11

 BNE edge3              \ If this is not the marker for the bottom of the edge,
                        \ loop back to edge3 to draw the next pixel byte over
                        \ the top of this non-empty byte in the screen buffer
                        \
                        \ Gets modified by the GetTyreDashEdge routine:
                        \
                        \   * BNE edge1 when GetTyreDashEdge is called with
                        \               Y = &DF
                        \
                        \   * BNE edge3 when GetTyreDashEdge is called with
                        \               Y = &E7

 LDA #0                 \ Overwrite the &AA value with 0, though this appears to
 STA (P),Y              \ have no effect, as if we loop back to edge5 in the
                        \ following conditional, this value will be overwritten,
                        \ and if we fall through to the LDA W below, it will
                        \ be overwritten there

 CPY blockOffset        \ If Y <> blockOffset then this can't be our marker, as
 BNE edge5              \ the marker is on line blockOffset, so jump back to
                        \ edge5 to merge this byte with the correct background
                        \ colour

                        \ If we get here then we have reached our marker at the
                        \ bottom of the edge

 LDA W                  \ Restore the entry in the dash data block that we
 STA (P),Y              \ overwrote with the marker, whose original contents we
                        \ stored in W

.edge12

 RTS                    \ Return from the subroutine

ENDIF

\ ******************************************************************************
\
\       Name: GetTyreDashEdgeS
\       Type: Subroutine
\   Category: Graphics
\    Summary: Copy the pixel bytes along the tyre and dashboard edges so they
\             can be feathered
\
\ ------------------------------------------------------------------------------
\
\ Modify the FillAfterObject routine before calling it.
\
\ Arguments:
\
\   X                   Sets the destination address for the copy
\
\   Y                   Alters the routine flow to either fill or copy
\
\   A                   The value to use when copying black pixel bytes
\
\ ******************************************************************************

IF _SUPERIOR

.GetTyreDashEdgeS

 STX sedg7+1            \ Modify the following instruction at sedg7:
                        \
                        \   STA (P),Y -> STA (R),Y          when X = LO(R)
                        \
                        \   STA (P),Y -> STA (P),Y          when X = LO(P)

 STY sedg5+1            \ Modify the following instruction at sedg5:
                        \
                        \   BNE sedg8 -> BNE sedg1          when Y = &EF
                        \
                        \   BNE sedg8 -> BNE sedg8          when Y = &09

 STA sedg6+1            \ Modify the following instruction at sedg6:
                        \
                        \   LDA #&55 -> LDA #0              when A = 0
                        \
                        \   LDA #&55 -> LDA #&55            when A = &55

                        \ Fall through into FillAfterObjectS to copy the edge
                        \ data to the location specified in (S R)

ENDIF

\ ******************************************************************************
\
\       Name: FillAfterObjectS
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Fill the block to the right of an object
\  Deep dive: Creating objects from edges
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   blockNumber         The dash data block number to draw in (i.e. the block
\                       to the right of the object)
\
\   blockOffset         The dash data offset for the bottom of the edge to draw
\
\   topTrackLine        Top track line number, i.e. the number of the start byte
\                       in the dash data block
\
\ ******************************************************************************

IF _SUPERIOR

.FillAfterObjectS

 LDA blockNumber        \ Set A to the dash data block number in blockNumber

 CMP #40                \ If A >= 40 then this is not a valid dash data block
 BCS sedg10             \ number, so jump to sedg10 to return from the
                        \ subroutine

                        \ We now calculate the start address of dash data block
                        \ A, which will be at dashData + &80 * A (because the
                        \ dash data blocks occur every &80 bytes from dashData)
                        \
                        \ We do this using the following simplification:
                        \
                        \     dashData + &80 * A
                        \   = dashData + 256 / 2 * A
                        \   = HI(dashData) << 8 + LO(dashData) + A << 7
                        \
                        \ LO(dashData) happens to be zero (as dashData = &3000),
                        \ so we can keep going:
                        \
                        \   = HI(dashData) << 8 + A << 7
                        \   = (HI(dashData) << 1 + A) << 7
                        \   = ((HI(dashData) << 1 + A) << 8) >> 1
                        \
                        \ In other words, if we build a 16-bit number with the
                        \ high byte set to HI(dashData) << 1 + A, and then shift
                        \ the whole thing right by one place, we have our result
                        \
                        \ We do this below, storing the 16-bit number in (Q P)

 CLC                    \ Set A = A + HI(dashData) << 1
 ADC #HI(dashData)<<1   \
                        \ so our 16-bit number is (A 0), and we want to shift
                        \ right by one place

 LSR A                  \ Shift (A 0) right by 1, shifting bit 0 of A into the
                        \ C flag

 STA Q                  \ Set Q = A, to store the high byte of the result in Q

 LDA #0                 \ Shift the C flag into bit 7 of A, so A now contains
 ROR A                  \ the low byte of our result

 STA P                  \ Set P = A, to store the low byte of the result in P,
                        \ giving the result we wanted in (Q P)

 LDY topTrackLine       \ Set Y to the number of the top track line, so we work
                        \ down from this byte within the data block, moving down
                        \ in memory until we reach the marker
                        \
                        \ So we are working down the screen, going backwards in
                        \ memory from byte topTrackLine to the marker that we
                        \ just placed at the start of the dash data

 JMP sedg9              \ Jump into the following loop at the entry point sedg9
                        \ to draw the fill from the top byte to the bottom byte

.sedg1

                        \ This part of the loop, between segd1 and segd5, is
                        \ only used by the GetTyreDashEdgeS routine, which
                        \ modifies the loop to copy pixels instead of filling
                        \ them

 CMP #&55               \ If the current byte is &55, then this represents black
 BNE sedg2              \ (colour 0), so set A = 0 so it's the correct pixel
 LDA #0                 \ byte for the current buffer contents

.sedg2

 STA (R),Y              \ Store the pixel byte we fetched from the screen buffer
                        \ in the Y-th byte of (S R), which copies the byte from
                        \ the screen buffer into the address set up in the
                        \ CopyTyreDashEdges routine (i.e. this copies the edges
                        \ into tyreRightEdge or dashRightEdge)

.sedg3

 DEY                    \ Decrement the track line counter in Y to move down to
                        \ the next pixel line on-screen

 CPY blockOffset        \ If Y = blockOffset then we have reached the bottom of
 BEQ sedg10             \ the objec, so jump back to sedg10 to return from the
                        \ subroutine

.sedg4

 LDA (P),Y              \ Fetch the current byte from the screen buffer

.sedg5

 BNE sedg8              \ If the current byte in the screen buffer is non-zero,
                        \ then it is not empty, so jump to sedg8 to move on to
                        \ the next byte, as we only need to fill empty bytes
                        \
                        \ Gets modified by the GetTyreDashEdge routine:
                        \
                        \   * BNE sedg1 when GetTyreDashEdge is called with
                        \               Y = &EF
                        \
                        \   * BNE sedg8 when GetTyreDashEdge is called with
                        \               Y = &09


 JSR GetColourS         \ The current byte in the screen buffer is zero, which
                        \ means it should inherit the colour of the byte to the
                        \ left, so call GetColourS to work out what this byte's
                        \ colour would be on-screen, and put it into A

 BNE sedg7              \ If the result is non-zero, then jump to sedg7 to skip
                        \ the following instruction

.sedg6

 LDA #&55               \ Set A = &55, which is the value we use to represent
                        \ colour 0 (black) in the screen buffer
                        \
                        \ Gets modified by the GetTyreDashEdge routine:
                        \
                        \   * LDA #0   when GetTyreDashEdge is called with
                        \              A = 0
                        \
                        \   * LDA #&55 when GetTyreDashEdge is called with
                        \              A = &55

.sedg7

 STA (P),Y              \ Draw the resulting pixel byte into the screen buffer
                        \ by writing it to the Y-th byte of the relevant dash
                        \ data block
                        \
                        \ Gets modified by the GetTyreDashEdge routine:
                        \
                        \   * STA (R),Y when GetTyreDashEdge is called with
                        \               X = LO(R)
                        \
                        \   * STA (P),Y when GetTyreDashEdge is called with
                        \               X = LO(P)

.sedg8

 DEY                    \ Decrement the track line counter in Y to move down to
                        \ the next pixel line on-screen

.sedg9

                        \ This is the entry point for the loop, which is between
                        \ sedg4 and the loop's end logic in the next instruction

 CPY blockOffset        \ If Y <> blockOffset then we haven't reached the bottom
 BNE sedg4              \ of the object yet, so jump back to sedg4 to fill the
                        \ next byte down

.sedg10

 RTS                    \ Return from the subroutine

ENDIF

\ ******************************************************************************
\
\       Name: DrawEdge
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Draw an edge, overwriting whatever is already on-screen
\
\ ------------------------------------------------------------------------------
\
\ This routine rejoins the DrawObjectEdge routine to move on to the next edge in
\ the current object part.
\
\ Arguments:
\
\   (Q P)               The address of the dash data block to draw in
\
\   Y                   The top track line
\
\   blockOffset         The bottom track line
\
\   A                   The pixel byte for the edge
\
\ ******************************************************************************

.dred1

 STA (P),Y              \ Draw the pixel byte into the screen buffer by writing
                        \ it to the Y-th byte of the relevant dash data block

 DEY                    \ Decrement the track line counter in Y to move down to
                        \ the next pixel line on-screen

.DrawEdge

                        \ This is the entry point for the routine

 CPY blockOffset        \ If Y <> blockOffset then loop back to draw the next
 BNE dred1              \ byte, as we haven't reached the bottom track line

 JMP draw29             \ Jump to draw29

\ ******************************************************************************
\
\       Name: GetTyreDashEdges
\       Type: Subroutine
\   Category: Graphics
\    Summary: Fetch the pixel bytes from along the edge of the dashboard or tyre
\             and fill the block to the right of the edge appropriately
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the leftmost dash data block to copy
\
\   A                   The number of the dash data block after the last block
\                       to copy (so the last block to draw is A - 1)
\
\   Y                   Start at this byte in the dash data, so we work down the
\                       screen from track line Y
\
\   (S R)               The address of the table into which we copy the pixel
\                       bytes from the specified edge
\
\ ******************************************************************************

.GetTyreDashEdges

 STA temp2              \ Set temp2 = A, so in the following, the loop counter
                        \ in blockNumber loops from X to temp2 - 1 (i.e. A - 1)

.gedg1

 STX blockNumber        \ Store the loop counter in blockNumber

 STY topTrackLine       \ Set topTrackLine to the offset of the start byte

 LDA dashDataOffset,X   \ Set blockOffset = the dash data offset for block X
 STA blockOffset

 LDX #LO(R)             \ Set X so the call to GetTyreDashEdge modifies the
                        \ FillAfterObject routine to draw to (S R) instead of
                        \ (Q P)

IF _ACORNSOFT

 LDY #&DF               \ Set Y = &DF so the call to GetTyreDashEdge modifies
                        \ the FillAfterObject routine at edge11 to BNE edge1,
                        \ so the routine copies into (S R) instead of filling
                        \ the screen buffer

 LDA #0                 \ Set A = 0, so the call to GetTyreDashEdge modifies the
                        \ FillAfterObject routine to store 0 as the value for
                        \ colour 0 (instead of the &55 that the screen buffer
                        \ uses to represent black)

 JSR GetTyreDashEdge    \ Modify the FillAfterObject routine and run it to copy
                        \ the edge bytes into the table at (S R)

 LDX #LO(P)             \ Set X so the call to GetTyreDashEdge modifies the
                        \ FillAfterObject routine back to drawing to (Q P)

 LDY #&E7               \ Set Y = &E7 so the call to GetTyreDashEdge modifies
                        \ the FillAfterObject routine at edge11 back to BNE
                        \ edge3

 LDA #&55               \ Set A = &55, so the call to GetTyreDashEdge modifies
                        \ the FillAfterObject routine back to storing &55 as the
                        \ value for colour 0

 INC blockNumber        \ Increment the block number

 JSR GetTyreDashEdge    \ Modify the FillAfterObject routine back to its default
                        \ code and run it, which fills the block to the right of
                        \ the dashboard or tyre edge with the appropriate
                        \ content

ELIF _SUPERIOR

 LDY #&EF               \ Set Y = &DF so the call to GetTyreDashEdgeS modifies
                        \ the FillAfterObjectS routine at sedg5 to BNE sedg1,
                        \ so the routine copies into (S R) instead of filling
                        \ the screen buffer

 LDA #0                 \ Set A = 0, so the call to GetTyreDashEdgeS modifies
                        \ theFillObject routine to store 0 as the value for
                        \ colour 0 (instead of the &55 that the screen buffer
                        \ uses to represent black)

 JSR GetTyreDashEdgeS   \ Modify the FillAfterObjectS routine and run it to copy
                        \ the edge bytes into the table at (S R)

 LDX #LO(P)             \ Set X so the call to GetTyreDashEdgeS modifies the
                        \ FillAfterObjectS routine at back to drawing to (Q P)

 LDY #&09               \ Set Y = &09 so the call to GetTyreDashEdgeS modifies
                        \ the FillAfterObjectS routine at sedg5 back to BNE
                        \ sedg8

 LDA #&55               \ Set A = &55, so the call to GetTyreDashEdgeS modifies
                        \ the FillAfterObjectS routine back to storing &55 as
                        \ the value for colour 0

 INC blockNumber        \ Increment the block number

 JSR GetTyreDashEdgeS   \ Modify the FillAfterObjectS routine back to its
                        \ default code and run it, which fills the block to the
                        \ right of the dashboard or tyre edge with the
                        \ appropriate content

ENDIF

 LDX blockNumber        \ Fetch the loop counter from blockNumber into X

 CPX temp2              \ If X <> temp2, loop back until we have copied from
 BNE gedg1              \ block X to block temp2 - 1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CopyTyreDashEdges
\       Type: Subroutine
\   Category: Graphics
\    Summary: Fetch the pixel bytes from the right edge of the left tyre and the
\             right edge of the dashboard, and fill to the right of the edge
\
\ ------------------------------------------------------------------------------
\
\ This routine populates the tyreRightEdge and dashRightEdge tables with the
\ pixel bytes along the right edge of the left tyre and the right edge of the
\ dashboard respectively. It also fills the block to the right of the edge with
\ the appropiate content, so the feathered edges don't fill to the right.
\
\ ******************************************************************************

.CopyTyreDashEdges

 LDA #HI(tyreRightEdge) \ Set (S R) = tyreRightEdge
 STA S                  \
 LDA #LO(tyreRightEdge) \ so the call to GetTyreDashEdges copies the pixel data
 STA R                  \ from the tyre edge into the tyreRightEdge table

 LDY #27                \ Start at byte 27 in the dash data, so we work down the
                        \ screen from track line 27

 LDX #3                 \ Loop through dash data blocks 3 to 5
 LDA #6

 JSR GetTyreDashEdges   \ Fetch the pixel bytes from along the right edge of the
                        \ left tyre and fill the block to the right of the edge
                        \ with the appropriate content

 LDA #HI(dashRightEdge) \ Set (S R) = dashRightEdge
 STA S                  \
 LDA #LO(dashRightEdge) \ so the call to GetTyreDashEdges copies the pixel data
 STA R                  \ from the dashboard edge into the dashRightEdge table

 LDY #43                \ Start at byte 43 in the dash data, so we work down the
                        \ screen from track line 43

 LDX #26                \ Loop through dash data blocks 26 to 33
 LDA #34

 JSR GetTyreDashEdges   \ Fetch the pixel bytes from along the right edge of the
                        \ dashboard and fill the block to the right of the edge
                        \ with the appropriate content

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FillInsideObject
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Fill the object part from the previous edge to the current edge
\  Deep dive: Creating objects from edges
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of bash data blocks inside the object that we
\                       need to fill
\
\   blockNumber         The block number of the edge to fill up to (i.e. we fill
\                       to the left of this block number)
\
\   leftOfEdge          The pixel byte to fill the object with
\
\   topTrackLine        Top track line of the object (higher value, 0 to 79)
\
\   bottomTrackLine     Bottom track line of the object (lower value, 0 to 79)
\
\ ******************************************************************************

.FillInsideObject

 LDA leftOfEdge         \ Set A to the byte we want to fill the object with

 BNE fill1              \ If it is non-zero, jump to fill1 to skip the following
                        \ instruction

 LDA #&55               \ The fill byte is zero, i.e. colour 0 (black), so set
                        \ A = &55, which is the value we use to represent
                        \ colour 0 (black) in the screen buffer

.fill1

 STA V                  \ Store A in V, so V contains the correct fill byte for
                        \ the screen buffer

 LDA #&7F               \ Set T = &7F - topTrackLine
 SEC                    \
 SBC topTrackLine       \ We subtract this value from the start addresses for
 STA T                  \ the two dash data blocks that we are going to fill
                        \ concurrently, and add the same value to the offset
                        \ for the bottom line in VV (see the next instruction)
                        \
                        \ There must be a reason for all this shenanigans, but
                        \ it's currently eluding me

 ADC bottomTrackLine    \ Set VV = T + bottomTrackLine
 STA VV

                        \ We now calculate the start address of dash data block
                        \ blockNumber - 1, which will be at:
                        \
                        \   dashData + &80 * (blockNumber - 1)
                        \
                        \ because the dash data blocks occur every &80 bytes
                        \ from dashData
                        \
                        \ We do this using the following simplification, where
                        \ A = (blockNumber - 1)
                        \
                        \     dashData + &80 * A
                        \   = dashData + 256 / 2 * A
                        \   = HI(dashData) << 8 + LO(dashData) + A << 7
                        \
                        \ LO(dashData) happens to be zero (as dashData = &3000),
                        \ so we can keep going:
                        \
                        \   = HI(dashData) << 8 + A << 7
                        \   = (HI(dashData) << 1 + A) << 7
                        \   = ((HI(dashData) << 1 + A) << 8) >> 1
                        \
                        \ In other words, if we build a 16-bit number with the
                        \ high byte set to HI(dashData) << 1 + A, and then shift
                        \ the whole thing right by one place, we have our result
                        \
                        \ So this is the same as:
                        \
                        \   ((HI(dashData) << 1 + blockNumber - 1) << 8) >> 1
                        \
                        \ We do this below, storing the 16-bit number in (Q A)

 LDA blockNumber        \ Set A = blockNumber

 STA U                  \ Set U = blockNumber

 CLC                    \ Set A = A - 1 + HI(dashData) << 1
 ADC #HI(dashData)<<1-1 \       = blockNumber - 1 + HI(dashData) << 1
                        \
                        \ so our 16-bit number is (A 0), and we want to shift
                        \ right by one place

 LSR A                  \ Shift (A 0) right by 1, shifting bit 0 of A into the
                        \ C flag

 STA Q                  \ Set Q = A, to store the high byte of the result in Q

 STA S                  \ Set S = A, to store the high byte of the result in S

 LDA #0                 \ Shift the C flag into bit 7 of A, so A now contains
 ROR A                  \ the low byte of our result

                        \ We now have our result in (Q A), which contains the
                        \ start address of dash data block blockNumber - 1

                        \ We now subtract T, though as noted above, I'm unclear
                        \ on the reason for this (but the maths all balances out
                        \ in the end, so ler's go with it)

 SEC                    \ Set (Q P) = (Q A) - T
 SBC T                  \
 STA P                  \ We also set the C flag depending on the subtraction

 EOR #&80               \ Set (S R) = (Q P) - &80
 STA R                  \
                        \ starting with the low bytes
                        \
                        \ We can do the subtraction more efficiently by using
                        \ EOR to flip between &xx00 and &xx80, as the dash data
                        \ blocks always start at these addresses

 BPL fill2              \ We then decrement the high byte, but only if the EOR
 DEC S                  \ set the low byte to &80 rather than &00 (if we just
                        \ set it to the latter, the BPL will skip the DEC)

.fill2

 BCS fill4              \ If the subtraction above didn't underflow, jump to
                        \ fill4 to skip the next two instructions

.fill3

 DEC Q                  \ Otherwise decrement the high bytes in (Q P) and (S R)
 DEC S                  \ as the low byte subtraction underflowed

.fill4

                        \ By this point, we have:
                        \
                        \   * (Q P) points to the start address of dash data
                        \     block blockNumber - 1, minus T
                        \
                        \   * (S R) points to the start address of dash data
                        \     block blockNumber - 2, minus T
                        \
                        \ So if we fill block (Q P), we will be filling the
                        \ block to the left of the edge, and if we fill block
                        \ (S R), we will be filling the block further to the
                        \ left

                        \ We now enter a loop to fill the object, filling either
                        \ one or both of these blocks at a time

 LDY U                  \ Set Y to the block number in U, which starts out as
                        \ blockNumber and goes down by 2 on each loop iteration

 LDA fillDataOffset-1,Y \ Set A to entry Y - 1 from fillDataOffset, which gives
                        \ us the offset of the bottom line of block Y - 1,
                        \ i.e. blockNumber - 1, adjusted to ensure that filling
                        \ to the left works properly

 DEY                    \ Set U = Y - 2
 DEY                    \       = U - 2
 STY U

 CMP bottomTrackLine    \ If A < bottomTrackLine, then the bottom of the object
 BCC fill5              \ is below the bottom of the block, so jump to fill5 to
                        \ do the fill from bottomTrackLine and up

 ADC T                  \ Set Y = A + T + C
 TAY                    \       = bottom line offset + T + 1

 BPL fill6              \ If Y < &80, jump to fill6 to do the fill from track
                        \ line Y and up, so the fill will start from address:
                        \
                        \   (Q P) + Y = (Q P) + A + T + 1
                        \             = start address of (blockNumber - 1) - T
                        \               + A + T + 1
                        \             = start address of (blockNumber - 1)
                        \               + A + 1
                        \
                        \ i.e. from track line A in blockNumber - 1

                        \ If we get here then Y >= &80, which means:
                        \
                        \   A + T + C >= &80
                        \
                        \   A + &7F - topTrackLine + 1 >= &80
                        \
                        \   A - topTrackLine >= 0
                        \
                        \   A >= topTrackLine
                        \
                        \ so the bottom line offset is above the top track line,
                        \ which is why we don't do the fill for these two blocks

 CPX #2                 \ If X >= 2, jump to fill8 to move on to the next two
 BCS fill8              \ blocks to the left

 RTS                    \ Return from the subroutine

.fill5

 LDY VV                 \ Set Y = VV
                        \       = T + bottomTrackLine
                        \
                        \ so the fill will start from address:
                        \
                        \   (Q P) + Y = (Q P) + T + bottomTrackLine
                        \             = start address of (blockNumber - 1) - T
                        \               + T + bottomTrackLine
                        \             = start address of (blockNumber - 1)
                        \               + bottomTrackLine
                        \
                        \ i.e. from bottomTrackLine in blockNumber - 1

.fill6

                        \ We now do the fill, filling the relevant blocks from
                        \ offset Y up to offset &7F, so that's:
                        \
                        \   * From (Q P) + Y to (Q P) + &7F
                        \
                        \   * And from (S R) + Y to (S R) + &7F if X >= 2
                        \
                        \ In the latter case we then reduce X by 2 and loop back
                        \ to do the next two blocks

 LDA V                  \ Set A to the byte we want to fill with

 CPX #2                 \ If X < 2, jump to fill9 to fill just one block and
 BCC fill9              \ return from the subroutine

.fill7

 STA (P),Y              \ Fill the Y-th byte of (Q P) and (S R) with A
 STA (R),Y

 INY                    \ Increment Y to point to the next byte down the screen

 BPL fill7              \ Loop back until we have filled down to the &7F-th byte

.fill8

 DEX                    \ Set X = X - 2
 DEX                    \
                        \ to move left by two blocks

 BNE fill3              \ If we haven't filled all the blocks, jump to fill3 to
                        \ fill the next two blocks to the left

 RTS                    \ Return from the subroutine

.fill9

 STA (P),Y              \ Fill the Y-th byte of (Q P) with A

 INY                    \ Increment Y to point to the next byte down the screen

 BPL fill9              \ Loop back until we have filled down to the &7F-th byte

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetColour
\       Type: Subroutine
\   Category: Graphics
\    Summary: Calculate the colour of a specific pixel byte in the screen buffer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The track line number of the pixel byte to check
\
\   blockNumber         The dash data block number of the pixel byte to check
\
\ Returns:
\
\   A                   The colour of this pixel byte in the screen buffer
\
\ ******************************************************************************

IF _ACORNSOFT

.GetColour

 CPY horizonLine        \ If Y <= horizonLine then the byte we want to check is
 BCC gcol1              \ below the horizon, so jump to gcol1 to work out the
 BEQ gcol1              \ byte's colour

 LDA horizonLine        \ Set A to the track line number of the horizon

 JSR gcol17             \ Call the gcol17 subroutine below

 LDA colourPalette+1    \ Otherwise the byte is in the sky, so set A to logical
                        \ colour 1 (blue) from the colour palette

 RTS                    \ Return from the subroutine

.gcol1

 LDA #0                 \ Set T = 0
 STA T

 LDA blockNumber
 CMP leftVergeStart,Y
 ROL T
 CMP leftTrackStart,Y
 ROL T
 CMP rightVergeStart,Y
 ROL T
 CMP rightGrassStart,Y
 LDA T
 ROL A
 BNE gcol7

 LDA backgroundColour,Y
 AND #&EC
 CMP #&40
 BEQ gcol2
 CMP #&88
 BEQ gcol2
 CMP #&04
 BEQ gcol2
 LDA rightGrassStart,Y
 BPL gcol3
 BMI gcol4

.gcol2

 LDA backgroundColour,Y
 AND #&10
 BNE gcol3
 JSR gcol8
 JMP gcol4

.gcol3

 JSR gcol12

.gcol4

 LDA backgroundColour,Y
 AND #3
 TAX

 LDA colourPalette,X    \ Set A to logical colour X from the colour palette

 RTS                    \ Return from the subroutine

.gcol5

 LDA colourPalette      \ Set A to logical colour 0 from the colour palette

 RTS                    \ Return from the subroutine

.gcol6

 LDA colourPalette+3    \ Set A to logical colour 3 from the colour palette

 RTS                    \ Return from the subroutine

.gcol7

 LSR A
 BCS gcol6
 LSR A
 BCS gcol12
 LSR A
 BCS gcol5

.gcol8

 CPY L002C
 BCS gcol6
 LDX L0400,Y
 BMI gcol15
 JSR gcol16

.gcol9

 LDA (P),Y
 BNE gcol11
 LDA leftTrackStart,Y
 BMI gcol10
 CMP blockNumber
 DEY
 BCS gcol9
 INY

.gcol10

 JSR gcol18

.gcol11

 LDY V
 JMP gcol13

.gcol12

 CPY L0029
 BCS gcol6
 LDX L0450,Y
 BMI gcol15
 JSR gcol16

.gcol13

 LDA L5EE0-1,X

.gcol14

 AND #3
 TAX

 LDA colourPalette,X    \ Set A to logical colour X from the colour palette

 RTS                    \ Return from the subroutine

.gcol15

 TXA
 AND #&7F
 TAX
 BPL gcol13

.gcol16

 LDA yVergeRight,X

.gcol17

                        \ This part gets called as a subroutine by the above
                        \ with:
                        \
                        \   * A = the track line number of the horizon
                        \
                        \   * Y = the track line number of the pixel byte to
                        \         check

 STY V                  \ Set V to the track line number in Y

 TAY                    \ Set Y to the track line number in A

.gcol18

 CPY V                  \ If Y >= V, jump to gcol19 to return from the
 BCS gcol19             \ subroutine

 CPY blockOffset        \ If Y < blockOffset, jump to gcol19 to return from the
 BCC gcol19             \ subroutine

 LDA (P),Y              \ If the current byte in the screen buffer is non-zero,
 BNE gcol19             \ then it is not empty, so jump to gcol19

 LDA #&AA               \ Set the current byte to &AA ???
 STA (P),Y

.gcol19

 LDY V                  \ Set Y to the track line number of the pixel byte to
                        \ check

 RTS                    \ Return from the subroutine

ENDIF

\ ******************************************************************************
\
\       Name: GetColourS
\       Type: Subroutine
\   Category: Graphics
\    Summary: Calculate the colour of a specific pixel byte in the screen buffer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The track line number of the pixel byte to check
\
\   blockNumber         The dash data block number of the pixel byte to check
\
\ Returns:
\
\   A                   The colour of this pixel byte in the screen buffer
\
\ ******************************************************************************

IF _SUPERIOR

.GetColourS

 CPY horizonLine        \ If Y <= horizonLine then the byte we want to check is
 BCC scol1              \ below the horizon, so jump to scol1 to work out the
 BEQ scol1              \ byte's colour

 LDA colourPalette+1    \ Otherwise the byte is in the sky, so set A to logical
                        \ colour 1 (blue) from the colour palette

 RTS                    \ Return from the subroutine

.scol1

 LDA blockNumber        \ Set A to the block number containing the pixel byte
                        \ that we want to check

 CMP rightGrassStart,Y  \ If A >= rightGrassStart for this track line, then the
 BCS scol3              \ pixel byte is in the grass to the right of the track,
                        \ so jump to scol3 to return colour 3 (green)

 CMP rightVergeStart,Y  \ If A >= rightVergeStart for this track line, then the
 BCS scol5              \ pixel byte is on the right track verge, so jump to
                        \ scol5 to work out its colour

 CMP leftTrackStart,Y   \ If A >= leftTrackStart for this track line, then the
 BCS scol2              \ pixel byte is on the track, so jump to scol2 to return
                        \ colour 0 (black)

 CMP leftVergeStart,Y   \ If A >= leftVergeStart for this track line, then the
 BCS scol4              \ pixel byte is on the left track verge, so jump to
                        \ scol4 to work out its colour

 LDA backgroundColour,Y \ If we get here then the byte is to the left of the
                        \ left track verge, so set A to the background colour of
                        \ this track line

 BCC scol7              \ Jump to scol7 to return the pixel byte for the colour
                        \ in A (this BCC is effectively a JMP as we just passed
                        \ throuhg a BCS)

.scol2

 LDA colourPalette      \ Set A to logical colour 0 (black) from the colour
                        \ palette

 RTS                    \ Return from the subroutine

.scol3

 LDA colourPalette+3    \ Set A to logical colour 3 (green) from the colour
                        \ palette

 RTS                    \ Return from the subroutine

.scol4

                        \ If we get here then the pixel byte is on the left
                        \ track verge

 CPY L002C              \ If the track line in Y >= L002C, jump to scol3 to
 BCS scol3              \ return colour 3 (green)

 LDA L0400,Y            \ Set A to the L0400 entry for this track line

 JMP scol6              \ Jump to scol6

.scol5

                        \ If we get here then the pixel byte is on the right
                        \ track verge

 CPY L0029              \ If the track line in Y >= L0029, jump to scol3 to
 BCS scol3              \ return colour 3 (green)

 LDA L0450,Y            \ Set A to the L0450 entry for this track line

.scol6

 AND #%01111111         \ Set X to bits 0-6 of A
 TAX

 LDA L5EE0-1,X          \ Set A to entry X - 1 from L5EE0

.scol7

 AND #%00000011         \ Set X to bits 0-1 of A
 TAX

 LDA colourPalette,X    \ Set A to logical colour X from the colour palette

 RTS                    \ Return from the subroutine

ENDIF

\ ******************************************************************************
\
\       Name: AssistSteering
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Apply Computer Assisted Steering (CAS) when configured
\
\ ------------------------------------------------------------------------------
\
\ This routine applies Computer Assisted Steering (CAS) to the joystick and
\ keyboard, but only if it is enabled and we are already steering (if we are not
\ steering, then there is no steering to assist).
\
\ Jumps back to:
\
\   * keys11 (joystick, CAS not enabled)
\
\   * keys7 (joystick, CAS enabled, joystick is hardly steering)
\
\   * keys10 (keyboard, or joystick with CAS applied)
\
\ Arguments:
\
\   (U T)               The amount of steering currently being applied by the
\                       steering wheel:
\
\                         * For joystick, contains the scaled joystick
\                           x-coordinate as a sign-magnitude number with the
\                           sign in bit 0 (1 = left, 0 = right)
\
\                         * For keyboard, contains a signed 16-bit number,
\                           negative if bit 0 of steeringLo is set (left),
\                           positive if bit 0 of steeringLo is clear (right)
\
\   (A T)               Same as (U T)
\
\   V                   For keyboard only:
\
\                         * V = 1 if ";" is being pressed (steer right)
\
\                         * V = 2 if "L" is being pressed (steer left)
\
\                         * V = 0 if neither is being pressed
\
\ Returns:
\
\   A                   A is set to steeringLo
\
\   (U T)               The new amount of steering to apply, adjusted to add
\                       steering assistance, as a sign-magnitude number
\
\ Other entry points:
\
\   AssistSteeringKeys  For keyboard-controlled steering
\
\ ******************************************************************************

IF _SUPERIOR

.AssistSteering

 JSR GetSteeringAssist  \ Set X = configAssist, set the C flag to bit 7 of
                        \ directionFacing, and update the Computer Assisted
                        \ Steering (CAS) indicator on the dashboard

 BNE asst2              \ If CAS is enabled, jump to asst2 to skip the following
                        \ instruction and apply CAS, otherwise we jump to keys11
                        \ to return to the ProcessDrivingKeys routine

.asst1

 JMP keys11             \ Return to the ProcessDrivingKeys routine at keys11

.asst2

 BCS asst1              \ If bit 7 of directionFacing is set, then our car is
                        \ facing backwards, so jump to asst1 to jump to keys11
                        \ in the ProcessDrivingKeys routine, as CAS only works
                        \ when driving forwards

 CMP #5                 \ If A >= 5, then the joystick is currently applying
 BCS asst4              \ some steering, so jump to asst4 to continue applying
                        \ CAS

                        \ Otherwise the joystick is not being used for steering
                        \ at the moment, so there is no steering to assist and
                        \ we don't apply CAS

 JMP keys7              \ Return to the ProcessDrivingKeys routine at keys7 to
                        \ apply no joystick steering

.AssistSteeringKeys

 JSR GetSteeringAssist  \ Set X = configAssist, set the C flag to bit 7 of
                        \ directionFacing, and update the CAS indicator on the
                        \ dashboard

 BEQ asst3              \ If CAS is not enabled, jump to asst3 to set A and jump
                        \ to keys10 in the ProcessDrivingKeys routine

 BCS asst3              \ If bit 7 of directionFacing is set, then our car is
                        \ facing backwards, so jump to asst3 to jump to keys10
                        \ in the ProcessDrivingKeys routine, as CAS only works
                        \ when driving forwards

 LDA V                  \ Set A = V

 BNE asst5              \ If A is non-zero, then one of the steering keys is
                        \ being held down, so jump to asst5 to continue applying
                        \ CAS

                        \ Otherwise the keyboard is not being used for steering
                        \ at the moment, so there is no steering to assist and
                        \ we don't apply CAS

.asst3

 JMP asst13             \ Jump to asst13 to set A to steeringLo and return to
                        \ the ProcessDrivingKeys routine at keys210

.asst4

                        \ If we get here then the joystick is being used for
                        \ steering, and (A T) contains the scaled joystick
                        \ x-coordinate as a sign-magnitude number with the
                        \ sign in bit 0 (1 = left, 0 = right)

 LDA T                  \ Set the C flag to the inverse of the joystick
 EOR #1                 \ x-coordinate's sign bit from bit 0 (i.e. 0 = left,
 LSR A                  \ 1 = right)

 LDA #3                 \ Set A to 3 (if the C flag is set, i.e. right) or 2 (if
 SBC #0                 \ the C flag is clear, i.e. left)

.asst5

                        \ If we get here, then either the joystick or keyboard
                        \ is being used for steering, and we have the following:
                        \
                        \   * A = 2 if we are steering left
                        \
                        \ We now spend the rest of the routine calculating the
                        \ amount of assisted steering to apply, returning the
                        \ result in the sign-magnitude number (U T)

 LDX #50                \ Set X = 50 to use as the value for steering left

 CMP #2                 \ If A = 2 then we are steering left, so jump to asst6
 BEQ asst6              \ to skip the following instruction

 LDX #10                \ Set X = 10 to use as the value for steering right

.asst6

                        \ We now set the following if we are steering right:
                        \
                        \   (W V) = (steeringHi steeringLo) + 256
                        \
                        \ or the following if we are steering left:
                        \
                        \   (W V) = (steeringHi steeringLo) - 256
                        \
                        \ by first converting (steeringHi steeringLo) from a
                        \ sign-magnitude number to a signed 16-bit number and
                        \ then doing the addition or subtraction

 LDA steeringLo         \ Set V = steeringLo
 STA V

 LSR A                  \ Set the C flag to the sign of steeringLo

 LDA steeringHi         \ Set A = steeringHi
                        \
                        \ So (A V) = (steeringHi steeringLo)

 BCC asst7              \ If the C flag is clear then (steeringHi steeringLo) is
                        \ positive, so jump to asst7 as (A V) already has the
                        \ correct sign

                        \ Otherwise (steeringHi steeringLo) is negative, so we
                        \ need to negate (A V)

 LDA #0                 \ Set (A V) = 0 - (A V)
 SEC                    \
 SBC V                  \ starting with the low bytes
 STA V

 LDA #0                 \ And then the high bytes
 SBC steeringHi

.asst7

 CLC                    \ Set (A V) = (A V) + 256
 ADC #1                 \           = (steeringHi steeringLo) + 256

 CPX #50                \ If X <> 50, then we are steering right, so jump to
 BNE asst8              \ asst8

 SBC #2                 \ X = 50, so we are steering left, so set:
                        \
                        \   (A V) = (A V) - 2 * 256
                        \         = (steeringHi steeringLo) + 256 - 2 * 256
                        \         = (steeringHi steeringLo) - 256

.asst8

 STA W                  \ Set (W V) = (A V)
                        \
                        \ So if we are steering right, we have:
                        \
                        \   (W V) = (steeringHi steeringLo) + 256
                        \
                        \ and if we are steering left we have:
                        \
                        \   (W V) = (steeringHi steeringLo) - 256

 LDA var24Lo,X          \ Set (A T) = X-th (var24Hi var24Lo) - (W V)
 SEC                    \
 SBC V                  \ starting with the low bytes
 STA T

 LDA var24Hi,X          \ And then the high bytes
 SBC W

 PHP                    \ Store the sign flag for X-th var24 - (W V) on the
                        \ stack, so we can retrieve it below

 JSR Absolute16Bit      \ Set (A T) = |A T|
                        \           = |X-th var24 - (W V)|

 STA V                  \ Set (V T) = (A T)
                        \           = |X-th var24 - (W V)|

 LDY segmentIndex96     \ Set Y to segmentIndex - 96

 LDA #60                \ Set A = 60 - speedHi
 SEC
 SBC speedHi

 BPL asst9              \ If the result is positive, jump to asst9 to skip the
                        \ following instruction

 LDA #0                 \ Set A = 0, so A is always positive, and is zero if we
                        \ are currently doing more than 60

.asst9

 ASL A                  \ Set U = A * 2 + 32
 ADC #32                \       = 32 + (60 - speedHi) * 2
 STA U                  \
                        \ So U is 32 if we are doing more than 60, and higher
                        \ with lower speeds

 LDA segmentSteering,Y  \ Fetch the carSteering value to steer round the corner
                        \ for track segment segmentIndex96

 AND #%01111111         \ Zero the driving direction in bit 7

 CMP #64                \ If A < 64, jump to asst10 to skip the following
 BCC asst10             \ instruction

 LDA #2                 \ A >= 64, i.e. bit 6 is set, so set A = 2

.asst10

 CMP #8                 \ If A < 8, jump to asst11 to skip the following
 BCC asst11             \ instruction

 LDA #7                 \ A >= 8, so set A = 7

.asst11

                        \ By now A is between 0 and 7, and is set to 2 if bit 6
                        \ of segmentSteering was set

 ASL A                  \ Set A = A * 16
 ASL A                  \
 ASL A                  \ So A is in the range 0 to 112
 ASL A

 CMP U                  \ If A < U, jump to asst12 to skip the following
 BCC asst12             \ instruction

 STA U                  \ A >= U, so set U = A, i.e. set U = max(U, A)

.asst12

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256
                        \           = U * |X-th var24 - (W V)| / 256

 LDA U                  \ Set (A T) = (U T)
                        \           = U * |X-th var24 - (W V)| / 256

 PLP                    \ Retrieve the sign of the X-th var24 - (W V)
                        \ calculation that we stored above

 JSR Absolute16Bit      \ Set the sign of (A T) to that of X-th var24 - (W V),
                        \ so we now have:
                        \
                        \   (A T) = U * (X-th var24 - (W V)) / 256

 STA U                  \ Set (U T) = (A T)
                        \           = U * (X-th var24 - (W V)) / 256

 LDA T                  \ Clear bit 0 of (U T)
 AND #%11111110
 STA T

 LDA steeringLo         \ Set the C flag to the sign in bit 0 of steeringLo
 LSR A

 BCS asst13             \ If the C flag is set, jump to asst13 to skip the
                        \ following instruction

 JSR Negate16Bit+2      \ Set (A T) = -(U T)

 STA U                  \ Set (U T) = (A T)
                        \           = -(U T)

.asst13

 LDA steeringLo         \ Set A = steeringLo to return from the subroutine

 JMP keys10             \ Return to the ProcessDrivingKeys routine at keys10

ENDIF

\ ******************************************************************************
\
\       Name: SetSteeringLimit
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Apply a maximum limit to the amount of steering
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   C flag              The result of CMP steeringHi
\
\ Returns:
\
\   (A T)               A is set to |steeringHi steeringLo|
\
\ ******************************************************************************

IF _SUPERIOR

.SetSteeringLimit

 BCC slim1              \ Before calling this routine, we did a CMP steeringHi,
                        \ so if A < steeringHi, jump to slim1 to return from
                        \ the subroutine

 LDA steeringLo         \ Set T = steeringLo with bit 0 cleared
 AND #%11111110
 STA T

 LDA steeringHi         \ Set A = steeringHi, so (A T) = (steeringHi steeringLo)
                        \ with the sign bit in bit 0 cleared

.slim1

 RTS                    \ Return from the subroutine

ENDIF

\ ******************************************************************************
\
\       Name: sub_C1FA8
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

IF _SUPERIOR

.sub_C1FA8

 BCC C1FAF
 LDA objSectionCount,X
 CMP #3

.C1FAF

 ROR L62FB
 RTS

 NOP

ENDIF

\ ******************************************************************************
\
\       Name: DrawObject
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Draw an object of a specific type
\
\ ------------------------------------------------------------------------------
\
\ This routine is used to draw objects such as road signs, corner markers and
\ cars.
\
\ Arguments:
\
\   objectType          The type of object to draw (0 to 12)
\
\   scaleUp             The scale factor for this object (i.e. its size)
\
\   colourPalette       The colour palette to use for drawing the object
\
\   X                   Driver number:
\
\                         * 0-19 = map logical colour 1 according to the driver
\                                  number in X:
\
\                           * Drivers 0, 4,  8, 12, 16 map to colour 0 (black)
\
\                           * Drivers 1, 5,  9, 13, 17 map to colour 1 (red)
\
\                           * Drivers 2, 6, 10, 14, 18 map to colour 2 (white)
\
\                           * Drivers 2, 7, 11, 15, 19 map to colour 3 (green)
\
\                         * 20-22 = this is the four-object car, which is the
\                                   closest car in front of us, so map logical
\                                   colour 1 according to the number of the
\                                   driver in front of us (using the same logic
\                                   as above)
\
\                         * 23 = stick with the palette in colourPalette
\
\ Returns:
\
\   colourPalette       Gets reset back to the default palette
\
\ ******************************************************************************

.DrawObject

 STX T                  \ Store the driver number in T

                        \ We start by copying the four bytes from the standard
                        \ colour palette in colourPalette to the object colour
                        \ palette in objectPalette, as we use the latter to draw
                        \ the object

 LDX #3                 \ Set up a counter in X for copying the four palette
                        \ bytes

.dobj1

 LDA colourPalette,X    \ Copy the X-th byte of colourPalette to the X-th byte
 STA objectPalette,X    \ of objectPalette

 DEX                    \ Decrement the loop counter

 BPL dobj1              \ Loop back until we have copied all four bytes

 LDA #%11110000         \ Map logical colour 2 in the colour palette to physical
 STA colourPalette+2    \ colour 1 (white in the track view), which sets it back
                        \ to the default value
                        \
                        \ This only has an effect when we call DrawObject from
                        \ DrawCornerMarkers, which changes the value of colour 2
                        \ in colourPalette (all other calls to DrawObject leave
                        \ the colour palette alone)

                        \ We now set the palette differently, depending on the
                        \ driver number in A:
                        \
                        \   * 0-19 = map logical colour 1 to physical colour
                        \            A mod 4
                        \
                        \   * 20-22 = map logical colour 1 to physical colour
                        \             (number of the driver in front) mod 4
                        \
                        \   * 23 = don't change the palette, i.e use the palette
                        \          from colourPalette

 LDA T                  \ Set A = T, so A contains the driver number

 CMP #23                \ If A = 23, jump to dobj3 to skip the following palette
 BEQ dobj3              \ changes

 CMP #20                \ If A < 20, jump to dobj2 to map logical colour 1 to
 BCC dobj2              \ physical colour A mod 4, in other words:
                        \
                        \   * Drivers 0, 4,  8, 12, 16 map to colour 0 (black)
                        \   * Drivers 1, 5,  9, 13, 17 map to colour 1 (red)
                        \   * Drivers 2, 6, 10, 14, 18 map to colour 2 (white)
                        \   * Drivers 2, 7, 11, 15, 19 map to colour 3 (green)

                        \ If we get here then A is 20, 21 or 22, which is the
                        \ four-object car, so we map logical colour 1 to the
                        \ number of the driver in front of us, mod 4

 LDX positionAhead      \ Set X to the position of the driver in front of us

 LDA driversInOrder,X   \ Set A the number of the driver in front of us, so we
                        \ map logical colour 1 to physical colour A mod 4

.dobj2

 AND #3                 \ Set X = A mod 4
 TAX

 LDA colourPalette,X    \ Map logical colour 1 in the object palette to logical
 STA objectPalette+1    \ colour X from the colour palette

.dobj3

 LDX #0                 \ Set scaleDown = 0, so the object's scaffold is not
 STX scaleDown          \ scaled down (as 2^scaleDown = 2^0 = 1)

 LDA scaleUp            \ Set A = scaleUp

 CMP L62FC              \ If A >= L62FC, jump to dobj4 to skip the following
 BCS dobj4              \ instruction and set lowestTrackLine to 0 (so the whole
                        \ object is drawn)

 LDX horizonLine        \ Set X to the track line number of the horizon, so the
                        \ parts of the object below this line do not get drawn

.dobj4

 STX lowestTrackLine    \ Set lowestTrackLine = X, so the object gets cut off at
                        \ the horizon line when scaleUp < L62FC

 CMP #64                \ If A >= 64, i.e. scaleUp >= 64, jump to dobj5 to skip
 BCS dobj5              \ the following

                        \ Otherwise we can alter the values of scaleUp and
                        \ scaleDown to be more accurate but without fear of
                        \ overflow, by multiplying both scale factors by 4
                        \ (as we know 4 * scaleUp is < 256)

 ASL A                  \ Set scaleUp = A * 4
 ASL A                  \             = scaleUp * 4
 STA scaleUp

 LDA #2                 \ Set scaleDown = 2, so the object's scaffold is scaled
 STA scaleDown          \ down by 2^scaleDown = 2^2 = 4
                        \
                        \ So the overall scaling of the scaffold is the same,
                        \ but we retain more accuracy

.dobj5

 LDX objectType         \ Set X to the type of object we're going to draw

                        \ If the object type is 10, 11 or 12, then it's one of
                        \ the turn signs (chicane, left or right turn), so we
                        \ draw this as two objects, starting with a blank white
                        \ sign (object type 9) and then the sign contents
                        \ (object 10, 11 or 12)
                        \
                        \ We only draw the sign contents if our car is facing
                        \ forwards, so the back of the sign is blank

 CPX #10                \ If X < 10, jump to dobj6 to skip the following
 BCC dobj6              \ instruction

 LDX #9                 \ Set X = 9, so we first draw an object of type 9 for
                        \ the blank white sign, before drawing another object of
                        \ type objectType

.dobj6

 STX thisObjectType     \ Store X in thisObjectType, so we can check it again
                        \ below in case we need to draw two objects

 LDA scaffoldIndex,X    \ Set QQ to the index of the first scaffold entry in
 STA QQ                 \ objectScaffold for object type X

 LDA scaffoldIndex+1,X  \ Set II to the index of the first scaffold entry in
 STA II                 \ objectScaffold for object type X + 1 (so the last
                        \ entry for object type X will be index II - 1)

 LDA objectIndex,X      \ Set QQ to the index of the first entry in the object
 STA MM                 \ data tables for object type X (so MM will point to the
                        \ first entry for this object in the objectTop,
                        \ objectBottom, objectLeft, objectRight and objectColour
                        \ tables)

 JSR ScaleObject        \ Scale the object's scaffold by the scaleUp and
                        \ scaleDown factors, storing the results in the
                        \ scaledScaffold table

 BCS dobj7              \ If the call to ScaleObject set the C flag then the
                        \ scaling process overflowed, in which case we do not
                        \ draw the object, so jump to dobj7 to return from the
                        \ subroutine

 JSR DrawObjectEdges    \ Draw the scaled object in the screen buffer by drawing
                        \ all the object's edges

 LDX objectType         \ Set X to the type of object we are drawing, in case we
                        \ need to draw a second object

 LDA thisObjectType     \ If the object we just drew is not an object of type 9,
 CMP #9                 \ then this is not a two-part road sign object, so jump
 BNE dobj7              \ to dobj7 to return from the subroutine

                        \ Otherwise we just drew an object of type 9, for the
                        \ blank white sign, so now we draw a second object for
                        \ the sign's contents, but only if our car is facing
                        \ forwards (if we are facing backwards, then we see the
                        \ back of the sign, which is blank)

 LDA directionFacing    \ If bit 7 of directionFacing is clear, then our car is
 BPL dobj6              \ facing fowards, so loop back to draw the contents of
                        \ the sign in object type objectType

.dobj7

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ScaleObject
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Scale an object's scaffold by the scale factors in scaleUp and
\             scaleDown
\  Deep dive: Scaling objects with scaffolds
\
\ ------------------------------------------------------------------------------
\
\ This routine is used when drawing objects such as road signs, corner markers
\ and cars.
\
\ It takes the values from the objectScaffold table, which contain an object's
\ scaffold (i.e. all the essential measurements that we need to build the
\ object), and scales them according to the values of scaleUp and scaleDown.
\
\ As only scaffold measurements are used when drawing an object, this routine
\ scales the whole object, according to the two scale factors.
\
\ The value in scaleUp is the numerator of the scale factor, which scales the
\ scaffold up, so bigger values of scaleUp give bigger objects.
\
\ The value in scaleDown is the denominator of the scale factor, which scales
\ the scaffold down, so bigger values of scaleDown give smaller objects.
\
\ Arguments:
\
\   QQ                  Index of the first objectScaffold entry for this object
\
\   II                  Index of the last objectScaffold entry for this object
\                       (where the last entry is index II - 1)
\
\   scaleUp             Numerator scale factor
\
\   scaleDown           Denominator scale factor
\
\ Returns:
\
\   C flag              Denotes whether the scaling was successful:
\
\                         * Clear if we manage to scale the scaffold
\
\                         * Set if the scaling of any individual scaffold
\                           measurements overflows, in which case we do not draw
\                           the object
\
\   scaledScaffold      The scaled scaffold
\
\   scaledScaffold+8    The scaled scaffold, with each measurement negated
\
\ ******************************************************************************

.ScaleObject

 LDA scaleUp            \ Set scaleRange = scaleUp
 STA scaleRange

 LSR A                  \ Set scaleRange+1 = scaleUp >> 1
 STA scaleRange+1       \                  = scaleUp / 2

 LSR A                  \ Set scaleRange+2 = scaleUp >> 2
 STA scaleRange+2       \                  = scaleUp / 4

 LSR A                  \ Set scaleRange+3 = scaleUp >> 3
 STA scaleRange+3       \                  = scaleUp / 8

 LSR A                  \ Set scaleRange+4 = scaleUp >> 4
 STA scaleRange+4       \                  = scaleUp / 16

 LSR A                  \ Set scaleRange+5 = scaleUp >> 5
 STA scaleRange+5       \                  = scaleUp / 32

                        \ So scaleRange + n contains scaleUp / 2^n

 LDY QQ                 \ We now loop through the objectScaffold table from
                        \ entry QQ to entry II - 1, so set a loop counter in Y
                        \ to act as an index

 LDX #0                 \ Set W = 0, to be used as an index as we populate the
 STX W                  \ scaledScaffold table, incrementing by one byte for
                        \ each loop

.prep1

 LDA objectScaffold,Y   \ Set A to the Y-th scaffold measurement

 BPL prep2              \ If bit 7 of A is clear, jump to prep2 to do the
                        \ calculation that only uses bits 0-2 of A

                        \ If we get here, bit 7 of A is set, so now we do the
                        \ following calculation, where the value of A from the
                        \ objectScaffold table is %1abbbccc:
                        \
                        \   A = a * scaleUp/2 + scaleUp/2^b-2 + scaleUp/2^c-2
                        \       ---------------------------------------------
                        \                       2^scaleDown
                        \
                        \     = scaleUp * (a/2 + 1/2^b-2 + 1/2^c-2)
                        \       -----------------------------------
                        \                    2^scaleDown
                        \
                        \         scaleUp
                        \     = ----------- * (a/2 + 1/2^b-2 + 1/2^c-2)
                        \       2^scaleDown
                        \
                        \         scaleUp
                        \     = ----------- * scaffold
                        \       2^scaleDown
                        \
                        \ We then store this as the next entry in scaledScaffold
                        \
                        \ Note that b and c are always in the range 3 to 7, so
                        \ they look up the values we stored in scaleRange above

 AND #%00000111         \ Set X = bits 0-2 of A
 TAX                    \       = %ccc
                        \       = c

 LDA scaleRange-2,X     \ Set T = entry X-2 in scaleRange
 STA T                  \       = scaleUp / 2^X-2
                        \       = scaleUp / 2^c-2

 LDA objectScaffold,Y   \ Set A to the Y-th scaffold measurement
 STA U

 LSR A                  \ Set X = bits 3-5 of A
 LSR A                  \       = %bbb
 LSR A                  \       = b
 AND #%00000111
 TAX

 LDA scaleRange-2,X     \ Set A = entry X-2 in scaleRange + T
 CLC                    \       = scaleUp / 2^X-2 + scaleUp / 2^c-2
 ADC T                  \       = scaleUp / 2^b-2 + scaleUp / 2^c-2

 BIT U                  \ If bit 6 of U is clear, jump to prep3
 BVC prep3

 CLC                    \ If bit 6 of U is set:
 ADC scaleRange+1       \
                        \   A = A + scaleRange+1
                        \     = A + scaleUp / 2

 JMP prep3              \ Jump to prep3

.prep2

                        \ If we get here, bit 7 of the Y-th objectScaffold is
                        \ clear, so we do the following calculation, where
                        \ A is %00000ccc:
                        \
                        \   A = scaleUp / 2^c-2
                        \       ---------------
                        \         2^scaleDown
                        \
                        \     = scaleUp * 1/2^c-2
                        \       -----------------
                        \          2^scaleDown
                        \
                        \     =   scaleUp
                        \       ----------- * 1/2^c-2
                        \       2^scaleDown
                        \
                        \         scaleUp
                        \     = ----------- * scaffold
                        \       2^scaleDown
                        \
                        \ We then store this as the next entry in scaledScaffold

 TAX                    \ Set A = entry c-2 in scaleRange
 LDA scaleRange-2,X     \       = scaleUp / 2^c-2

.prep3

 LDX scaleDown          \ If scaleDown = 0 then the scale factor is 2^scaleDown
 BEQ prep5              \ = 2^0 = 1, so jump to prep5 to skip the division

                        \ We now shift A right by X places, which is the same as
                        \ dividing by 2^X = 2^scaleDown

.prep4

 LSR A                  \ Set A = A >> 1

 DEX                    \ Decrement the shift counter

 BNE prep4              \ Loop back until we have shifted A right by X places,
                        \ and the C flag contains the last bit shifted out from
                        \ bit 0 of A

 ADC #0                 \ Set A = A + C to round the result of the division to
                        \ the nearest integer

.prep5

 LDX W                  \ Set X to W, the index into the tables we are building

 STA scaledScaffold,X   \ Store A in the X-th byte of scaledScaffold

 EOR #&FF               \ Set A = ~A

 BPL prep6              \ If bit 7 of A is clear, i.e. it was set before the
                        \ EOR, then the result of the scaling was >= 128, which
                        \ is an overflow of the scaling
                        \
                        \ If the scaling overflows, then the object is too big
                        \ to be drawn, so we jump to prep6 to return from the
                        \ subroutine with the C flag set, so we do not draw this
                        \ object and ignore all the values calculated here

 CLC                    \ Store -A in the X-th byte of scaledScaffold+8
 ADC #1
 STA scaledScaffold+8,X

 INC W                  \ Increment the index counter

 INY                    \ Increment the loop counter

 CPY II                 \ Loop back until Y has looped through QQ to II - 1
 BNE prep1

 CLC                    \ Clear the C flag to indicate a successful scaling

 RTS                    \ Return from the subroutine

.prep6

 SEC                    \ Set the C flag to indicate that scaling overflowed and
                        \ the object should not be drawn

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawObjectEdges
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Draw all the parts of an object by drawing edges into the screen
\             buffer
\  Deep dive: Creating objects from edges
\
\ ------------------------------------------------------------------------------
\
\ This routine is used to draw road signs, corner markers and cars. They are
\ drawn as edges - specifically the left and right edges - into the screen
\ buffer in the dash data blocks.
\
\ Arguments:
\
\   MM                  The index of the first entry in the object data tables
\                       for this this object (i.e. the index of the data for the
\                       object's first part)
\
\   xCoord              The pixel x-coordinate of the centre of the object
\
\   yCoord              The object's y-coordinate (for the centre of the object)
\                       in terms of track lines, so 80 is the top of the track
\                       view and 0 is the bottom of the track view
\
\   lowestTrackLine     Hide any part of the object that's below the specified
\                       track line (typically used to stop an object from being
\                       drawn below the horizon)
\
\                         * 0 = draw the whole object
\
\                         * Non-zero = only draw the part of the object that's
\                                      above this track line
\
\ ******************************************************************************

.DrawObjectEdges

 LDY MM                 \ Set Y to the index of this object data in the object
                        \ data tables

                        \ We now work our way through the data for this object,
                        \ drawing one part at a time, using thisObjectIndex and
                        \ Y as the loop counter as we loop through each part
                        \
                        \ Note that most object parts are defined by one set of
                        \ object data, so they correspond to two edges (left and
                        \ right), but object types 2 and 4 contain four-edge
                        \ object parts, which are defined by two sets of data,
                        \ and therefore two loop iterations

.drob1

 LDA colourPalette      \ Set rightOfEdge to logical colour 0 in the standard
 STA rightOfEdge        \ colour palette, so the fill colour to the left of the
                        \ first edge is set to a default of black when we call
                        \ DrawObjectEdge below

 LDA #0                 \ Set prevEdgeInByte = 0 to indicate that the first edge
 STA prevEdgeInByte     \ is not sharing a pixel byte with the previous edge (as
                        \ there isn't a previous edge)

 STA edgePixelMask      \ Set edgePixelMask = 0 to pass to DrawObjectEdge below
                        \ as there is no previous edge, so there should be no
                        \ mask for the previous edge in the same pixel byte

 LDX objectTop,Y        \ Set A to the scaled scaffold for the top of this part
 LDA scaledScaffold,X   \ of the object

 CLC                    \ Set A = A + yCoord
 ADC yCoord             \
                        \ so A is now the track line of the top of the object

 BMI drob9              \ If A > 128, then the top of this object part is well
                        \ above the track view, so jump to drob9 to move on to
                        \ the next object part as this one doesn't fit on-screen

 CMP #80                \ If A >= 80, set A = 79, as the maximum track line at
 BCC drob2              \ the very top of the track view is 79
 LDA #79

.drob2

 STA topTrackLine       \ Store A in N as the number of the top track line, to
                        \ send to DrawObjectEdge below

 LDX objectBottom,Y     \ Set A to the scaled scaffold for the bottom of this
 LDA scaledScaffold,X   \ part of the object

 CLC                    \ Set A = A + yCoord
 ADC yCoord             \
                        \ so A is now the track line of the bottom of the object

 BMI drob3              \ If A < 0, then the bottom of this object part is lower
                        \ than the bottom of the track view, so jump to drob3 to
                        \ set A = lowestTrackLine, so we only draw the object
                        \ down to the lowest line allowed

 CMP lowestTrackLine    \ If A >= lowestTrackLine, jump to drob4 to skip the
 BCS drob4              \ following

.drob3

                        \ If we get here then either the bottom track line in A
                        \ is negative or A < lowestTrackLine, both of which are
                        \ below the lowest level that we want to draw, so we
                        \ cut off the bottom of the object to fit

 LDA lowestTrackLine    \ Set A = lowestTrackLine, so the minimum track line
                        \ number is set to lowestTrackLine and we only draw the
                        \ objectdown to the lowest line allowed

 NOP                    \ These instructions have no effect - presumably they
 NOP                    \ are left over from changes during development

.drob4

 CMP topTrackLine       \ If A >= N, then the bottom track line for this object
 BCS drob9              \ in A is higher than the top track line in N, so jump
                        \ to drob9 to move on to the next object part as there
                        \ is nothing to draw for this part

                        \ We now set up the parameters to pass to DrawObjectEdge
                        \ below, to draw the left and right edges

 STA bottomTrackLine    \ Set bottomTrackLine = A as the bottom track line

 LDX objectLeft,Y       \ Set thisEdge to the scaled scaffold for the left edge
 LDA scaledScaffold,X   \ of this part of the object, to pass to DrawObjectEdge
 STA thisEdge

 LDX objectRight,Y      \ Set nextEdge to the scaled scaffold for the right
 LDA scaledScaffold,X   \ edge of this part of the object, to pass to
 STA nextEdge           \ DrawObjectEdge

 LDA objectColour,Y     \ Set A to the colour data for this object part

 STA colourData         \ Set colourData to the colour data for this object part

 STY thisObjectIndex    \ Store the current index into the object data in
                        \ thisObjectIndex

 LDY #1                 \ Draw the left edge of this object part
 JSR DrawObjectEdge

.drob5

 BIT colourData         \ If bit 7 is set in the colour data for this object
 BMI drob10             \ part, then this is a four-edge object part, so
                        \ jump to drob10 to draw the extra two edges before
                        \ returning here (with bit 7 of colourData clear) to
                        \ draw the fourth edge

 LDA #0                 \ Set A = 0 to send to DrawObjectEdge as the fill colour
                        \ to the right, as there is no fill to the right of the
                        \ object

 LDY #2                 \ Draw the right edge of this object part
 JSR DrawObjectEdge

 BIT colourData         \ If bit 6 is set in the colour data for this object
 BVS drob7              \ part, then this indicates that this is the last part
                        \ of this object, so jump to drob7 to return from the
                        \ subroutine as we have now drawn the whole object

 LDY thisObjectIndex    \ Otherwise we need to move on to the next part, so set
                        \ Y to the loop counter

.drob6

 INY                    \ Increment the loop counter to point to the data for
                        \ the next object part

 JMP drob1              \ Loop back to drob1 to process the next object part

.drob7

 RTS                    \ Return from the subroutine

.drob8

                        \ We get here when we come across data that forms the
                        \ second and third stages of a four-edge object part,
                        \ so we now need to skip that data as we have already
                        \ processed it

 AND #%01000000         \ If bit 6 of A is set, i.e. 64 + x, jump to drob7 to
 BNE drob7              \ return from the subroutine, as we have just drawn the
                        \ last part of the object we wanted to draw

 INY                    \ Increment the loop counter to point to the data for
                        \ the next object part

.drob9

 LDA objectColour,Y     \ Set A to the colour data for this object part

 BMI drob8              \ If bit 7 of A is set, i.e. 128 + x, jump to drob8 to
                        \ skip this bit of data and move on to the next, as this
                        \ contains the data for the second and third edges of a
                        \ four-edge object part, and this will already have
                        \ been processed in drob10

 AND #%01000000         \ If bit 6 of A is set, i.e. 64 + x, jump to drob7 to
 BNE drob7              \ return from the subroutine, as we have just drawn the
                        \ last part of the object we wanted to draw

 BEQ drob6              \ Jump to drob6 to move on to the next object part (this
                        \ BEQ is effectively a JMP as we just passed through a
                        \ BNE)

.drob10

                        \ If we get here then the colour data for this object
                        \ part has bit 7 set, so this is a four-edge object
                        \ part and we need to draw the second and third edges
                        \
                        \ The second and third edges are defined in the next bit
                        \ of object data, as follows:
                        \
                        \   * Second edge: nextEdge   = objectLeft
                        \                  colourData = objectRight
                        \
                        \   * Third edge:  nextEdge   = objectTop
                        \                  colourData = objectColour

 LDY thisObjectIndex    \ Set Y to the loop counter

 INY                    \ Increment the loop counter to point to the next bit of
 STY thisObjectIndex    \ object data (which contains the data for the second
                        \ and third edges)

 LDX objectLeft,Y       \ Set nextEdge to the scaled data from objectLeft for
 LDA scaledScaffold,X   \ this object part, to pass to DrawObjectEdge
 STA nextEdge

 LDA objectRight,Y      \ Set colourData to the data from objectRight for this
 STA colourData         \ object part, to pass to DrawObjectEdge

 LDY #0                 \ Draw the second edge of the four-edge object part
 JSR DrawObjectEdge

 LDY thisObjectIndex    \ Set Y to the index into the object data

 LDX objectTop,Y        \ Set nextEdge to the scaled data from objectTop for
 LDA scaledScaffold,X   \ this object part, to pass to DrawObjectEdge
 STA nextEdge

 LDA objectColour,Y     \ Set colourData to the data from objectColour for this
 STA colourData         \ object part, to pass to DrawObjectEdge

 LDY #0                 \ Draw the third edge of the four-edge object part
 JSR DrawObjectEdge

 JMP drob5              \ Loop back to drob5 to draw the fourth edge, with
                        \ colourData set to the colour data from the third edge,
                        \ which does not have bit 7 set

\ ******************************************************************************
\
\       Name: GetObjRotation (Part 1 of 4)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate an object's rotation angle about the y-axis
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The offset of the variable to use for the object's 3D
\                       coordinates
\
\                         * &F4 = xVector7
\
\                         * &FA = xVector3
\
\                         * &FD = xVector4
\
\   Y                   The offset of the second variable to use:
\
\                         * 0 = xPlayerCoord
\
\                         * 6 = xVector6
\
\ Returns:
\
\   (JJ II)             The rotation about the y-axis of the object
\
\   (J I)               max(|x-delta|, |z-delta|)
\
\   (H G)               min(|x-delta|, |z-delta|)
\
\   M                   The smaller viewing angle of the object, where 0 to 255
\                       represents 0 to 45 degrees
\
\ Other entry points:
\
\   GetObjRotation-2    Use xPlayerCoord (Y = 0)
\
\ ******************************************************************************

 LDY #0                 \ Use xPlayerCoord for the second variable when calling
                        \ the routine via GetObjRotation-2

.GetObjRotation

                        \ The vectors used in this routine are configured by the
                        \ values of X and Y, but for the purposes of simplicity,
                        \ the comments will assume the following:
                        \
                        \   * X = &FD, xVector4
                        \
                        \   * Y = 0, xPlayerCoord

 LDA xSegmentCoordILo,X \ Set (VV PP) = xVector4 - xPlayerCoord
 SEC                    \
 SBC xPlayerCoordLo,Y   \ starting with the low bytes
 STA PP

 LDA xSegmentCoordIHi,X \ And then the high bytes
 SBC xPlayerCoordHi,Y
 STA VV

                        \ Let's call this difference in x-coordinates x-delta,
                        \ so:
                        \
                        \   (VV PP) = x-delta

 BPL rotn1              \ If (VV PP) is positive, jump to rotn1 to skip the
                        \ following

 LDA #0                 \ Set (VV PP) = 0 - (VV PP)
 SEC                    \
 SBC PP                 \ starting with the low bytes
 STA PP

 LDA #0                 \ And then the high bytes
 SBC VV

                        \ So (VV PP) is now positive, in other words:
                        \
                        \   (VV PP) = |x-delta|

.rotn1

 STA SS                 \ Set (SS PP) = (VV PP)
                        \             = |x-delta|

 LDA zSegmentCoordILo,X \ Set (GG RR) = zVector4 - zPlayerCoord
 SEC                    \
 SBC zPlayerCoordLo,Y   \ starting with the low bytes
 STA RR

 LDA zSegmentCoordIHi,X \ And then the high bytes
 SBC zPlayerCoordHi,Y
 STA GG

                        \ Let's call this difference in z-coordinates z-delta,
                        \ so:
                        \
                        \   (GG RR) = z-delta

 BPL rotn2              \ If (GG RR) is positive, jump to rotn2 to skip the
                        \ following

 LDA #0                 \ Set (GG RR) = 0 - (GG RR)
 SEC                    \
 SBC RR                 \ starting with the low bytes
 STA RR

 LDA #0                 \ And then the high bytes
 SBC GG

                        \ So (GG RR) is now positive, in other words:
                        \
                        \   (GG RR) = |z-delta|

.rotn2

 STA UU                 \ Set (UU RR) = (GG RR)
                        \             = |z-delta|

                        \ At this point we have the following:
                        \
                        \   (SS PP) = |x-delta|
                        \
                        \   (UU RR) = |z-delta|
                        \
                        \ We now compare these two 16-bit values, starting with
                        \ the high bytes, and then the low bytes (if the high
                        \ bytes are the same)

 CMP SS                 \ If UU < SS, then (UU RR) < (SS PP), so jump to rotn3
 BCC rotn3

 BNE rotn4              \ If UU <> SS, i.e. UU > SS, then (UU RR) > (SS PP), so
                        \ jump to rotn4 with the C flag clear

                        \ The high bytes are equal, so now we compare the low
                        \ bytes

 LDA RR                 \ If RR >= PP, then (UU RR) >= (SS PP), so jump to rotn4
 CMP PP                 \ with the C flag set
 BCS rotn4

                        \ Otherwise (UU RR) < (SS PP), so fall through into
                        \ rotn3

.rotn3

                        \ If we get here then (UU RR) < (SS PP), so:
                        \
                        \   |z-delta| < |x-delta|

 LDA UU                 \ Set (H G) = (UU RR)
 STA H                  \           = |z-delta|
 LDA RR                 \
 STA G                  \ and (H G) contains the smaller value

 LDA PP                 \ Set (J I) = (SS PP)
 STA I                  \           = |x-delta|
 LDA SS                 \
 STA J                  \ and (J I) contains the larger value

 JMP rotn6              \ Jump to rotn6

.rotn4

                        \ If we get here then (UU RR) >= (SS PP), so:
                        \
                        \   |z-delta| >= |x-delta|

 PHP                    \ Store the status flags on the stack, and in particular
                        \ the Z flag, which which will be set if the two match,
                        \ i.e. if |z-delta| = |x-delta|
                        \
                        \ In other words, a BEQ would branch with these flags

 LDA SS                 \ Set (H G) = (SS PP)
 STA H                  \           = |x-delta|
 LDA PP                 \
 STA G                  \ and (H G) contains the smaller value

 LDA RR                 \ Set (J I) = (UU RR)
 STA I                  \           = |z-delta|
 LDA UU                 \
 STA J                  \ and (J I) contains the larger value

 PLP                    \ Retrieve the status flags we stored above

 BEQ rotn9              \ If (UU RR) = (SS PP), jump to rotn9

 JMP rotn14             \ Jump to rotn14

\ ******************************************************************************
\
\       Name: GetObjRotation (Part 2 of 4)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate rotation angle for when |x-delta| > |z-delta|
\
\ ******************************************************************************

.rotn5

                        \ This part is called from below, if we want to scale
                        \ the division

 ASL RR                 \ Set (UU RR) = (UU RR) << 1
 ROL UU

.rotn6

                        \ If we get here, then:
                        \
                        \   * (J I) = (A PP) = |x-delta|
                        \
                        \   * VV is the high byte of x-delta
                        \
                        \   * (H G) = (UU RR) = |z-delta|
                        \
                        \   * GG is the high byte of z-delta
                        \
                        \   * |x-delta| > |z-delta|
                        \
                        \ We now do the following division so we can use
                        \ trigonometry to calculate the rotation angle:
                        \
                        \   |z-delta| / |x-delta|
                        \
                        \ To get started, we shift both 16-bit values to the
                        \ left as far as possible, which we can do without
                        \ affecting the result as we are going to divide the two
                        \ values, so any mutual shifts will cancel each other
                        \ out in the division
                        \
                        \ Once that's done, we can drop the low bytes and just
                        \ divide the high bytes, which retains as much accuracy
                        \ as possible while avoiding the need for full 16-bit
                        \ division
                        \
                        \ So we keep shifting left until we get a 1 in bit 7 of
                        \ (A PP), as that's the larger of the two values

 ASL PP                 \ Set (A PP) = (A PP) << 1
 ROL A

 BCC rotn5              \ If we just shifted a 0 out of the high byte of (A PP),
                        \ then we can keep shifting, so loop back to rotn6 to
                        \ keep shifting both values

 ROR A                  \ We just shifted a 1 out of bit 7 of A, so reverse the
                        \ shift so A contains the correct high byte (we don't
                        \ care about the low byte any more)
                        
                        \ So by this point, (A PP) and (UU RR) have both been
                        \ scaled by the same number of shifts

 STA V                  \ Set V = A, the high byte of the scaled |x-delta|

 LDA RR                 \ Set T = RR, the low byte of the scaled |z-delta|, to
 STA T                  \ use for rounding the result in Divide8x8 ???

 LDA UU                 \ Set A = UU, the high byte of the scaled |z-delta|

 CMP V                  \ If A = V then the high bytes of the scaled values
 BEQ rotn9              \ match, so jump to rotn9, which deals with the case
                        \ when the xVector and zVector values are equal

                        \ We have scaled both values, so now for the division of
                        \ the high bytes

 JSR Divide8x8          \ Set T = 256 * A / V
                        \       = 256 * |z-delta| / |x-delta|
                        \
                        \ using the lower byte of the |z-delta| numerator for
                        \ rounding ???

 LDA #0                 \ Set II = 0 to use as the low byte for the final
 STA II                 \ rotation angle

 LDY T                  \ Set A = arctanR(T)
 LDA arctanR,Y          \       = arctanR(|z-delta| / |x-delta|)
                        \
                        \ So this is the viewing angle of the object

 STA M                  \ Store the viewing angle in M, to return from the
                        \ subroutine

 LSR A                  \ Set (JJ II) = (A 0) >> 3
 ROR II                 \             = A * 256 / 8
 LSR A                  \             = A * 32
 ROR II                 \             = arctanR(|z-delta| / |x-delta|) * 32
 LSR A
 ROR II
 STA JJ

 LDA VV                 \ If VV and GG have different signs, then so do x-delta
 EOR GG                 \ and z-delta, so jump to rotn7
 BMI rotn7

 LDA #0                 \ Negate (JJ II)
 SEC                    \
 SBC II                 \ starting with the low bytes
 STA II

 LDA #0                 \ And then the high bytes
 SBC JJ
 STA JJ

.rotn7

 LDA #64                \ Set A = 64, to add to the high byte below

 BIT VV                 \ If x-delta is positive, jump to rotn8 to skip the
 BPL rotn8              \ following instruction

                        \ If we get here then x-delta is negative

 LDA #&C0               \ Set A = -64, to add to the high byte below

.rotn8

 CLC                    \ Set (JJ II) = (JJ II) + (A 0)
 ADC JJ                 \
 STA JJ                 \ which is one of the following:
                        \
                        \   (JJ II) = (JJ II) + 64 * 256
                        \
                        \   (JJ II) = (JJ II) - 64 * 256
                        \
                        \ depending on the sign of x-delta

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetObjRotation (Part 3 of 4)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate rotation angle for when |x-delta| = |z-delta|
\
\ ******************************************************************************

.rotn9

                        \ If we get here, then:
                        \
                        \   * VV is the high byte of x-delta
                        \
                        \   * GG is the high byte of z-delta
                        \
                        \   * |x-delta| = |z-delta|

 LDA #255               \ Set M = 255, to represent a viewing angle of 45
 STA M                  \ degrees

 LDA #0                 \ Set II = 0 to use as the low byte for the final
 STA II                 \ rotation angle

 BIT VV                 \ If x-delta is positive, jump to rotn11
 BPL rotn11

                        \ If we get here then x-delta is negative

 BIT GG                 \ If z-delta is positive, jump to rotn10
 BPL rotn10

                        \ If we get here then both x-delta and z-delta are
                        \ negative

 LDA #&A0               \ Set (JJ II) = -96 * 256
 STA JJ

 RTS                    \ Return from the subroutine

.rotn10

                        \ If we get here then x-delta is negative and y-delta
                        \ is positive

 LDA #&E0               \ Set (JJ II) = -32 * 256
 STA JJ

 RTS                    \ Return from the subroutine

.rotn11

                        \ If we get here then x-delta is positive

 BIT GG                 \ If z-delta is positive, jump to rotn12
 BPL rotn12

                        \ If we get here then x-delta is positive and y-delta
                        \ is negative

 LDA #&60               \ Set (JJ II) = 96 * 256
 STA JJ

 RTS                    \ Return from the subroutine

.rotn12

                        \ If we get here then both x-delta and z-delta are
                        \ positive

 LDA #&20               \ Set (JJ II) = 32 * 256
 STA JJ

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetObjRotation (Part 4 of 4)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate rotation angle for when |x-delta| < |z-delta|
\
\ ******************************************************************************

.rotn13

                        \ This part is called from below, if we want to scale
                        \ the division

 ASL PP                 \ Set (SS PP) = (SS PP) << 1
 ROL SS

.rotn14

                        \ If we get here, then:
                        \
                        \   * (H G) = (SS PP) = |x-delta|
                        \
                        \   * VV is the high byte of x-delta
                        \
                        \   * (J I) = (A RR) = |z-delta|
                        \
                        \   * GG is the high byte of z-delta
                        \
                        \   * |x-delta| < |z-delta|
                        \
                        \ We now do the following division so we can use
                        \ trigonometry to calculate the rotation angle:
                        \
                        \   |x-delta| / |z-delta|
                        \
                        \ To get started, we shift both 16-bit values to the
                        \ left as far as possible, which we can do without
                        \ affecting the result as we are going to divide the two
                        \ values, so any mutual shifts will cancel each other
                        \ out in the division
                        \
                        \ Once that's done, we can drop the low bytes and just
                        \ divide the high bytes, which retains as much accuracy
                        \ as possible while avoiding the need for full 16-bit
                        \ division
                        \
                        \ So we keep shifting left until we get a 1 in bit 7 of
                        \ (A RR), as that's the larger of the two values

 ASL RR                 \ Set (A RR) = (A RR) << 1
 ROL A

 BCC rotn13             \ If we just shifted a 0 out of the high byte of (A RR),
                        \ then we can keep shifting, so loop back to rotn13 to
                        \ keep shifting both values

 ROR A                  \ We just shifted a 1 out of bit 7 of A, so reverse the
                        \ shift so A contains the correct high byte (we don't
                        \ care about the low byte any more)
                        
                        \ So by this point, (A RR) and (SS PP) have both been
                        \ scaled by the same number of shifts

 STA V                  \ Set V = A, the high byte of the scaled |z-delta|

 LDA PP                 \ Set T = PP, the low byte of the scaled |x-delta|, to
 STA T                  \ use for rounding the result in Divide8x8 ???

 LDA SS                 \ Set A = SS, the high byte of the scaled |x-delta|

 CMP V                  \ If A = V then the high bytes of the scaled values
 BEQ rotn9              \ match, so jump to rotn9, which deals with the case
                        \ when the xVector and zVector values are equal

                        \ We have scaled both values, so now for the division of
                        \ the high bytes

 JSR Divide8x8          \ Set T = 256 * A / V
                        \       = 256 * |x-delta| / |z-delta|
                        \
                        \ using the lower byte of the |x-delta| numerator for
                        \ rounding ???

 LDA #0                 \ Set II = 0 to use as the low byte for the final
 STA II                 \ rotation angle

 LDY T                  \ Set A = arctanR(T)
 LDA arctanR,Y          \       = arctanR(|x-delta| / |z-delta|)
                        \
                        \ So this is the viewing angle of the object

 STA M                  \ Store the viewing angle in M, to return from the
                        \ subroutine

 LSR A                  \ Set (JJ II) = (A 0) >> 3
 ROR II                 \             = A * 256 / 8
 LSR A                  \             = A * 32
 ROR II                 \             = arctanR(|x-delta| / |z-delta|) * 32
 LSR A
 ROR II
 STA JJ

 LDA VV                 \ If VV and GG have different signs, then so do x-delta
 EOR GG                 \ and z-delta, so jump to rotn15
 BPL rotn15

 LDA #0                 \ Negate (JJ II)
 SEC                    \
 SBC II                 \ starting with the low bytes
 STA II

 LDA #0                 \ And then the high bytes
 SBC JJ
 STA JJ

.rotn15

 LDA #0                 \ Set A = 0, to add to the high byte below

 BIT GG                 \ If z-delta is positive, jump to rotn16 to skip the
 BPL rotn16             \ following instruction

                        \ If we get here then z-delta is negative

 LDA #&80               \ Set A = -128, to add to the high byte below

.rotn16

 CLC                    \ Set (JJ II) = (JJ II) + (A 0)
 ADC JJ                 \
 STA JJ                 \ which is one of the following:
                        \
                        \   (JJ II) = (JJ II)
                        \
                        \   (JJ II) = (JJ II) - 128 * 256
                        \
                        \ depending on the sign of z-delta

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetObjElevation
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate an object's elevation angle
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The offset of the variable to use for the object's 3D
\                       coordinates
\
\                         * &F4 = yVector7
\
\                         * &FA = yVector3
\
\                         * &FD = yVector4
\
\   Y                   The offset of the second variable to use:
\
\                         * 0 = yPlayerCoord
\
\                         * 6 = yVector6
\
\   (L K)               The result from GetObjectDistance, which is called
\                       between GetObjRotation and GetObjElevation
\
\ Returns:
\
\   LL                  The elevation angle of the object
\
\   A                   The elevation angle of the object (same as LL)
\
\   scaleUp             The scale up factor for the object
\
\   scaleDown           The scale down factor for the object
\
\   C flag              Is the object visible on-screen:
\
\                         * Clear if the object is on-screen
\
\                         * Set if it isn't on-screen
\
\   N flag              Set according to the y-coordinate, so a BPL following
\                       the call will branch if the y-coordinate is positive
\
\ Other entry points:
\
\   GetObjElevation-2   Use yPlayerCoord (Y = 0)
\
\ ******************************************************************************

 LDY #0                 \ Use xPlayerCoord for the second variable when calling
                        \ the routine via GetObjElevation-2

.GetObjElevation

                        \ The vectors used in this routine are configured by the
                        \ values of X and Y, but for the purposes of simplicity,
                        \ the comments will assume the following:
                        \
                        \   * X = &FD, yVector4
                        \
                        \   * Y = 0, yPlayerCoord

 LDA ySegmentCoordILo,X \ Set (WW QQ) = yVector4 - yPlayerCoord
 SEC                    \
 SBC yPlayerCoordLo,Y   \ starting with the low bytes
 STA QQ

 LDA ySegmentCoordIHi,X \ And then the high bytes
 SBC yPlayerCoordHi,Y
 STA WW

                        \ Let's call this difference in y-coordinates y-delta,
                        \ so:
                        \
                        \   (WW QQ) = (A QQ) = y-delta

 BPL elev1              \ If (A QQ) is positive, jump to elev1 to skip the
                        \ following

 LDA #0                 \ Set (A QQ) = 0 - (WW QQ)
 SEC                    \
 SBC QQ                 \ starting with the low bytes
 STA QQ

 LDA #0                 \ And then the high bytes
 SBC WW

                        \ So (A QQ) is now positive, in other words:
                        \
                        \   (A QQ) = |y-delta|

.elev1

 LSR A                  \ Set (A QQ) = (A QQ) >> 3
 ROR QQ                 \            = |y-delta| / 8
 LSR A
 ROR QQ
 LSR A
 ROR QQ

 STA TT                 \ Set (TT QQ) = (A QQ)
                        \             = |y-delta| / 8

                        \ We now compare the two 16-bit values in (A QQ) and
                        \ (L K)

 CMP L                  \ If A < L, then (A QQ) < (L K), so jump to elev3
 BCC elev3

 BNE elev2              \ If A <> L, i.e. A > L, then (A QQ) > (L K), so jump
                        \ to elev2 to return from the subroutine with the C flag
                        \ set

                        \ The high bytes are equal, so now we compare the low
                        \ bytes

 LDA QQ                 \ If QQ < K, then (A QQ) < (L K), so jump to elev3
 CMP K
 BCC elev3

.elev2

                        \ If we get here then (A QQ) >= (L K), so:
                        \
                        \   |y-delta| / 8 >= (L K)

 SEC                    \ Set the C flag

 RTS                    \ Return from the subroutine

.elev3

 LDY #0                 \ Set Y = 0, which we use to count the number of shifts
                        \ in the following calculation

 LDA L                  \ Set (A K) = (L K)

 JMP elev5              \ Jump to elev5

.elev4

                        \ This part is called from below, if we want to scale
                        \ the division

 ASL QQ                 \ Set (TT QQ) = (TT QQ) << 1
 ROL TT

 INY                    \ Increment Y

.elev5

                        \ If we get here, then:
                        \
                        \   * (TT QQ) = |y-delta| / 8
                        \
                        \   * WW is the high byte of y-delta
                        \
                        \   * (A K) = |x-delta|
                        \
                        \   * |x-delta| > |y-delta| / 8
                        \
                        \   * Y = 0
                        \
                        \ We now do the following division so we can use
                        \ trigonometry to calculate the elevation angle:
                        \
                        \   (|y-delta| / 8) / |x-delta|
                        \
                        \ To get started, we shift both 16-bit values to the
                        \ left as far as possible, which we can do without
                        \ affecting the result as we are going to divide the two
                        \ values, so any mutual shifts will cancel each other
                        \ out in the division
                        \
                        \ We count the number of shifts we do in Y
                        \
                        \ Once that's done, we can drop the low bytes and just
                        \ divide the high bytes, which retains as much accuracy
                        \ as possible while avoiding the need for full 16-bit
                        \ division
                        \
                        \ So we keep shifting left until we get a 1 in bit 7 of
                        \ (A K), as that's the larger of the two values

 ASL K                  \ Set (A K) = (A K) << 1
 ROL A

 BCC elev4              \ If we just shifted a 0 out of the high byte of (A K),
                        \ then we can keep shifting, so loop back to rotn6 to
                        \ keep shifting both values

 ROR A                  \ We just shifted a 1 out of bit 7 of A, so reverse the
                        \ shift so A contains the correct high byte (we don't
                        \ care about the low byte any more)

                        \ So by this point, (A K) and (TT QQ) have both been
                        \ scaled by the same number of shifts

 STA V                  \ Set V = A, the high byte of the scaled |x-delta|,
                        \ which we know is at least 128 (as bit 7 is set)

 STY scaleDown          \ Set scaleDown to the number of shifts in Y

 TAY                    \ Set scaleUp = arctanE(A)
 LDA arctanE-128,Y      \             = arctanE(|x-delta|)
 STA scaleUp

 LDA QQ                 \ Set T = QQ, the low byte of the scaled |y-delta|, to
 STA T                  \ use for rounding the result in Divide8x8 ???

 LDA TT                 \ Set A = TT, the high byte of the scaled |y-delta|

 JSR Divide8x8          \ Set T = 256 * A / V
                        \       = 256 * (|y-delta| / 8) / |x-delta|
                        \
                        \ using the lower byte of the |y-delta| numerator for
                        \ rounding ???

 LDA T                  \ If T >= 128, jump to elev8 to return from the 
 CMP #128               \ subroutine with the C flag set
 BCS elev8

 BIT WW                 \ If y-delta is positive, jump to elev6 to skip the
 BPL elev6              \ following and add 60 to T

 LDA #60                \ Set A = 60 - T
 SEC
 SBC T

 JMP elev7              \ Jump to elev7

.elev6

 CLC                    \ Set A = T + 60
 ADC #60

.elev7

 SEC                    \ Set LL = A - L000D
 SBC L000D
 STA LL

 CLC                    \ Clear the C flag to indicate success

.elev8

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetSectionAngles
\       Type: Subroutine
\   Category: Track
\    Summary: Get the elevations for the inner and outer track sections
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   GetSectionAngles-1  Contains an RTS
\
\ ******************************************************************************

.GetSectionAngles

 LDA newSegmentFetched  \ If newSegmentFetched = 0, then we have not fetched a
 BEQ gsec1              \ new segment since the last call, so jump to gsec1 to
                        \ skip the following call to ShuffleSegmentData

 JSR ShuffleSegmentData \ ??? Shuffle various variables along by one if this is
                        \ a new segment, update L0006 and L0008

 LDA #0                 \ Reset newSegmentFetched to 0 so we don't call the
 STA newSegmentFetched  \ ShuffleSegmentData routine again until the next new
                        \ segment has been fetched

.gsec1

 LDY L0005              \ If L0005 = 6, return from the subroutine (as 
 CPY #6                 \ GetSectionAngles-1 contains an RTS)
 BEQ GetSectionAngles-1

 LDY L0006              \ If L0006 = 6, jump to gsec4
 CPY #6
 BEQ gsec4

                        \ Otherwise we now loop from Y = L0006 up to 5, skipping
                        \ when Y = L0008

.gsec2

 CPY L0008              \ If Y = L0008, jump to gsec3 to move on to the next
 BEQ gsec3              \ iteration

 STY T                  \ Store Y in T so we can retrieve it below

 TYA                    \ Set Y = Y + 40
 CLC
 ADC #40
 TAY

 JSR RotateTrack        \ ??? Update T-th L5F08 (= 0), var23 (subtract spin),
                        \ yVergeLeft (subtract L004E), maybe horizonLine and
                        \ L0051

 LDY T                  \ Retrieve the original value of Y that we stored above

 JSR RotateTrack        \ ??? Update T-th L5EE0 (= 0), var24 (subtract spin),
                        \ yVergeRight (subtract L004E), maybe horizonLine and
                        \ L0051

.gsec3

 INY                    \ Increment the loop counter in Y

 CPY #6                 \ Loop back until we have done the above with Y = L0006
 BCC gsec2              \ to 5

.gsec4

 LDA #6                 \ Set A = (6 - L0008) * 8
 SEC
 SBC L0008
 ASL A
 ASL A
 ASL A

 BIT directionFacing    \ If bit 7 of directionFacing is clear, then we are
 BPL gsec5              \ facing forwards, so jump to gsec5

                        \ If we get here then we are facing backwards, so we
                        \ now calculate the section number

 STA T                  \ Set T = A
                        \       = (6 - L0008) * 8

 LDA objTrackSection+23 \ Set A to the number * 8 of the track section for
                        \ driver 23

 CLC                    \ Set A = A + 8 - T
 ADC #8                 \       = section23 * 8 + 8 - (6 - L0008) * 8
 SEC                    \       = (section23 + 1 - 6 + L0008) * 8
 SBC T

 BCS gsec6              \ If the subtraction didn't underflow, jump to gsec6

 ADC trackSectionCount  \ The subtraction underflowed, so add the total number
                        \ of track sections * 8 given in trackSectionCount to
                        \ wrap round to the correct section number (we know the
                        \ C flag is clear as we just passed through a BCS)

 JMP gsec6              \ Jump to gsec6

.gsec5

                        \ If we get here then we are facing forwards

 CLC                    \ Set A = A + number * 8 of track section for driver 23
 ADC objTrackSection+23 \       = A + section23 * 8
                        \       = (6 - L0008) * 8 + section23 * 8
                        \       = (6 - L0008 + section23) * 8

 CMP trackSectionCount  \ If A < trackSectionCount then A is a valid section
 BCC gsec6              \ number, so jump to gsec6

 SBC trackSectionCount  \ The addition took us past the highest track section
                        \ number, so subtract the total number of track sections
                        \ * 8 given in trackSectionCount to bring it down to the
                        \ correct section number (we know the C flag is set as
                        \ we just passed through a BCC)

.gsec6

 TAY                    \ Set Y = the new section number * 8
 
 STY thisSectionNumber  \ Store the new section number * 8 in thisSectionNumber,
                        \ so we can retrieve it below when looping back

 LDX L0008              \ Set X = L0008, to use as a loop counter for the inner
                        \ (L0008) and outer (L0008 + 40) track coordinates

                        \ We run the following section twice, once for the inner
                        \ track section coordinates (with X = L0008), and again
                        \ for the outer track section coordinates (with
                        \ X = L0008 + 40)

.gsec7

 STX L0042              \ Store the loop counter in L0042

 LDX #&FD               \ Copy the first trackSectionI coordinate for track
 JSR GetSectionCoord    \ section Y into xVector4, so xVector4 is the 3D
                        \ coordinate of the inner track at the start of the
                        \ section (or, if this is the second loop where Y is
                        \ incremented by 3, xVector4 is the 3D coordinate of the
                        \ outer track)

 JSR GetObjRotation-2   \ Calculate xVector4's rotation about the y-axis,
                        \ from the point of view of the player, returning it in
                        \ (JJ II)

 LDY L0042              \ Set Y to the loop counter

 BIT directionFacing    \ If bit 7 of directionFacing is clear, then we are
 BPL gsec8              \ facing forwards, so jump to gsec8

 TYA                    \ We are facing backwards, so flip Y between L0008 and
 EOR #40                \ L0008 + 40 to do the inner and outer track sections
 TAY                    \ in reverse order

.gsec8

 JSR GetSectionRotation \ Set Y-th (var24Hi var24Lo) = (JJ II) - playerRotation
                        \
                        \ Set (L K) to the distance between the track section
                        \ and the player's car

 LDX L0042              \ If X >= 40, then we are dealing with the outer track
 CPX #40                \ section, so jump to gsec10 as we don't need to repeat
 BCS gsec10             \ the elevation calculation (as the track is level, so
                        \ the outer track is the same height as the inner
                        \ track)

 LDX #&FD               \ Set X = &FD so the call to GetObjElevation uses
                        \ xVector4

 JSR GetObjElevation-2  \ Calculate xVector4's elevation angle, from the point
                        \ of view of the player, returning it in A and LL

 LDX L0042              \ Set X to the loop counter, which we know is less than
                        \ 40 at this point (and which is therefore equal to
                        \ L0008)

 LDA LL                 \ Set A to the elevation angle

 STA yVergeRight,X      \ Store the elevation angle in the X-th yVergeRight
                        \ entry, for this point on the inner track section

 STA yVergeLeft,X       \ Store the elevation angle in the X-th yVergeLeft, for
                        \ this point on the outer track section

 CMP horizonLine        \ If A < horizonLine, then this track section is lower
 BCC gsec10             \ than the current horizon, so jump to gsec10 to move on
                        \ to the outer track section 

 BNE gsec9              \ If A <> horizonLine, i.e. A > horizonLine, then the
                        \ track section is higher than the current horizon line,
                        \ so jump to gsec9 to set the horizon line to the
                        \ elevation of this track section

 CPX L0051              \ If X < L0051, jump to gsec10
 BCC gsec10

.gsec9

 STA horizonLine        \ Set horizonLine to the elevation in A

 STX L0051              \ Set L0051 = X

.gsec10

 TXA                    \ Set A = X + 40
 CLC                    \       = L0008 + 40
 ADC #40

 CMP #60                \ If A >= 60, we have done both inner and outer track
 BCS gsec11             \ sections, so jump to gsec11

 TAX                    \ Set X = A
                        \       = L0008 + 40

 LDA thisSectionNumber  \ Set Y = thisSectionNumber + 3
 CLC                    \
 ADC #3                 \ So when we loop back, the offset in Y points to the
 TAY                    \ trackSectionO coordinates for the outer track section
                        \ instead of the inner coordinates in trackSectionI (as
                        \ the outer coordinates are 3 bytes after the inner ones
                        \ in the track data)

 JMP gsec7              \ Loop back to gsec7 to process the outer track section

.gsec11

 LDX L0008              \ Set X = L0008 - 1
 DEX

 JSR SetSegmentPointer  \ Update the segment pointers:
                        \
                        \   * L0006 = min(X + 1, L0006)
                        \
                        \   * If L0005 <= X < 6, set L0008 = X (i.e. decrement)
                        \                        else set L0008 = 5

 LDA #7                 \ Set A = 7, to set as the horizon line when L0052 > 7

 CMP L0052              \ If A >= L0052, jump to gsec12 to return from the
 BCS gsec12             \ subroutine

 STA horizonLine        \ Set horizonLine = 7

.gsec12

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetSegmentRotation
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The offset from xSegmentCoordILo of the variable to use
\                       for the object's 3D coordinates in GetObjRotation
\
\ Returns:
\
\   (L K)               The distance between the object and the player's car
\
\   A                   Contains the high byte of (L K)
\
\ ******************************************************************************

.GetSegmentRotation

 JSR GetObjRotation-2   \ Calculate the object's rotation about the y-axis,
                        \ from the point of view of the player, returning it in
                        \ (JJ II)

 LDY L0012              \ Set Y = L0012, which is 6 or 46

                        \ Fall through into GetSectionRotation to get the
                        \ rotation angle for this segment

\ ******************************************************************************
\
\       Name: GetSectionRotation
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   Index within var24 to store the difference in rotation
\                       angle between the object and the player
\
\   (JJ II)             The rotation about the y-axis of the object
\
\ Returns:
\
\   (L K)               The distance between the object and the player's car
\
\   A                   Contains the high byte of (L K)
\
\ ******************************************************************************

.GetSectionRotation

 LDA II                 \ Set Y-th (var24Hi var24Lo) = (JJ II) - playerRotation
 SEC                    \
 SBC playerRotationLo   \ starting with the low bytes
 STA var24Lo,Y

 LDA JJ                 \ And then the high bytes
 SBC playerRotationHi
 STA var24Hi,Y

 JMP GetObjectDistance  \ Set (L K) to the distance between the object and the
                        \ player's car, with A set to L, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: GetSegmentAngles (Part 1 of 3)
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   6 or 46
\
\   X                   The segment number * 3 as an offset from
\                       xSegmentCoordILo, so:
\
\                         * X for inner track segment coordinates
\
\                         * X + 120 for outer track segment coordinates
\
\   L000E               0 or 120
\
\   L0049               0 or 1
\
\ ******************************************************************************

.GetSegmentAngles

 STA L0012              \ Set L0012 = A

 LDA #0                 \ Set L0042 = 0
 STA L0042

.gseg1

 JSR GetSegmentRotation \ Calculate the rotation angle for the track segment
                        \ specified in X
                        \
                        \ Set Y = L0012
                        \ Set Y-th var24 to distance to player
                        \ Set (A K) = (L K) = distance between object X and car

 CMP L0011              \ If A < L0011, then (L K) < (L0011 L0010), so jump to
 BCC gseg2              \ gseg2

 BNE gseg3              \ If A <> L0011, i.e. A > L0011, then
                        \ (L K) > (L0011 L0010), so jump to gseg3

                        \ We now compare the high bytes

 LDA L0010              \ If L0010 < K, then (L K) > (L0011 L0010), so jump
 CMP K                  \ to gseg3
 BCC gseg3

.gseg2

                        \ If we get here then (L K) <= (L0011 L0010)

 LDA L                  \ Set (L0011 L0010) = (L K)
 STA L0011
 LDA K
 STA L0010

 LDA L0042              \ Set L0013 = L0042
 STA L0013

 LDY L0012              \ Set Y = L0012

 STY L005C              \ Set L005C = L0012

 LDA var24Hi,Y          \ Set L005E = Y-th var24Hi
 STA L005E

.gseg3

 JSR GetObjElevation-2  \ Calculate the object's elevation angle, from the point
                        \ of view of the player, returning it in A and LL
                        \
                        \ If the object is not visible on-screen, the C flag is
                        \ set, otherwise it will be clear

 BCS gseg4              \ If the object is not visible on-screen, jump to gseg4

 BPL gseg10             \ If the elevation angle is positive, jump to gseg10

\ ******************************************************************************
\
\       Name: GetSegmentAngles (Part 2 of 3)
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ******************************************************************************

.gseg4

                        \ If we get here then the object is not visible or the
                        \ elevation is negative

 LDA L0042
 BNE gseg5
 RTS

.gseg5

 LDA #0
 STA U
 LDY L0014
 STX W

.gseg6

 LDA xSegmentCoordILo,X
 SEC
 SBC xSegmentCoordILo,Y
 STA T
 LDA xSegmentCoordIHi,X
 SBC xSegmentCoordIHi,Y
 CLC
 BPL gseg7
 SEC

.gseg7

 PHP
 ROR A
 ROR T
 PLP
 ROR A
 ROR T
 STA V
 LDX U
 LDA xSegmentCoordILo,Y
 CLC
 ADC T
 STA xVector3Lo,X
 LDA xSegmentCoordIHi,Y
 ADC V
 STA xVector3Hi,X
 INX
 CPX #3
 BEQ gseg8
 STX U
 LDX W
 INY
 INX
 STX W
 JMP gseg6

.gseg8

 LDX #&FA               \ xVector3 in GetSegmentRotation

 JSR GetSegmentRotation

 JSR GetObjElevation-2  \ Calculate the object's elevation angle, from the point
                        \ of view of the player, returning it in A and LL
                        \
                        \ If the object is not visible on-screen, the C flag is
                        \ set, otherwise it will be clear

 BCS gseg9              \ If the object is not visible on-screen, jump to gseg9
                        \ to return from the subroutine

 LDX L0014

 LDA markersToDraw      \ Store markersToDraw in temp1 so we can restore it
 STA temp1              \ after the call to SetTrackAndMarkers (so the call
                        \ doesn't change the value of markersToDraw)

 JSR SetTrackAndMarkers

 LDA temp1              \ Retrieve the value of markersToDraw that we stored
 STA markersToDraw      \ in temp1

 INC L0012

.gseg9

 RTS

\ ******************************************************************************
\
\       Name: GetSegmentAngles (Part 3 of 3)
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ******************************************************************************

.gseg10

                        \ If we get here then the elevation angle is positive

 JSR SetTrackAndMarkers
 LDA L0042
 CMP L0013
 BEQ gseg13
 BCC gseg13
 LDY L0012
 LDA var24Hi,Y
 BPL gseg11
 EOR #&FF

.gseg11

 CMP #&14
 BCC gseg13
 LDA var24Hi-1,Y
 BPL gseg12
 EOR #&FF

.gseg12

 CMP #&14
 BCS gseg16
 JMP gseg4

.gseg13

 STX L0014
 INC L0012
 INC L0042
 LDY L0042
 CPY #&12
 BCS gseg16
 LDA L3DD0,Y
 STA T
 TXA
 SEC
 SBC L000E
 CMP T
 BCS gseg14
 TXA
 CLC
 ADC #120
 JMP gseg15

.gseg14

 TXA

.gseg15

 SEC
 SBC T
 TAX
 JMP gseg1

.gseg16

 RTS

\ ******************************************************************************
\
\       Name: MovePlayerCar
\       Type: Subroutine
\   Category: Driving model
\    Summary: Move the player's car in the correct direction
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.MovePlayerCar

 LDA L0044
 SEC
 SBC spinSpeedHi
 BPL mpla1
 EOR #&FF

.mpla1

 ASL A
 CMP #&80
 EOR directionFacing
 BPL mpla3
 BCC mpla2
 EOR #&7F

.mpla2

 CMP #&FC
 BCS mpla3
 JSR sub_C13FB
 RTS

.mpla3

 LDA L0013
 CMP #&0C
 BEQ mpla4
 BCS mpla5
 JSR MovePlayerForward

.mpla4

 BIT L0043
 BPL mpla7
 JSR MovePlayerForward
 RTS

.mpla5

 CMP #&0E
 BCC mpla7
 BEQ mpla6
 JSR MovePlayerBack

.mpla6

 JSR MovePlayerBack

.mpla7

 RTS

\ ******************************************************************************
\
\       Name: GetTrackAndMarkers
\       Type: Subroutine
\   Category: Track
\    Summary: Calculate the 3D coordinates of the track and corner markers
\
\ ******************************************************************************

.GetTrackAndMarkers

 LDA #0                 \ Set horizonLine = 0
 STA horizonLine

 JSR GetSectionAngles   \ Get the elevation angles for the inner and outer track
                        \ sections

 LDA #&FF               \ Set L0011 = -1
 STA L0011

 LDA #13                \ Set L0013 = 13
 STA L0013

 LDA #0                 \ Set L000E, L0049, X for facing forwards
 JSR GetSegmentNumber

 LDA #6
 JSR GetSegmentAngles

 LDA L0012              \ Set L0015 = L0012
 STA L0015

 LDA #&80               \ Set L000E, L0049, X for facing backwards
 JSR GetSegmentNumber

 LDA #46
 JSR GetSegmentAngles

 LDA L0051              \ If L0051 < 40, jump to gmar1 to skip the following
 CMP #40                \ three instructions
 BCC gmar1

 SEC                    \ Set L0051 = L0051 - 40
 SBC #40
 STA L0051

.gmar1

 TAY                    \ Set Y to the updated value of L0051

 STY L0052              \ Set L0052 to the updated value of L0051

 LDA horizonLine        \ If horizonLine < 79, jump to gmar2 to skip the
 CMP #79                \ following two instructions
 BCC gmar2

 LDA #78                \ Set horizonLine = 78, so horizonLine is a maximum of
 STA horizonLine        \ 78

.gmar2

 STA yVergeRight,Y      \ Set the Y-th entry in yVergeRight to the updated value
                        \ of horizonLine

 STA yVergeLeft,Y       \ Set the Y-th entry in yVergeLeft to the updated value
                        \ of horizonLine

 LDA var24Hi,Y          \ Set A = var24Hi - var23Hi for Y
 SEC
 SBC var23Hi,Y

 JSR Absolute8Bit       \ Set A = |A|

 LSR A                  \ Set L62FC = A / 2
 STA L62FC

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetSegmentNumber
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Direction:
\
\                         * Bit 7 clear = forwards
\                        
\                         * Bit 7 set = backwards
\
\ Returns:
\
\   L000E               Returns:
\
\                         * 0 when our car is facing in direction A
\
\                         * 120 when our car is facing opposite direction A
\
\   L0049               Returns:
\
\                         * 0 when our car is facing in direction A
\
\                         * 1 when our car is facing opposite direction A
\
\   X                   Returns:
\
\                         * segmentIndex when our car is facing in direction A
\
\                         * segmentIndex + 120 when our car is facing opposite
\                           direction A (which is the outer xSegmentCoordOLo
\                           rather than the inner xSegmentCoordILo)
\
\ ******************************************************************************

.GetSegmentNumber

 LDX segmentIndex       \ Set X to the index * 3 of the current track segment

 EOR directionFacing    \ If bit 7 of A and bit 7 of directionFacing are the
 BPL snum1              \ same, jump to snum1

 TXA                    \ Set X = X + 120
 CLC
 ADC #120
 TAX

 LDA #120               \ Set A = 120, so L000E gets set to 120

 SEC                    \ Set the C flag, so L0049 gets set to 1

 BNE snum2              \ Jump to snum2 (thie BNE is effectively a JMP as A is
                        \ never zero

.snum1

 LDA #0                 \ Set A = 0, so L000E gets set to 0

 CLC                    \ Clear the C flag, so L0049 gets set to 0

.snum2

 STA L000E              \ Set L000E = A

 LDA #0                 \ Set L0049 = the C flag
 ROL A
 STA L0049

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SetTrackAndMarkers
\       Type: Subroutine
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.SetTrackAndMarkers

 LDY L0049
 CPX #120
 BCS smar1
 LDA segmentFlags,X
 BCC smar2

.smar1

 LDA segmentFlags-120,X

.smar2

 AND L306C,Y            \ Set W = A AND 00101101 if Y = 0
 STA W                  \               00110011 if Y = 1

 AND #7                 \ Set Y = bits 0-2 of W
 TAY

 LDA L306E,Y            \ Set V = 0 if Y = 0 or 1
 STA V                  \         1 otherwise

 LDA L0042
 CMP #3
 BCS smar3
 JMP smar9

.smar3

 LDA scaleDown
 SEC
 SBC L3076,Y
 TAY
 LDA #0
 STA U
 LDA scaleUp
 DEY
 BEQ smar6
 BPL smar5

.smar4

 LSR U
 ROR A
 INY
 BNE smar4
 BEQ smar6

.smar5

 ASL A
 ROL U
 DEY
 BNE smar5

.smar6

 STA T
 LDA L0049
 LSR A
 ROR A
 EOR directionFacing
 BPL smar7
 LDA #0
 SEC
 SBC T
 STA T
 LDA #0
 SBC U
 STA U

.smar7

 LDY L0012

 LDA var24Lo,Y          \ Set (var25Hi var25Lo) = (var24Hi var24Lo) + (U T)
 CLC                    \
 ADC T                  \ starting with the low bytes
 STA var25Lo,Y

 LDA var24Hi,Y          \ And then the high bytes
 ADC U
 STA var25Hi,Y

 LDA W
 AND #%00011000
 BEQ smar9

 LDY markersToDraw      \ Set Y to the number of markers we have to draw

 CPY #3                 \ If Y >= 3, jump to smar9 to skip the following
 BCS smar9

 LDA L0012              \ Set L62B4 for the Y-th marker to L0012
 STA L62B4,Y

 LDA W                  \ Set L6299 for the Y-th marker to W
 STA L6299,Y

 AND #1                 \ If bit 0 of W is clear, jump to smar8 to skip the
 BEQ smar8              \ following instruction

 LSR U                  \ Set (U T) = (U T) >> 1
 ROR T

.smar8

 LDA T                  \ Set (var27Hi var27Lo) for the Y-th marker to (U T)
 STA var27Lo,Y
 LDA U
 STA var27Hi,Y

 INC markersToDraw      \ Increment markersToDraw, as we have just added a new
                        \ marker to draw

.smar9

 TXA
 AND #1
 BEQ smar10
 LDA #2
 BNE smar11

.smar10

 LDA V

.smar11

 LDY L0012
 STA L5EE0,Y
 LDA LL
 STA yVergeRight,Y
 CMP #&50
 BCS smar12
 CMP horizonLine
 BCC smar12
 STA horizonLine
 STY L0051

.smar12

 RTS

\ ******************************************************************************
\
\       Name: HideAllCars
\       Type: Subroutine
\   Category: Driving model
\    Summary: Set all the cars to hidden
\
\ ******************************************************************************

.HideAllCars

 LDX #22                \ We are about to process the car status bytes for
                        \ drivers 0 to 19, plus the three extra car objects in
                        \ 20 to 22 that make up the four-object car, so set a
                        \ loop counter in X

.hide1

 LDA objectStatus,X     \ Set bit 7 in the X-th byte of objectStatus to set the
 ORA #%10000000         \ car for driver X to be hidden
 STA objectStatus,X

 DEX                    \ Decrement the loop counter

 BPL hide1              \ Loop back until we have hidden all 23 cars

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Delay
\       Type: Subroutine
\   Category: Main loop
\    Summary: Delay for a specified number of loops
\
\ ------------------------------------------------------------------------------
\
\ This routine performs T + (5 * 256) loop iterations, to create a delay. The
\ value of T doesn't have much effect on the amount of delay, so it looks like
\ this variable was chosen simply because it doesn't contain anything useful at
\ this point.
\
\ ******************************************************************************

.Delay

 LDX #6                 \ Set X as the counter for the outer loop

.dely1

 DEC T                  \ Loop around for T iterations in the inner loop
 BNE dely1

 DEX                    \ Loop around for X iterations in the outer loop
 BNE dely1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MoveAndDrawCars
\       Type: Subroutine
\   Category: Driving model
\    Summary: Move the cars around the track and draw any that are visible, up
\             to a maximum of five
\
\ ******************************************************************************

.MoveAndDrawCars

 LDA qualifyingTime     \ If bit 7 of qualifyingTime is set then this is a
 BMI Delay              \ practice lap (i.e. qualifyingTime = 255), so there are
                        \ no other cars to draw
                        \
                        \ To maintain the same game speed as for races, we jump
                        \ to Delay to pause for a while before returning from
                        \ the subroutine using a tail call

 LDX positionBehind     \ Set X to the position of the driver behind us

 LDY driversInOrder,X   \ Set Y to the number of the driver in behind us

 LDA objectStatus,Y     \ Clear bit 7 of the car object's status byte, to flag
 AND #%01111111         \ the car behind us as being visible
 STA objectStatus,Y

 JSR MoveCars           \ Move the cars around the track

 JSR ApplyDriverTactics \ Apply driving tactics to all the non-player drivers

 JSR HideAllCars        \ Set all the cars to be hidden

 JSR SetPlayerPositions \ Set the current player's position, plus the position
                        \ ahead and the position behind

 LDX currentPosition    \ Set X to the current player's position

 LDY #5                 \ We now work our way through the five nearest cars in
                        \ front of us, so set a loop counter in Y

.dcar1

 BIT directionFacing    \ If bit 7 of directionFacing is clear, then we are
 BPL dcar2              \ facing forwards, so jump to dcar2

 JSR GetPositionBehind  \ We are facing backwards, so set X to the number of
                        \ the position behind position X, to get the number of
                        \ the car that we are looking at

 JMP dcar3              \ Jump to dcar3 to skip the following

.dcar2

 JSR GetPositionAhead   \ We are facing forwards, so set X to the number of the
                        \ position ahead of position X, to get the number of
                        \ the car that we are looking at

.dcar3

 STY temp3              \ Store the loop counter in temp3 so we can retrieve it
                        \ after the following call

 STX thisPosition       \ Store the position of the car we are considering in
                        \ thisPosition

 JSR BuildVisibleCar    \ Build the car object if it is visible, so we can draw
                        \ it below

 LDX thisPosition       \ Retrieve the position of the car that we stored in
                        \ thisPosition above

 LDY temp3              \ Retrieve the value of the loop counter that we stored
                        \ in temp3 above

 DEY                    \ Decrement the loop counter

 BPL dcar1              \ Loop back until we have processed five cars in front

 JSR DrawCars           \ Draw all the cars, with the closest car in front of us
                        \ split into four objects

 LDX positionBehind     \ Set X to the position of the driver behind us

 JSR BuildVisibleCar    \ Build the car object if it is visible, so it can be
                        \ shown in the mirror if close enough

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SwapDriverPosition
\       Type: Subroutine
\   Category: Drivers
\    Summary: Swap the position for two drivers (i.e. overtake)
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The first position
\
\   Y                   The second position
\
\ Returns:
\
\   X                   The number of the driver now at position X
\
\   Y                   The number of the driver now at position Y
\
\ ******************************************************************************

.SwapDriverPosition

 LDA driversInOrder,X   \ Set T to the number of the driver at position X
 STA T

 LDA driversInOrder,Y   \ Set A to the number of the driver at position Y

 STA driversInOrder,X   \ Set the driver at position X to the driver from
                        \ position Y

 TAX                    \ Set X to the number of the driver now at position X

 LDA T                  \ Set the driver at position y to the driver from
 STA driversInOrder,Y   \ position X

 TAY                    \ Set Y to the number of the driver now at position Y

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ApplyDriverTactics (Part 1 of 3)
\       Type: Subroutine
\   Category: Driving model
\    Summary: Process all cars, checking first to see if the car we are
\             processing has just overtaken the car in front of it
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   H                   Gets a 1 rotated left into bit 0 each time we process
\                       one car overtaking another
\
\ ******************************************************************************

.ApplyDriverTactics

 LDX currentPosition    \ Set X to the current player's position, to use as a
                        \ loop counter in the following as we work backwards
                        \ through the field from this position

.tact1

 STX W                  \ Store the position number in W, so we can retrieve it
                        \ during the loop

 LDA driversInOrder,X   \ Set T to the number of the driver in position X
 STA T

 JSR GetPositionAhead   \ Set X to the number of the position ahead of position
                        \ X

 LDA driversInOrder,X   \ Set G to the number of the driver in position X, i.e.
                        \ the number of the driver ahead of driver T

 STX G                  \ Store the position number of the driver ahead in G, so
                        \ we can retrieve it during the loop

 TAY                    \ Set Y to the number of the driver ahead of driver T

 LDX T                  \ Set X to the number of the driver we are currently
                        \ processing

                        \ So in the following, we are applying driving tactics
                        \ to driver X (aka driver T)
                        \
                        \ We start by comparing driver X with the driver ahead,
                        \ driver Y
                        \
                        \ Drivers X and Y are in positions W and G respectively

 LDA #0                 \ Set N = 0, which we will use to build the car status
 STA N                  \ flags for driver X

 STA carSteering,X      \ Set this driver's carSteering to 0, so by default
                        \ driver X will drive straight (though we may change
                        \ this below)

 JSR GetCarProgress     \ Set A to the distance between drivers X and Y

 BCS tact4              \ If the C flag is set then the cars are far apart, so
                        \ jump to tact18 via tact4 to update the car status byte
                        \ for driver X to N = 0, and then move on to the next
                        \ driver

 BPL tact5              \ If the distance in A is positive then driver Y is
                        \ still ahead of driver X, so jump to tact5 to apply
                        \ tactics to driver X in part 2

                        \ If we get here then driver Y is not actually in front
                        \ of this driver, despite being in a higher position, so
                        \ we now need to check how far ahead driver X is

 CMP #&F6               \ If A < -10, driver X is not very far ahead of driver
 BCC tact4              \ Y, so we don't yet consider this a passing move, so
                        \ jump to tact18 via tact4 to update the car status byte
                        \ for driver X to N = 0, and then move on to the next
                        \ driver

                        \ If we get here then driver X has overtaken driver Y,
                        \ and the distance between the cars is >= 10, so we need
                        \ to swap their positions, as driver X has pulled far
                        \ enough away for this to be considered a passing move

 LDX W                  \ Swap the drivers between positions W and G, i.e. swap
 LDY G                  \ the positions of driver X and Y, so driver X moves
 JSR SwapDriverPosition \ into a higher position, and set:
                        \
                        \   * X = the number of the driver now at position W,
                        \         i.e. the driver behind, previously referred to
                        \         as driver Y
                        \
                        \   * Y = the number of the driver now at position G,
                        \         i.e. the driver ahead, previously referred to
                        \         as driver X
                        \
                        \ So now X and Y have swapped, so driver Y just passed
                        \ driver X

 SEC                    \ Set bit 7 of updateDriverInfo so the driver names get
 ROR updateDriverInfo   \ updated at the top of the screen, to reflect the new
                        \ race positions

 CPY currentPlayer      \ If driver Y (the one that just did the overtaking)
 BNE tact2              \ is not the current player, jump to tact2 to skip the
                        \ following two instructions

                        \ If we get here then the C flag is set, as the above
                        \ comparison is equal

                        \ Driver Y (the one that just did the overtaking) is the
                        \ current player, so we now need to reduce the current
                        \ player's position by 1 to move them into a higher
                        \ position

 LDA #&99               \ Set A = -1 in BCD, which we can use to decrement the
                        \ BCD number in positionChangeBCD below, so the current
                        \ player's position will go down by 1

 BNE tact3              \ Jump to tact3 (this BNE is effectively a JMP as A is
                        \ never zero)

.tact2

 CPX currentPlayer      \ If driver X (the one that just got overtaken) is not
 BNE tact4              \ the current player, jump to tact18 via tact4 to update
                        \ the car status byte for this driver to N = 0, and then
                        \ move on to the next driver

                        \ If we get here then the C flag is set, as the above
                        \ comparison is equal

                        \ Driver Y (the one that just did the overtaking) is the
                        \ current player, so we now need to reduce the current
                        \ player's position by 1 to move them into a higher
                        \ position

 LDA #&01               \ Set A = 1 in BCD, which we can use to increment the
                        \ BCD number in positionChangeBCD below, so the current
                        \ player's position will go up by 1

.tact3

 STA T                  \ Set T = A, so A contains the position change in BCD

 LDA driverLapNumber,Y  \ Set A to the lap number for the driver ahead

 ROL H                  \ Rotate the C flag into bit 0 of H, which we know is
                        \ set from the comparisons above, so this rotates a 1
                        \ into bit 0 of H (though this doesn't appear to be used
                        \ anywhere, so this instruction is a bit of a mystery)

 SBC driverLapNumber,X  \ Subtract the lap number for this driver

 BNE tact4              \ If the drivers are on different laps, jump to tact18
                        \ via tact4 to update the car status byte for this
                        \ driver to N = 0, and then move on to the next driver

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

 CLC                    \ Set positionChangeBCD = positionChangeBCD + T
 LDA T                  \
 ADC positionChangeBCD  \ so this applies the position change we calculated
 STA positionChangeBCD  \ above to positionChangeBCD

 CLD                    \ Clear the D flag to switch arithmetic to normal

.tact4

 JMP tact18             \ Jump to tact18 to update the car status byte for
                        \ driver X to N = 0, and then move on to the next driver

\ ******************************************************************************
\
\       Name: ApplyDriverTactics (Part 2 of 3)
\       Type: Subroutine
\   Category: Driving model
\    Summary: The car we are processing has not overtaken the car in front of
\             it, so apply driving tactics
\
\ ******************************************************************************

.tact5

                        \ We jump here with the distance between driver X and
                        \ driver Y in A, which is positive as driver Y is ahead
                        \ of driver X

 CMP #5                 \ If A >= 5, then the cars are not very close, so jump 
 BCS tact4              \ to tact18 via tact4 to update the car status byte for
                        \ this driver to N = 0, and then move on to the next
                        \ driver

 LDA carSpeedLo,X       \ Set A to the high byte of the following subtraction:
 CLC                    \
 SBC carSpeedLo,Y       \   driver X speed - driver Y speed - 1
 LDA carSpeedHi,X
 SBC carSpeedHi,Y

 ROR V                  \ Rotate the C flag into bit 7 of V, so bit 7 is set if
                        \ driver X is going faster than driver Y (so driver X is
                        \ catching up), and it's clear if driver Y is running
                        \ away with it

 BPL tact4              \ If bit 7 of the ROR result is clear, i.e. the C flag
                        \ is clear, i.e. if driver Y is driving as fast as or
                        \ faster than driver X, jump to tact18 via tact4 to
                        \ update the car status byte for this driver to N = 0,
                        \ and then move on to the next driver

                        \ If we get here then driver X is behind driver Y but is
                        \ driving faster than driver Y, so we need to think
                        \ about steering driver X
                        \
                        \ We also know that A is positive, as the above
                        \ subtraction didn't underflow

 LSR A                  \ Set A = A / 2

 CMP #30                \ If A < 30, jump to tact6 to skip the following
 BCC tact6              \ instruction

 LDA #30                \ Set A = 30, so A is a maximum of 30

.tact6

 CMP #4                 \ If A >= 4, jump to tact7 to skip the following
 BCS tact7              \ instruction

 LDA #4                 \ Set A = 4, so A is a minimum of 4

.tact7

 STA SS                 \ Store A in SS, which we will use below as the amount
                        \ of steering to apply, in the range 4 to 30, with more
                        \ steering being applied when the cars have a bigger
                        \ speed gap

 LDA T                  \ Set A to the number of the driver we are currently
                        \ processing, which we stored in T in part 1 (though the
                        \ same number is still in X, so this could be done more
                        \ efficiently with a TXA instruction)

 CMP #4                 \ Set the C flag if A >= 4, clear the C flag if A < 4

 LDA carStatus,Y        \ Set A to just bit 6 of driver Y's car status byte,
 AND #%01000000         \ which is the acceleration flag

 BEQ tact9              \ If bit 6 of driver Y's car status byte is clear, then
                        \ driver Y is not accelerating, so jump to tact9

                        \ If we get here then driver Y is accelerating, so we
                        \ get driver X to follow driver Y's racing line

 BCS tact8              \ If the C flag is set, then the driver number of the
                        \ driver we are currently processing is 4 or greater, so
                        \ jump to tact8 to skip the following instruction

 ORA #%10000000         \ We are currently processing one of drivers 0 to 3, who
                        \ are the four best drivers, so set bit 7 of A to apply
                        \ the brakes, overriding the acceleration flag in bit 6

.tact8

 STA N                  \ Store the updated flags in N, so bit 6 of driver X
                        \ matches driver Y's bit 6 (so their acceleration status
                        \ matches), and bit 7 (braking) set if X = 0 to 3

 LDA carRacingLine,X    \ If the racing line for driver X >= the racing line for
 CMP carRacingLine,Y    \ driver Y, set the C flag, otherwise clear it
                        \
                        \ In other words, the C flag is set if driver X is to
                        \ the left of driver Y

 ROR T                  \ Rotate the C flag into bit 7 of T, so we can use this
                        \ bit to determine the direction that driver X should
                        \ steer
                        \
                        \ This steers driver X to the right (bit 7 set) when
                        \ driver X is to the left of driver Y - in other words,
                        \ it steers driver X towards driver Y's racing line,
                        \ into driver Y's slipstream

 JMP tact15             \ Jump to tact15 to apply the steering direction in T to
                        \ the amount of steering in SS

.tact9

                        \ If we get here then driver Y is not accelerating, so
                        \ we get driver X to move to overtake driver Y

 BCS tact10             \ If the C flag is set, then the driver number of the
                        \ driver we are currently processing is 4 or greater, so
                        \ jump to tact10

 LDA #%01000000         \ Set N so it only has bit 6 set (so driver X will be
 STA N                  \ set to accelerate)

 LDA carRacingLine,Y    \ If the racing line for driver Y >= the racing line for
 CMP carRacingLine,X    \ driver X, set the C flag, otherwise clear it
                        \
                        \ In other words, the C flag is set if driver X is to
                        \ the right of driver Y

 ROR T                  \ Rotate the C flag into bit 7 of T, so we can use this
                        \ bit to determine the direction that driver X should
                        \ steer
                        \
                        \ This steers driver X to the right (bit 7 set) when
                        \ driver X is to the right of driver Y - in other words,
                        \ it steers driver X away from driver Y's racing line,
                        \ into an overtaking position

 AND #&FF               \ This instruction doesn't change any values, but it
                        \ does set the N flag according to the current value of
                        \ A, so the call to Absolute8Bit will return |A| rather
                        \ than being affected by the result of the ROR
                        \ instruction

 JSR Absolute8Bit       \ Set A = |A|
                        \
                        \ As A is the racing line, this gives the distance of
                        \ driver Y from the edge of the track, with 0 being on
                        \ the verge, and 127 being in the centre

 CMP #60                \ If A < 60, then driver Y is close to the verge, so
 BCC tact11             \ jump to tact11 to steer driver X into the other half
                        \ of the track to driver Y

 BCS tact12             \ Otherwise we steer driver X away from driver Y's
                        \ racing line, by jumping to tact12 (this BCS is
                        \ effectively a JMP as we just passed through a BCC)

.tact10

 LSR V                  \ Clear bit 7 of V, so we never end up applying the
                        \ brakes in tact12 or tact14 below

.tact11

 LDA carRacingLine,Y    \ Set T to the racing line for driver Y, specifically
 STA T                  \ so we can extract the top bit to determine which side
                        \ of the track driver Y is on (0 = right, 1 = left),
                        \ and to steer in the opposite direction

.tact12

 LDA objectStatus,X     \ If bit 7 of driver X's object status byte is clear,
 BPL tact13             \ then the car is visible, so jump to tact13

                        \ If we get here then driver X is not visible

 LDA VIA+&68            \ Read 6522 User VIA T1C-L timer 2 low-order counter
                        \ (SHEILA &68), which will be a pretty random figure

 AND #31                \ Reduce the random number to the range 0 to 31

 BNE tact18             \ If A is non-zero, jump to tact18 to update the car
                        \ status byte for this driver to N, and then move on
                        \ to the next driver

                        \ If we get here then A is zero, which has a 3.125%
                        \ chance of happening

 LDA V                  \ Set A to N, but with bit 7 set to bit 7 of V, so bit 7
 AND #%10000000         \ of N gets set if driver X is going faster than driver
 ORA N                  \ Y, which means driver X slams on the brakes

 JMP tact17             \ Jump to tact17 to update the car status byte for this
                        \ driver to the value of A, and then move on to the next
                        \ driver

.tact13

                        \ If we get here then driver X is visible

 LDA carRacingLine,Y    \ Set A to the difference between the racing lines for
 SEC                    \ driver X and driver Y
 SBC carRacingLine,X

 BCS tact14             \ If the subtraction didn't underflow, jump to tact14 to
                        \ skip the following instruction

 EOR #&FF               \ The subtraction underflowed, so flip all the bits in
                        \ the result to change it from negative to positive, so
                        \ A contains the difference between the two drivers'
                        \ racing lines, made positive

.tact14

 CMP #100               \ If A >= 100, then the cars are far apart in terms of
 BCS tact18             \ left-right spacing, so jump to tact18 to update the
                        \ car status byte for this driver to N, and then move on
                        \ to the next driver

 CMP #80                \ If A >= 80, then the cars are slightly closer, so jump
 BCS tact16             \ to tact16 to set bit 4 of driver X's car status byte

 CMP #60                \ If A >= 60, then the cars are even closer, so jump to
 BCS tact15             \ tact15 to steer driver X in the direction in T, which
                        \ we set above to the side of the track driver Y is on
                        \ (0 = right, 1 = left)
                        \
                        \ This therefore steers driver X away from driver Y, as
                        \ in terms of steering 0 = steer left, 1 = steer right

                        \ If we get here then the cars are really close, so we
                        \ get driver X to slam on the brakes, as well as
                        \ steering away from driver Y

 LDA V                  \ Store the bit 7 of V in bit 7 of the car status flag
 AND #%10000000         \ byte we are building in N, so driver X applies the
 ORA N                  \ brakes when bit 7 of V is set
 STA N

.tact15

 LDA T                  \ Set the steering for this driver to SS, with the top
 AND #%10000000         \ bit (i.e. the direction of the steering) set to the
 ORA SS                 \ sign bit of T (0 = steer left, 1 = steer right)
 STA carSteering,X

.tact16

 LDA N                  \ Set bit 4 of the car status flag byte we are building
 ORA #%00010000         \ in N

.tact17

 STA N                  \ Store A in N to use as the car status flags for this
                        \ driver

\ ******************************************************************************
\
\       Name: ApplyDriverTactics (Part 3 of 3)
\       Type: Subroutine
\   Category: Driving model
\    Summary: Update the car status and loop back for the next car
\
\ ******************************************************************************

.tact18

 LDA carStatus,X        \ Set the C flag to bit 0 of the car status flags for
 LSR A                  \ this driver

 LDA N                  \ Set A = N, to use as the new car status flags for this
                        \ driver, but only when bit 0 of the current flag byte
                        \ is set

 BCS tact19             \ If the C flag is set, i.e. bit 0 of the car status
                        \ flags for this driver is set, jump to tact19 to skip
                        \ the following instruction

 STA carStatus,X        \ Set the car status flags for this driver to A (i.e. to
                        \ the flags in N)

.tact19

 LDX W                  \ Set X to the position that we just checked, which we
                        \ stored in W at the start of the loop

 JSR GetPositionBehind  \ Set X to the number of the position behind position X,
                        \ so we work backwards through the field

 CPX currentPosition    \ If X = the current player's position, jump to tact20
 BEQ tact20             \ to return from the subroutine

 JMP tact1              \ Otherwise jump back to tact1 to process the next
                        \ driver in X

.tact20

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetCarProgress
\       Type: Subroutine
\   Category: Driving model
\    Summary: Calculate the distance between two cars, in terms of progress
\             along the track
\             
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of driver X
\
\   Y                   The number of driver Y
\
\ ******************************************************************************

.GetCarProgress

 LDA carProgress,Y      \ Set the C flag according to the subtraction:
 SEC                    \
 SBC carProgress,X      \    carProgress for driver ahead
                        \  - carProgress for this driver
                        \
                        \ so the progress figures act like a fractional byte
                        \ in the subtraction at the start of the following
                        \ routine, though because only the C flag is kept, they
                        \ only serve to round the result to the nearest integer,
                        \ rather than giving a full 24-bit result

                        \ Fall through into GetObjectProgress to calculate the
                        \ distance between the two cars

\ ******************************************************************************
\
\       Name: GetObjectProgress
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate the distance between two objects, in terms of progress
\             along the track
\
\ ------------------------------------------------------------------------------
\
\ Calculate the distance between two objects.
\
\ Arguments:
\
\   X                   The number of object X
\
\   Y                   The number of object Y
\
\   C flag              Determines the accuracy of the arithmetic:
\
\                         * Clear for a 16-bit calculation using objProgress
\
\                         * For a 24-bit calculation, contains the carry from
\                           GetCarProgress above
\
\ Returns:
\
\   A                   The distance between the two objects, negative if object
\                       X is ahead, positive if object Y is ahead
\
\   T                   The same as A
\
\   C flag              How far apart the objects are:
\
\                         * Set if objects are far apart (distance >= 128)
\
\                         * Clear if they are close (distance < 128)
\
\   N flag              The object order (if the objects are close):
\
\                         * Set if object X is ahead by more than 256
\
\                         * Clear otherwise
\
\   H                   Relationship to the starting line:
\
\                         * Bit 7 is clear if the object are quite close (when
\                           distance < 256) but are on opposite sides of the
\                           starting line
\
\                         * Bit 7 set otherwise
\
\ ******************************************************************************

.GetObjectProgress

 LDA objProgressLo,Y    \ Set (A T) =   objProgress for object Y
 SBC objProgressLo,X    \             - objProgress for object X
 STA T                  \
                        \ starting with the low bytes

 LDA objProgressHi,Y    \ And then the high bytes
 SBC objProgressHi,X    \
                        \ So (A T) now contains the distance between the two
                        \ objects - let's call it distance

 PHP                    \ Store the status register on the stack, so the N flag
                        \ on the stack is the sign of the above subtraction, so
                        \ it's set if objProgressHi for object Y < objProgressHi
                        \ for object X, i.e. if object X is ahead by 256 or more

 BPL dist1              \ If the result of the subtraction was positive, jump
                        \ to dist1 to skip the following instruction

 JSR Absolute16Bit      \ The result of the subtraction was negative, so set
                        \ (A T) = |A T|

.dist1

 STA U                  \ Set (U T) = (A T)
                        \           = |distance|

 SEC                    \ Set the C flag to shift into bit 7 of H below

 BEQ dist2              \ If the high byte of the distance is zero, jump to
                        \ dist2 to check the low byte

                        \ If we get here then the high byte of the distance
                        \ is non-zero, so now we need to check whether this is
                        \ down to the objects being close but either side of the
                        \ starting line (as object progress resets to zero at
                        \ the starting line, so objects that are on either side
                        \ of the line will have a big difference in objProgress
                        \ values even though they are actually close together)

 PLA                    \ Flip the N flag in the status register on the stack
 EOR #%10000000         \ (as the N flag is bit 7 of the status register), so
 PHP                    \ the N flag on the stack is the opposite sign to the
                        \ objProgress subtraction we did above, in other words
                        \ it's now clear if object X is ahead by 256 or more and
                        \ set otherwise
                        \
                        \ This caters for the situation where the cars are close
                        \ but on either side of the starting line, in which case
                        \ the subtraction we did above will give the wrong
                        \ result, so this flips the order of the two objects to
                        \ be correct

                        \ In the following, (trackLengthHi trackLengthLo)
                        \ contains the length of the full track

 LDA trackLengthLo      \ Set (A T) = (trackLengthHi trackLengthLo) - (U T)
 SEC                    \           = trackLength - |distance|
 SBC T                  \
 STA T                  \ starting with the high bytes

 LDA trackLengthHi      \ And then the low bytes
 SBC U

 BNE dist3              \ If the high byte is non-zero, then that means the
                        \ objects are not just either side of the starting line,
                        \ so they must be far away from each other, so jump to
                        \ dist3 to return from the subroutine with the C flag
                        \ set

                        \ If we get here then the high byte is zero, which means
                        \ the objects are quite close but are either side of the
                        \ starting line

 CLC                    \ Clear the C flag

.dist2

                        \ If we get here then the objects are close together
                        \ (the high byte of the distance between then is zero)

 ROR H                  \ Set bit 7 of H to the C flag, so it's clear if the
                        \ objects are quite close but on opposite sides of the
                        \ starting line, otherwise it is set

 LDA T                  \ If T >= 128, then the distance between the objects is
 CMP #128               \ >= 128, so jump to dist3 to return from the subroutine
 BCS dist3              \ with the C flag set

                        \ If we get here then the distance between the objects
                        \ is 127 or less, so the objects are determined to be
                        \ close

 PLP                    \ Retrieve the status flags from the stack

 JSR Absolute8Bit       \ Multiply the sign of A by the N flag

 STA T                  \ Set T = A

 LDA T                  \ Set the N flag according to the value of A

 CLC                    \ Clear the C flag

 RTS                    \ Return from the subroutine

.dist3

                        \ We get here if the objects are far away from each
                        \ other, i.e. the distance between them is >= 128

 PLP                    \ Retrieve the status flags from the stack, to return
                        \ from the subroutine

 SEC                    \ Set the C flag

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MoveCars (Part 1 of 2)
\       Type: Subroutine
\   Category: Driving model
\    Summary: Move the cars around the track
\
\ ------------------------------------------------------------------------------
\
\ This part changes each car's speed. It calculates the speed change in (U A),
\ and then applies it to the car's speed.
\
\ Other entry points:
\
\   MoveCars-1          Contains an RTS
\
\ ******************************************************************************

.MoveCars

 LDA raceStarting       \ If bit 7 of raceStarting is set, then the race is in
 BMI MoveCars-1         \ the process of starting and we are on the starting
                        \ grid, so the cars are not allowed to move, so return
                        \ from the subroutine (as MoveCars-1 contains an RTS)

 LDX #20                \ Set X = 20 to use as a loop counter as we work through
                        \ all 20 cars

 JMP mcar20             \ Jump into the loop at mcar20 to decrement X and start
                        \ looping through the drivers, looping back to mcar1 for
                        \ all drivers except the current player

.mcar1

                        \ This first part of the loop changes the car's speed as
                        \ required

 LDA carStatus,X        \ If bit 7 of driver X's carStatus is set, jump to
 BMI mcar8              \ mcar8 to apply the brakes

 LDY objTrackSection,X  \ Set Y to the track section number * 8 for driver X

 LDA trackSectionFlag,Y \ Set A to the flag byte for the driver's track section

 BPL mcar2              \ If bit 7 of this section's flag byte is clear, jump to
                        \ mcar2

                        \ If we get here then bit 7 of this section's flag byte
                        \ is set

 LDA carSpeedHi,X       \ If the high byte of the car's speed >= the car's
 CMP carSectionSpeed,X  \ carSectionSpeed then jump to mcar11 to skip changing
 BCS mcar11             \ the car's speed, as it is already going fast enough
                        \ for the section

 BCC mcar3              \ Otherwise jump to mcar3 to continue with the speed
                        \ calculation (this BCC is effectively a JMP as we just
                        \ passed through a BCS)

.mcar2

                        \ If we get here then bit 7 of this section's flag byte
                        \ is clear, and A contains this section's flag byte 

 LSR A                  \ Set the C flag to bit 0 of A, i.e. to bit 0 of this
                        \ section's flag byte

 BCS mcar3              \ If bit 0 of this section's flag byte is set, then this
                        \ is a curved section, so jump to mcar3 to continue with
                        \ the speed calculation

                        \ If we get here then bits 0 and 7 of this section's
                        \ flag byte are both clear, so this is a straight
                        \ section and ???

 LDA trackDriverSpeed,Y \ Set carSectionSpeed for this driver to
 STA carSectionSpeed,X  \ trackDriverSpeed for this track section

 CLC                    \ Set A = trackDriverSpeed - carSpeedHi - 1
 SBC carSpeedHi,X

 BCS mcar3              \ If the subtraction didn't underflow, then
                        \ trackDriverSpeed > carSpeedHi, so jump to mcar3 to
                        \ continue with the speed calculation

 LSR A                  \ Set T = A >> 2 with bits 6 and 7 set
 LSR A                  \
 ORA #%11000000         \ As A is negative, this divides A by 4 while keeping
 STA T                  \ the sign, so:
                        \
                        \   T = A / 4
                        \     = (trackDriverSpeed - carSpeedHi - 1) / 4

 LDA objSectionCount,X  \ Set A = objSectionCount - trackSectionTurn
 SEC                    \
 SBC trackSectionTurn,Y \ so this takes the driver's current progress through
                        \ the track section and subtracts the trackSectionTurn
                        \ for this track section

 BCS mcar11             \ If the subtraction didn't underflow, then
                        \ objSectionCount >= trackSectionTurn, so jump to mcar11
                        \ to skip changing the car's speed

 CMP T                  \ If A >= T, jump to mcar8 to apply the brakes
 BCS mcar8

.mcar3

                        \ We now set A and T to use in the calculation to work
                        \ out the level of acceleration we need to apply to the
                        \ car's speed

 LDA carSpeedHi,X       \ Set A to the high byte of the car's current speed

 CMP #60                \ If the high byte of the car's speed in A >= 60, jump
 BCS mcar4              \ to mcar4 to skip the following instruction

 LDA #22                \ Set A = 22

.mcar4

                        \ By this point, A is either 22 or >= 60

 STA T                  \ Set T = A

 LDA carStatus,X        \ If bit 6 of driver X's carStatus is clear, then we do
 AND #%01000000         \ not accelerate the car, so jump to mcar5 with A = 0
 BEQ mcar5

 LDA #5                 \ Set A = 5

.mcar5

                        \ By this point
                        \
                        \   * T is carSpeedHi, reduced to 22 if < 60
                        \
                        \   * A is either 0 or 5, depending on bit 6 of driver
                        \     X's carStatus, i.e. whether the car is set to be
                        \     accelerating

 CLC                    \ Set A = A + the driver's average speed, as calculated
 ADC driverSpeed,X      \ in the SetDriverSpeed routine

                        \ So by this point:
                        \
                        \   * T is carSpeedHi, reduced to 22 if < 60
                        \
                        \   * A is driver X's average speed, + 5 if driver X is
                        \     accelerating 

                        \ We now apply any trackRaceSlowdown factor from the
                        \ track data, which allows us to slow down races for
                        \ debugging purposes (trackRaceSlowdown is set to 0 in
                        \ in the Silverstone track, so this has no effect)

 BIT raceStarted        \ If bit 7 of raceStarted is clear then this is practice
 BPL mcar6              \ or qualifying, so jump to mcar6 to skip the following
                        \ instruction

 SBC trackRaceSlowdown  \ This is a race, so set A = A - trackRaceSlowdown
                        \
                        \ The value of trackRaceSlowdown for the Silverstone
                        \ track is zero, so this has no effect, but if it were
                        \ non-zero then it would reduce the speed of all cars
                        \ in a race by that amount

.mcar6

                        \ We now calculate (U A) = A - T to get the speed change
                        \ to apply to the driver, given the following values:
                        \
                        \   * T is carSpeedHi, reduced to 22 if < 60
                        \
                        \   * A is driver X's average speed, + 5 if driver X is
                        \     accelerating, reduced by trackRaceSlowdown if this
                        \     is a race
                        \
                        \ In other words, T is the current speed, while A is the
                        \ speed we should be aiming for, so
                        \
                        \   (U A) = A - T
                        \
                        \ will give us the delta that we need to apply to the
                        \ car's current speed to get to the new speed, with the
                        \ acceleration much higher when the car's current speed
                        \ is < 60 (when T is reduced to 22)
                        \
                        \ So cars can't accelerate fast once they pass a certain
                        \ speed (carSpeedHi >= 60)

 LDY #0                 \ Set Y = 0, so (Y A) = A

 SEC                    \ Set (Y A) = (Y A) - T
 SBC T                  \           = A - T
                        \
                        \ starting with the low bytes

 BCS mcar7              \ And then the high bytes
 DEY

.mcar7

 STY U                  \ Set (U A) = (Y A)
                        \           = A - T

 JMP mcar9              \ Jump to mcar9

.mcar8

                        \ If we get here then we are applying the brakes, so
                        \ set (U A) to -256 so we subtract 1024 from the speed
                        \ in the following

 LDA #&FF               \ Set (U A) = -256 (&FF00)
 STA U                  \
 LDA #0                 \ so the following adds -1024 to the car speed

.mcar9

                        \ By this point we have calculated the speed change in
                        \ (U A), so now we apply it

 ASL A                  \ Set (U A) = (U A) * 4
 ROL U
 ASL A
 ROL U

 CLC                    \ Set (A carSpeedLo) = (carSpeedHi carSpeedLo) + (U A)
 ADC carSpeedLo,X       \
 STA carSpeedLo,X       \ starting with the low bytes

 LDA U                  \ And then the high bytes
 ADC carSpeedHi,X

 CMP #190               \ If the high byte in A < 190, jump to mcar10 to store
 BCC mcar10             \ the result in carSpeedHi

 LDA #0                 \ Otherwise the car's speed is now a negative value, so
 STA carSpeedLo,X       \ we zero the car's speed, starting with the low byte,
                        \ and setting A = 0 so we also zero the high byte in the
                        \ next instruction

.mcar10

 STA carSpeedHi,X       \ Update the high byte of the car's speed to A

\ ******************************************************************************
\
\       Name: MoveCars (Part 2 of 2)
\       Type: Subroutine
\   Category: Driving model
\    Summary: Move the cars forward around the track, and apply steering
\
\ ------------------------------------------------------------------------------
\
\ This part moves the car round the track by the speed we just calculated, and
\ applies steering if required.
\
\ The steering algorithm works as follows:
\
\   * Only apply steering if the car is visible.
\
\   * If any of the following are true, apply the amount of steering given in
\     carSteering:
\
\     * Bit 6 of the car's objectStatus is set
\
\     * Bit 6 of the car's carSteering is clear
\
\     * Bit 7 of the car's racing line = bit 7 of carSteering, so:
\
\       * Car is in the right half and is steering left (when bit 7 is clear)
\
\       * Car is in the left half and is steering right (when bit 7 is set)
\
\     * The car is not within 30 of either verge, 30 <= carRacingLine < 226
\
\   * Otherwise, if the car's racing line is within 20 of either verge, steer
\     away from the verge by one.
\
\ ******************************************************************************

.mcar11

 LDA #1                 \ Set V = 1, so we do the following loop twice, which
 STA V                  \ updates the car's progress by 2 x carSpeedHi

.mcar12

 LDA carSpeedHi,X       \ Add carSpeedHi to carProgress to move the car along
 CLC                    \ the track by its speed
 ADC carProgress,X
 STA carProgress,X

 BCC mcar13             \ If the addition didn't overflow, jump to mcar13 to do
                        \ the next loop

 JSR MoveObjectForward  \ The addition overflowed, so carProgress has filled up
                        \ and we need to update (objProgressHi objProgressLo)
                        \ for driver X

.mcar13

 DEC V                  \ Decrement the loop counter in V

 BPL mcar12             \ Loop back until we have added carSpeedHi twice

 LDA objectStatus,X     \ If bit 7 of the driver's car object status byte is
 ASL A                  \ set, then the car is not visible, so jump to mar20 to
 BCS mcar20             \ move on to the next car

 BMI mcar17             \ If bit 6 of the driver's car object status byte is
                        \ set, then the car has finished racing, so jump to
                        \ mcar17 to steer the car

 LDA carSteering,X      \ If bit 6 of the car's carSteering is clear, jump to
 AND #%01000000         \ mcar17 to steer the car
 BEQ mcar17

 LDA carRacingLine,X    \ If bit 7 of the car's racing line and carSteering are
 EOR carSteering,X      \ the same (so the car is steering into the opposite
 BPL mcar17             \ half of the track), jump to mcar17 to steer the car

 LDA carRacingLine,X    \ If the car's racing line < 128, then the car is in the
 BPL mcar15             \ right half of the track, so jump to mcar15 to check
                        \ how close it is to the right verge

 CMP #236               \ If the car's racing line < 236, jump to mcar14
 BCC mcar14

                        \ If we get here then the car's racing line >= 236,
                        \ which is very close to the left verge, so we steer a
                        \ little to the right

 DEC carRacingLine,X    \ Steer the car a little to the right

 BCS mcar20             \ Jump to mcar20 (this BCS is effectively a JMP as we
                        \ just passed through a BCC)

.mcar14

 CMP #226               \ If the car's racing line < 226, jump to mcar17 to
 BCC mcar17             \ steer the car

                        \ If we get here, then the car's racing line >= 226,
                        \ which is quite close to the left verge

 BCS mcar20             \ Jump to mcar20 (this BCS is effectively a JMP as we
                        \ just passed through a BCC)

.mcar15

 CMP #20                \ If the car's racing line >= 20, jump to mcar16
 BCS mcar16

                        \ If we get here then the car's racing line < 20, which
                        \ is very close to the right verge, so we steer a little
                        \ to the left

 INC carRacingLine,X    \ Steer the car a little to the left

 BCC mcar20             \ Jump to mcar20 (this BCC is effectively a JMP as we
                        \ just passed through a BCS)

.mcar16

 CMP #30                \ If the car's racing line < 30, jump to mcar20 to move
 BCC mcar20             \ on to the next driver

.mcar17

                        \ If we get here, then we need to apply the steering
                        \ given in carSteering
                        \
                        \ carSteering is a sign-magnitude number, where bit 7 is
                        \ the sign and bits 0-5 contain the magnitude, so before
                        \ we can apply the steering, we need to convert it into
                        \ a signed number

 LDA carSteering,X      \ Set A to the car's carSteering

 AND #%10111111         \ Clear bit 6

 CLC                    \ Clear the C flag in preparation for the addition below

 BPL mcar18             \ If bit 7 of A is clear, then the amount of steering is
                        \ positive and the number is already correct, so jump to
                        \ mcar18 to add it to the racing line

                        \ If we get here then the sign-magnitude number in A is
                        \ negative, so we need to convert this into a signed
                        \ number
                        \
                        \ We do this by first setting bit 6 (which we just
                        \ cleared above) so bits 6 and 7 are both set, and we
                        \ then need to flip bits 0-5, to convert the positive
                        \ magnitude into its negative equivalent
                        \
                        \ We can do this in one EOR instruction, as follows

 EOR #%01111111         \ Set bit 6 of A and flip bits 0-5, so A is now a
                        \ negative number that we can add to the racing line in
                        \ order to subtract the correct amount of steering

 ADC carRacingLine,X    \ Steer the car right by the amount in A

 BCS mcar19             \ If the subtraction didn't underflow then we are still
                        \ on the track, so jump to mcar19 to update the racing
                        \ line with the new figure

 BCC mcar20             \ Otherwise the subtraction just underflowed, which
                        \ means we just steered the car off the track, so jump
                        \ to mcar20 so we don't update the car's racing line
                        \ (this BCC is effectively a JMP as we just passed
                        \ through a BCS)

.mcar18

 ADC carRacingLine,X    \ Steer the car left by the amount in A

 BCS mcar20             \ If the addition just overflowed then this would steer
                        \ the car off the track, so jump to mcar20 so we don't
                        \ update the car's racing line (so we don't actually do
                        \ the steer)

.mcar19

 STA carRacingLine,X    \ Update the car's racing line with the updated figure,
                        \ to steer the car across the track

.mcar20

 DEX                    \ Decrement the loop counter to point to the next driver

 BMI mcar21             \ If we have worked our way through all 20 drivers, jump
                        \ to mcar21 to return from the subroutine

 CPX currentPlayer      \ If driver X is the current player, jump up to mcar20
 BEQ mcar20             \ to move on to the next driver

 JMP mcar1              \ Jump up to mcar1 to process the next driver

.mcar21

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: BuildVisibleCar
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Check the distance to the specified car and build the car object
\             if it is close enough
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The position of the driver whose distance we want to
\                       check
\
\ ******************************************************************************

.BuildVisibleCar

 LDA driversInOrder,X   \ Set A to the number of the driver in position X

 STA thisDriver         \ Store the driver number in thisDriver so we can
                        \ retrieve it later

 STA objectNumber       \ Store the driver number in objectNumber, in case we
                        \ need to hide this driver's car below

 TAX                    \ Set X to the driver number

 LDY #23                \ Set Y to driver 23

 SEC                    \ Set the C flag for a 16-bit calculation in the call
                        \ to GetObjectProgress

 JSR GetObjectProgress  \ Set A and T to the distance between driver X and
                        \ driver 23 in object Y

 BCS bvis1              \ If the C flag is set then the two cars are far apart,
                        \ so jump to bvis1 to hide the car

 EOR directionFacing    \ This tests whether bit 7 of directionFacing and bit 7
 BMI bvis1              \ of the distance in A are different, which will happen
                        \ if either of the following is true:
                        \
                        \   * We are facing forwards (0) and driver X is ahead
                        \     of driver 23 by more than 256 (1)
                        \
                        \   * We are facing backwards (1) and driver X is not
                        \     ahead of driver 23 by more than 256 (0)
                        \
                        \ In both cases driver X is too far away from us to be
                        \ seen, and bit 7 of the result of the EOR will be set,
                        \ so jump to bvis1 to hide the car

 LDA T                  \ Set T = |T|
 JSR Absolute8Bit       \
 STA T                  \ so A and T contain the absolute value of the distance
                        \ between the car and driver 23

 CMP #40                \ If |A| < 40, jump to bvis2 to skip the following
 BCC bvis2              \ instruction and continue creating the car object

                        \ If we get here then the car and driver 23 are far
                        \ apart, so we hide the car

.bvis1

 JMP HideObject         \ Hide the object in objectNumber, which this hides the
                        \ car object for driver X, and return from the
                        \ subroutine using a tail call

.bvis2

                        \ If we get here, A and T contain the absolute value of
                        \ the distance between the car and driver 23

 ASL A                  \ Set A = A * 2
                        \       = distance * 2

 CLC                    \ Set A = ~(A + T)
 ADC T                  \       = ~(distance * 2 + distance)
 EOR #&FF               \       = ~(distance * 3)

 SEC                    \ Set A = A + 1 + segmentIndex
 ADC segmentIndex       \       = ~(distance * 3) + 1 + segmentIndex
                        \       = -(distance * 3) + segmentIndex
                        \       = segmentIndex - distance * 3
                        \
                        \ segmentIndex contains the index * 3 of the track
                        \ segment that was last processed, so this is the same
                        \ as:
                        \
                        \   (track segment index - distance) * 3

 BPL bvis3              \ If the result was positive, i.e. track segment index
                        \ > distance, jump to bvis3 to skip the following

 CLC                    \ Otherwise set A = A + 120
 ADC #120

.bvis3

 TAY                    \ Copy the result from A into Y, so Y now contains the
                        \ track segment index * 3 of the track segment for the
                        \ car object

 LDA carStatus,X        \ If bit 4 of driver X's carStatus is set, jump to
 AND #%00010000         \ BuildCarObjects
 BNE BuildCarObjects

 LDA carSpeedHi,X       \ If the high byte of driver X's speed is less than 50,
 CMP #50                \ jump to BuildCarObjects
 BCC BuildCarObjects

 LDA segmentSteering,Y  \ Set the driver's carSteering to the segmentSteering
 STA carSteering,X      \ value for this track segment, so the car follows the
                        \ curve of the track

\ ******************************************************************************
\
\       Name: BuildCarObjects (Part 1 of 3)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate the 3D coordinate of the specified car
\  Deep dive: Drawing a 3D car from 2D parts
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates the 3D coordinate of the specified car, given its
\ progress through the current section and the racing line, as follows:
\
\   [ xVector4 ]     [ xSegmentCoordI        ]   [ xTrackVectorI ]
\   [ yVector4 ]  =  [ ySegmentCoordI mod 32 ] + [ yTrackVectorI ] * carProgress
\   [ zVector4 ]     [ zSegmentCoordI        ]   [ zTrackVectorI ]
\
\                    [ xTrackVectorO ]
\                  + [       0       ] * carRacingLine * 4
\                    [ zTrackVectorO ]
\
\                    [  0  ]
\                  + [ 144 ]
\                    [  0  ]
\
\ In the above:
\
\   * trackVectorI is the inner track vector for the car's position
\
\   * trackVectorO is the outer track vector for the car's position
\
\   * xSegmentCoordI is the coordinate for the start of the car's track segment
\
\ The routine then calculates the rotation and elevation angles for the car
\ object (or objects).
\
\ This part calculates the 3D coordinate of the car along the inside edge of
\ the track, i.e. the first part of the above:
\
\   [ xVector4 ]   [ xSegmentCoordI        ]   [ xTrackVectorI ]
\   [ yVector4 ] = [ ySegmentCoordI mod 32 ] + [ yTrackVectorI ] * carProgress
\   [ zVector4 ]   [ zSegmentCoordI        ]   [ zTrackVectorI ]
\
\ Arguments:
\
\   X                   The driver number of the car object to build
\
\   L0045               Same as X
\
\   Y                   The index * 3 of the track segment to use for the
\                       calculation
\
\ Returns:
\
\   X                   X is set to the driver number in thisDriver
\
\   xVector4            Contains the object's 3D coordinates (for the one-object
\                       car) or the coordinates of the rear tyres (for the
\                       four-object car
\
\   objRotation         The object's rotation about the y-axis
\
\ ******************************************************************************

.BuildCarObjects

 LDA segmentVector,Y    \ Fetch the track vector number for track segment Y,
                        \ which gives us the track vector number of the car
                        \ object we want to build

 STA yStore1            \ Store the track vector number in yStore1 so we can
                        \ retrieve it in parts 2 and 3

 STY T                  \ Store the index * 3 of the track segment in T

 TAY                    \ Set Y to the track vector number of the car object

 LDA carProgress,X      \ Set TT to the lowest byte of the car's progress
 STA TT

 LDA carRacingLine,X    \ Set UU to the car's current racing line
 STA UU

 LDA xTrackVectorI,Y    \ Set VV to the 3D x-coordinate of the inner track
 STA VV                 \ vector for the car object

 LDA yTrackVectorI,Y    \ Set VV+1 to the 3D y-coordinate of the inner track
 STA VV+1               \ vector for the car object

 LDA zTrackVectorI,Y    \ Set VV+2 to the 3D z-coordinate of the inner track
 STA VV+2               \ vector for the car object

                        \ We now calculate the following:
                        \
                        \   xVector4 =   xSegmentCoordI
                        \              + trackVectorI * carProgress

 LDX #0                 \ We are about to work our way through the three axes,
                        \ so set X = 0 to use as an axis counter, working
                        \ through the three axes x, y, z using X = 0, 1, 2
                        \
                        \ The comments below are for the x-axis

 LDA TT                 \ Set U = TT
 STA U                  \       = the lowest byte of the car's progress

 LDY T                  \ Set Y to the index * 3 of the track segment that we
                        \ stored above

.bcar1

 LDA #0                 \ Set (V A) = 0
 STA V

 LDA VV,X               \ Set A to the x-coordinate of the inner track vector

                        \ We now calculate (V A T) = A * U, making sure we get
                        \ the signs right

 BPL bcar2              \ If A is positive, jump to bcar2 to multiply A and U as
                        \ they are

                        \ If we get here then A is negative, so we need to apply
                        \ the correct sign to the multiplication

 EOR #&FF               \ Negate A (so it is now positive)
 CLC
 ADC #1

 JSR Multiply8x8        \ Set (A T) = A * U

 EOR #&FF               \ Negate A again (so it is now the correct sign for the
 CLC                    \ multiplication)
 ADC #1

 BCS bcar3              \ If the addition just overflowed, then the result is
                        \ now positive, which means V is already the correct
                        \ high byte for (V A T), so jump to bcar3

 DEC V                  \ Otherwise, decrement V to &FF so it's the correct
                        \ high byte for (V A T)

 BCC bcar3              \ Jump to bcar3 (this BCC is effectively a JMP as we
                        \ just passed through a BCS)

.bcar2

 JSR Multiply8x8        \ Set (A T) = A * U

.bcar3

                        \ By this point, we have the following, signed result:
                        \
                        \   (V A T) = A * U
                        \           = trackVectorI * carProgress
                        \
                        \ We now add (V A) to the Y-th entry in xSegmentCoordI,
                        \ which is the xSegmentCoordI entry for the track
                        \ segment passed to the routine (Y contains the
                        \ index * 3 of the track segment), and store the result
                        \ in xVector4
                        \
                        \ For the y-axis of the coordinate, i.e. for the
                        \ multiplication:
                        \
                        \   yVector4 = ySegmentCoordI + (V A)
                        \
                        \ then we add ySegmentCoordIHi mod 32 instead of
                        \ ySegmentCoordIHi

 CLC                    \ Set (xVector4Hi xVector4Lo)
 ADC xSegmentCoordILo,Y \     = (xSegmentCoordIHi xSegmentCoordILo) + (V A)
 STA xVector4Lo,X       \
                        \ starting with the low bytes

 LDA xSegmentCoordIHi,Y \ And then the high bytes (though with a short interlude
                        \ for when X = 1, when we add ySegmentCoordIHi mod 32
                        \ instead)

 PHP                    \ Store the C flag on the stack so we can retrieve it
                        \ when adding the high bytes below

 CPX #1                 \ If X = 1, set A = A mod 32
 BNE bcar4              \                 = ySegmentCoordIHi mod 32
 AND #31

.bcar4

 PLP                    \ Now we can finally add the high bytes
 ADC V
 STA xVector4Hi,X

 INY                    \ Increment the axis pointer for xSegmentCoordI

 INX                    \ Increment the axis pointer for xVector4

 CPX #3                 \ Loop back until X has looped through all three axes
 BNE bcar1

\ ******************************************************************************
\
\       Name: BuildCarObjects (Part 2 of 3)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Add the racing line to the 3D coordinate of the specified car
\  Deep dive: Drawing a 3D car from 2D parts
\
\ ------------------------------------------------------------------------------
\
\ This part adds in the vector from the inside edge of the track to the car,
\ i.e. the second part of the above:
\
\   [ xVector4 ]   [ xVector4 ]   [ xTrackVectorO ]
\   [ yVector4 ] = [ yVector4 ] + [       0       ] * carRacingLine * 4
\   [ zVector4 ]   [ zVector4 ]   [ zTrackVectorO ]
\
\                                 [  0  ]
\                               + [ 144 ]
\                                 [  0  ]
\
\ ******************************************************************************

                        \ We start by calculating the following:
                        \
                        \   xVector4 =   xSegmentCoordI
                        \              + trackVectorO * carRacingLine * 4
                        \
                        \ for the x-axis and z-axis only

 LDY yStore1            \ Set Y to the track vector number that we stored above

 LDA xTrackVectorO,Y    \ Set VV to the 3D x-coordinate of the outer track
 STA VV                 \ vector for the car object

 LDA zTrackVectorO,Y    \ Set VV+2 to the 3D x-coordinate of the outer track
 STA VV+2               \ vector for the car object

                        \ Note that VV+1 still contains the y-coordinate for the
                        \ inner track vector, which we can reuse as the height
                        \ of the track from side-to-side is always the same,
                        \ i.e. yTrackVectorI = yTrackVectorO for the same vector
                        \ which means the track is always level along the y-axis

 LDX #0                 \ We are about to work our way through the three axes,
                        \ so set X = 0 to use as an axis counter, working
                        \ through the three axes x, y, z using X = 0, 1, 2
                        \
                        \ The comments below are for the x-axis

 LDA UU                 \ Set U = UU
 STA U                  \       = the car's current racing line

.bcar5

 LDA #0                 \ Set (V A) = 0
 STA V

 LDA VV,X               \ Set A to the x-coordinate of the outer track vector

                        \ We now calculate (V A T) = A * U, making sure we get
                        \ the signs right

 BPL bcar6              \ If A is positive, jump to bcar6 to multiply A and U as
                        \ they are

                        \ If we get here then A is negative, so we need to apply
                        \ the correct sign to the multiplication

 EOR #&FF               \ Negate A (so it is now positive)
 CLC
 ADC #1

 JSR Multiply8x8        \ Set (A T) = A * U

 EOR #&FF               \ Negate A again (so it is now the correct sign for the
 CLC                    \ multiplication)
 ADC #1

 BCS bcar7              \ If the addition just overflowed, then the result is
                        \ now positive, which means V is already the correct
                        \ high byte for (V A T), so jump to bcar7

 DEC V                  \ Otherwise, decrement V to &FF so it's the correct
                        \ high byte for (V A T)

 BCC bcar7              \ Jump to bcar7 (this BCC is effectively a JMP as we
                        \ just passed through a BCS)

.bcar6

 JSR Multiply8x8        \ Set (A T) = A * U

.bcar7

                        \ By this point, we have the following, signed result:
                        \
                        \   (V A T) = A * U
                        \           = trackVectorO * carRacingLine

 ASL A                  \ Set (V A) = (V A) * 4
 ROL V                  \           = trackVectorO * carRacingLine * 4
 ASL A
 ROL V

 CLC                    \ Set (xVector4Hi xVector4Lo) = (xVector4Hi xVector4Lo)
 ADC xVector4Lo,X       \                                + (V A)
 STA xVector4Lo,X       \
                        \ starting with the low bytes

 LDA xVector4Hi,X       \ And then the high bytes
 ADC V
 STA xVector4Hi,X

 INX                    \ Set X = X + 2, so we skip the y-axis
 INX

 CPX #4                 \ Loop back to bcar5 until we have processed the x-axis
 BNE bcar5              \ (for X = 0) and z-axis (for X = 2)

                        \ Finally, we add 144 to the y-coordinate

 LDA yVector4Lo         \ Set (yVector4Hi yVector4Lo) += 144
 CLC                    \
 ADC #144               \ starting with the low bytes
 STA yVector4Lo

 BCC bcar8              \ And then the high bytes
 INC yVector4Hi

\ ******************************************************************************
\
\       Name: BuildCarObjects (Part 3 of 3)
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate the screen coordinates of all the objects in the
\             specified car
\  Deep dive: Drawing a 3D car from 2D parts
\
\ ------------------------------------------------------------------------------
\
\ Now that we have the car's 3D coordinates in xVector4, we calculate the car's
\ rotation and elevation angles, and use them to create either one car object,
\ or four car objects if this is the four-object car.
\
\ If this is the four-object car (i.e. the car is directly in front of us, is
\ close enough and is visible), then we calculate the coordinates for the three
\ extra objects as follows:
\
\                     [ xVector4 ]   [ xTrackVectorI ]
\   Front tyres =     [ yVector4 ] + [ yTrackVectorI ] / 2
\                     [ zVector4 ]   [ zTrackVectorI ]
\
\                     [ xVector4 ]   [ xTrackVectorI ]
\   Body and helmet = [ yVector4 ] + [ yTrackVectorI ] / 4
\                     [ zVector4 ]   [ zTrackVectorI ]
\
\                     [ xVector4 ]   [ xTrackVectorI ]
\   Rear tyres =      [ yVector4 ] + [ yTrackVectorI ] / 8
\                     [ zVector4 ]   [ zTrackVectorI ]
\
\ ******************************************************************************

.bcar8

 LDA #4                 \ Set A = 4, to use as the object type for the car (we
                        \ start with the object type of the standard car, and
                        \ change this later if required)

 JSR GetObjectAngles-2  \ Calculate the object's rotation and elevation angles,
                        \ using the coordinates in xVector4, and set the
                        \ object's visibility, scale and type

 LDX L0045              \ Set X = L0045 (driver number of car we are driving)

 LDA objectDistanceHi   \ Set A to the high byte of the distance of the object

 CMP #3                 \ If A >= 3, then the car is not close enough to be the
 BCS bcar11             \ four-object car, so jump to bcar11 to check whether it
                        \ should be built as a distant car object

                        \ If we get here then A <= 2, so the car is close enough
                        \ to consider building as a four-object car

 LDA thisPosition       \ If the car we are building is not the car just ahead
 CMP positionAhead      \ of us in the race, then it can't be the four-object
 BNE bcar10             \ car, jump to bcar10 to return from the subroutine with
                        \ the car built as a standard car

 LDA objectStatus,X     \ If bit 7 of the car's object status byte is set, then
 BMI bcar9              \ the car is not visible, so jump to bcar9 to skip the
                        \ following instruction (which leaves the car object as
                        \ a standard car, but still builds the other three car
                        \ objects)

                        \ If we get here then the car we are building is the
                        \ nearest car in front of us, it's close and it is
                        \ visible, so we draw this car as the four-object car

 DEC objectStatus,X     \ The object type is stored in bits 0-3 of objectStatus,
                        \ so this decrements the car's object type from 4 (the
                        \ standard car) to 3 (the rear wing in the four-object
                        \ car)

.bcar9

 LDY yStore1            \ Set Y to the track vector number that we stored above

 JSR GetTrackData       \ Fetch the inner track vector for the part of the track
                        \ that the car is on:
                        \
                        \   [ (SS T) ]   [ xTrackVectorI ]
                        \   [ (TT U) ] = [ yTrackVectorI ]
                        \   [ (UU V) ]   [ yTrackVectorI ]
                        \
                        \ So this contains the direction of the track where the
                        \ car is

 JSR HalveCoordinate    \ Halve the coordinate in (SS T), (TT U) and (UU V)

 LDY #&FD               \ Set Y = &FD so the call to AddVectors uses xVector4

 LDX #&FA               \ Set X = &FA so the call to AddVectors uses xVector3

 JSR AddVectors         \ Set:
                        \
                        \                         [ (SS T) ]
                        \   xVector3 = xVector4 + [ (TT U) ] / 2
                        \                         [ (UU V) ]
                        \
                        \ So xVector3 contains the 3D coordinates of the front
                        \ tyres of the four-object car

 JSR HalveCoordinate    \ Halve the coordinate in (SS T), (TT U) and (UU V)

 LDX #&F4               \ Set X = &F4 so the call to AddVectors uses xVector7

 JSR AddVectors         \ Set:
                        \
                        \                         [ (SS T) ]
                        \   xVector7 = xVector4 + [ (TT U) ] / 4
                        \                         [ (UU V) ]
                        \
                        \ So xVector7 contains the 3D coordinates of the helmet
                        \ and body of the four-object car

 JSR HalveCoordinate    \ Halve the coordinate in (SS T), (TT U) and (UU V)

 LDX #&FD               \ Set X = &FD so the call to AddVectors uses xVector4

 JSR AddVectors         \ Set:
                        \
                        \                         [ (SS T) ]
                        \   xVector4 = xVector4 + [ (TT U) ] / 8
                        \                         [ (UU V) ]
                        \
                        \ So xVector4 contains the 3D coordinates of the rear
                        \ tyres of the four-object car

                        \ Now that we have the 3D coordinates of the extra three
                        \ parts of the four-object car, we can calculate the
                        \ object's rotation and elevation angles, and store the
                        \ details in objects 20, 21 and 22 (for the rear tyres,
                        \ body/helmet and front tyres respectively)

 LDA #20                \ Set objectNumber = 20, to use as then object number
 STA objectNumber       \ for the rear tyres in the four-object car

 LDA #2                 \ Set A = 2, to use as the object type for the rear
                        \ tyres in the four-object car

 JSR GetObjectAngles-2  \ Calculate the object's rotation and elevation angles,
                        \ using the coordinates of the rear tyres in xVector4,
                        \ and set the object's visibility, scale and type

 LDA #21                \ Set objectNumber = 21, to use as then object number
 STA objectNumber       \ for the body and helmet in the four-object car

 LDA #1                 \ Set A = 1, to use as the object type for the body and
                        \ helmet in the four-object car

 LDX #&F4               \ Set X = &F4 so the call to GetObjectAngles uses
                        \ xVector7

 JSR GetObjectAngles    \ Calculate the object's rotation and elevation angles,
                        \ using the coordinates of the body and helmet in
                        \ xVector7, and set the object's visibility, scale and
                        \ type

 LDA #22                \ Set objectNumber = 22, to use as then object number
 STA objectNumber       \ for the rear tyres in the four-object car

 LDA #0                 \ Set A = 0, to use as the object type for the rear
                        \ tyres in the four-object car

 LDX #&FA               \ Set X = &FA so the call to GetObjectAngles uses
                        \ xVector3

 JSR GetObjectAngles    \ Calculate the object's rotation and elevation angles,
                        \ using the coordinates of the front tyres using
                        \ xVector3, and set the object's visibility, scale and
                        \ type

.bcar10

 LDX thisDriver         \ Set X to the driver number that we stored at the start
                        \ of the BuildVisibleCar routine

 RTS                    \ Return from the subroutine

.bcar11

                        \ We jump here when objectDistanceHi >= 3, so we now
                        \ need to check whether the car is far enough away for
                        \ us to change it to a distant car object
                        \
                        \ We jump here with A set to objectDistanceHi

 CMP #5                 \ If A < 5, i.e. objectDistanceHi = 4, then the car is
 BCC bcar10             \ close enough to stay as a standard car object, so jump
                        \ to bcar10 to return from the subroutine

 LDA objectStatus,X     \ If bit 7 of the car's object status byte is set, then
 BMI bcar10             \ the car is not visible, so jump to bcar10 to return
                        \ from the subroutine

                        \ If we get here then objectDistanceHi >= 5 and the car
                        \ is visible, so the car is far enough away to be a
                        \ distant car object

 INC objectStatus,X     \ The object type is stored in bits 0-3 of objectStatus,
                        \ so this increments the car's object type from 4 (the
                        \ standard car) to 5 (the distant car)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetObjectAngles
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate the object's rotation and elevation angles, and set the
\             object's visibility, scale and type
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Object type
\
\   X                   The offset of the variable to use for the object's 3D
\                       coordinates in the GetObjRotation routine:
\
\                         * &F4 = xVector7
\
\                         * &FA = xVector3
\
\                         * &FD = xVector4
\
\ Other entry points:
\
\   GetObjectAngles-2   Use xVector4 for the object's 3D coordinates in the call
\                       to GetObjRotation
\
\ ******************************************************************************

 LDX #&FD               \ Set X = &FD so the calls to GetObjRotation and
                        \ GetObjElevation use xVector4 and yVector4 for the
                        \ object's 3D coordinates

.GetObjectAngles

 STA objectType         \ Store the object type in objectType

 JSR GetObjRotation-2   \ Calculate the object's rotation about the y-axis,
                        \ from the point of view of the player, returning it in
                        \ (JJ II)

 LDY objectNumber       \ Set Y to the number of the object we are processing

 LDA II                 \ Set the rotation about the y-axis for this object in
 STA objRotationLo,Y    \ (objRotationHi objRotationLo) to (JJ II)
 LDA JJ
 STA objRotationHi,Y

 JSR CheckForContact-2  \ Check to see if the object and the player's car are
                        \ close enough for contact, specifically if they are
                        \ within a distance of 37 from each other

 JSR GetObjElevation-2  \ Calculate the object's elevation angle, from the point
                        \ of view of the player, returning it in A and LL
                        \
                        \ If the object is not visible on-screen, the C flag is
                        \ set, which will hide the object in the following
                        \ routine

                        \ Fall through into SetObjectDetails to set the object's
                        \ visibility, scale and type

\ ******************************************************************************
\
\       Name: SetObjectDetails
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Set an object's visibility, scale and type
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The object's elevation angle, as returned by
\                       GetObjElevation
\
\   C flag              If the C flag is set, hide the object
\
\   scaleUp             The scale up factor, as returned by GetObjElevation
\
\   scaleDown           The scale down factor, as returned by GetObjElevation
\
\ ******************************************************************************

.SetObjectDetails

 LDY objectNumber       \ Set Y to the number of the object

 BCS HideObject         \ If the C flag is set, jump to HideObject to hide the
                        \ object and return from the subroutine using a tail
                        \ call

 SEC                    \ Set A = A - 1
 SBC #1

 BMI HideObject         \ If the result is negative, jump to HideObject to hide
                        \ the object and return from the subroutine using a tail
                        \ call

 STA objElevation,Y     \ Store the object's elevation angle in objElevation

                        \ We now set the object's scaleUp value (i.e. its size)
                        \ to the following:
                        \
                        \   scaleUp / 2 ^ (scaleDown - 10)
                        \
                        \ where scaleUp and scaleDown were set by the call to
                        \ GetObjElevation

 LDA scaleDown          \ Set X = scaleDown - 9
 SEC
 SBC #9
 TAX

 LDA scaleUp            \ Set A = scaleUp

 DEX                    \ Set X = X - 1
                        \       = scaleDown - 10

 BEQ sobj3              \ If X = 0, jump to sobj3 to set the object's scaleUp
                        \ to A

 BPL sobj2              \ If X > 0, jump to sobj3 to set the object's scaleUp
                        \ to A << X

                        \ Otherwise X < 0, so we calculate A >> X to set as the
                        \ the object's scaleUp

.sobj1

 LSR A                  \ Set A = A >> 1

 INX                    \ Increment the shift counter in X

 BNE sobj1              \ Loop back to sobj1 until we have shifted by X places

 BEQ sobj3              \ Jump to sobj3 (this BEQ is effectively a JMP as we
                        \ just passed through a BNE)

.sobj2

 ASL A                  \ Set A = A << 1

 DEX                    \ Decrement the shift counter in X

 BNE sobj2              \ Loop back to sobj2 until we have shifted by X places

.sobj3

 STA objectScaleUp,Y    \ Set the object's scaleUp (i.e. size) to A

 LDA objectStatus,Y     \ Set A to the object's status byte

 AND #%01110000         \ Clear bit 7 to make the object visible, and set bits
 ORA objectType         \ 0-3 to the object type

 JMP SetObjectStatus    \ Jump to SetObjectStatus to store the updated object
                        \ status byte, returning from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: HideObject
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Set an object to be hidden
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   objectNumber        The number of the object to hide
\
\ ******************************************************************************

.HideObject

 LDY objectNumber       \ Set Y to the number of the object to hide

 LDA objectStatus,Y     \ Set A to the object's status byte

 ORA #%10000000         \ Set bit 7 in the object's status byte in A, which
                        \ marks the object as hidden

                        \ Fall through into SetObjectStatus to store the updated
                        \ object status byte

\ ******************************************************************************
\
\       Name: SetObjectStatus
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Set an object's status byte
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The object status byte
\
\   Y                   The number of the object
\
\ ******************************************************************************

.SetObjectStatus

 STA objectStatus,Y     \ Set object Y's status byte to the value in A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CheckForContact
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Check to see if the object is close enough to the player car to
\             make contact
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   Contact is made if objectDistanceLo <= Y
\
\   (J I)               max(|x-delta|, |z-delta|)
\
\   (H G)               min(|x-delta|, |z-delta|)
\
\   M                   The smaller viewing angle of the object, where 0 to 255
\                       represents 0 to 45 degrees
\
\   L0042               The number of the object being checked for contact
\
\ Other entry points:
\
\   CheckForContact-2   Set Y = 37, so we make contact if (L K) <= 37
\
\ ******************************************************************************

 LDY #37                \ Set Y = 37, so we make contact if (L K) <= 37

.CheckForContact

 JSR GetObjectDistance  \ Set (L K) to the distance between the object and the
                        \ player's car

 LDA L                  \ Set objectDistanceHi to the high byte of (L K)
 STA objectDistanceHi

 BNE ccon1              \ If objectDistanceHi is non-zero then the objects are
                        \ too far apart for a collision, so jump to ccon1 to
                        \ return from the subroutine

 CPY K                  \ If K > Y, then the objects are too far apart for a
 BCC ccon1              \ collision, this time in terms of the low byte of the
                        \ distance, so jump to ccon1 to return from the
                        \ subroutine

                        \ If we get here then K <= Y, so the objects are close
                        \ enough for a collision

 DEC processContact     \ Decrement processContact so it is non-zero, so we
                        \ check for contact between this car and the player's
                        \ car in the ProcessContact routine

 LDA K                  \ Set (objectDistanceHi objectDistanceLo) = (L K)
 STA objectDistanceLo

 LDA L0042              \ Store the number of the other object in
 STA collisionDriver    \ collisionDriver, so we know who's crashing

.ccon1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawCarInPosition
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the car in a specified race position
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The race position of the car to draw
\
\ Returns:
\
\   X                   X is preserved
\
\ ******************************************************************************

.DrawCarInPosition

 STX xStore2            \ Store X in xStore2 so it can be retrieved at the end
                        \ of the DrawCarOrSign routine

 LDA driversInOrder,X   \ Set X to the number of the driver in position X
 TAX

                        \ Fall through into DrawCarOrSign to draw the car whose
                        \ driver number we just looked up, i.e. the car in
                        \ position X

\ ******************************************************************************
\
\       Name: DrawCarOrSign
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw a car or sign
\
\ ------------------------------------------------------------------------------
\
\ This routine is used to draw road signs and cars.
\
\ Arguments:
\
\   X                   The car or sign to draw:
\
\                         * 0-19 = Draw the car for this driver number
\
\                         * 20-22 = Draw one of the three extra objects that
\                                   make up the four-object car:
\
\                           * 20 = rear wing
\
\                           * 21 = body and helmet
\
\                           * 22 = front tyres
\
\                         * 23 = Draw the road sign
\
\   xStore2             The value to restore into X at the end of the routine
\
\ Returns:
\
\   X                   X is set to xStore2
\
\ ******************************************************************************

.DrawCarOrSign

 LDA objectStatus,X     \ Set A to this object's status byte

 BMI dcas3              \ If bit 7 is set then the object is not visible, so
                        \ jump to dcas3 to return from the subroutine without
                        \ drawing anything

 AND #%00001111         \ Extract the object's object type from bits 0-3 and
 STA objectType         \ store it in objectType

 LDA objRotationLo,X    \ Set (A T) =   objRotation for this object
 SEC                    \             - playerRotation
 SBC playerRotationLo   \
 STA T                  \ starting with the low bytes

 LDA objRotationHi,X    \ And then the high bytes
 SBC playerRotationHi   \
                        \ So (A T) now contains the amount that the object we
                        \ are drawing is to the left or right of the player's
                        \ car

 BPL dcas1              \ If the result is positive, jump to dcas1 to perform a
                        \ positive comparison

 CMP #&E0               \ The result is negative, so check to see if A < -32,
 BCC dcas3              \ and if so, jump to dcas3 to return from the subroutine
                        \ without drawing anything

 BCS dcas2              \ Jump to dcas2 (this BCS is effectively a JMP as we
                        \ just passed through a BCC)

.dcas1

 CMP #32                \ The result is positive, so check to see if A >= 32,
 BCS dcas3              \ and if so, jump to dcas3 to return from the subroutine
                        \ without drawing anything

.dcas2

                        \ If we get here then -32 <= A < 32

 ASL T                  \ Set (A T) = (A T) * 4
 ROL A                  \
 ASL T                  \ so -128 <= A < 128
 ROL A

 CLC                    \ Set xCoord = 80 + A
 ADC #80                \
 STA xCoord             \ This moves xCoord so that it is centred on the
                        \ screen, as the centre x-coordinate of the screen is
                        \ at 80 pixels

 LDA objElevation,X     \ Set yCoord to this object's elevation angle
 STA yCoord

 LDA objectScaleUp,X    \ Set scaleUp to this object's scale factor (i.e. the
 STA scaleUp            \ size of the car

 JSR DrawObject         \ Draw the object on-screen

.dcas3

 LDX xStore2            \ Set X = xStore2 so X is unchanged by the routine call

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: HalveCoordinate
\       Type: Subroutine
\   Category: Maths
\    Summary: Halve a coordinate with three 16-bit axes
\
\ ------------------------------------------------------------------------------
\
\ Given a three-axis variable, this routine halves each axis in-place:
\
\   [ (SS T) ]   [ (SS T) ]
\   [ (TT U) ] = [ (TT U) ] / 2
\   [ (UU V) ]   [ (UU V) ]
\
\ Arguments:
\
\   (SS T)              The value of the coordinate's first axis
\
\   (TT U)              The value of the coordinate's second axis
\
\   (UU V)              The value of the coordinate's third axis
\
\ ******************************************************************************

.HalveCoordinate

 LDX #2                 \ We are about to right-shift the following 16-bit
                        \ variables:
                        \
                        \   (SS T)
                        \   (TT U)
                        \   (UU V)
                        \
                        \ so set a counter in X to use as an index that loops
                        \ through 2, 1 and 0, as:
                        \
                        \   (TT U) = (SS+1 U+1)
                        \   (UU V) = (SS+2 U+2)
                        \
                        \ The following comments are for (SS T), but the same
                        \ process applies for (TT U) and (UU V)

.halc1

 LDA SS,X               \ Set A to the high byte of (SS T)

 CLC                    \ If A is negative, set the C flag, otherwise clear the
 BPL halc2              \ C flag, so this sets the C flag to the sign of (SS T)
 SEC

.halc2

 ROR SS,X               \ Set (SS T) = (SS T) >> 1
 ROR T,X

 DEX                    \ Decrement the loop counter to move on to the next
                        \ variable

 BPL halc1              \ Loop back until we have shifted all three 16-bit
                        \ variables to the right

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: var29Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var29Hi

 EQUB HI(leftVergeStart)
 EQUB HI(leftTrackStart)
 EQUB HI(rightVergeStart)
 EQUB HI(rightGrassStart)

\ ******************************************************************************
\
\       Name: var29Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var29Lo

 EQUB LO(leftVergeStart)
 EQUB LO(leftTrackStart)
 EQUB LO(rightVergeStart)
 EQUB LO(rightGrassStart)

\ ******************************************************************************
\
\       Name: sub_C2B26
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C2B26

 PHP
 STA L0054
 LDA #0
 STA L001E
 LDA yVergeRight,Y
 SEC
 SBC #1
 CMP #&4E
 BCS C2B40
 LDA var24Hi,X
 BPL C2B3E
 EOR #&FF

.C2B3E

 CMP #&14

.C2B40

 ROR GG
 LDA var24Hi,X
 STA W
 LDA var24Lo,X
 ASL A
 ROL W
 ASL A
 ROL W
 LDA W
 CLC
 ADC #&80
 STA W
 LDA yVergeRight,Y
 STA RR
 STX L0045
 STY thisObjectIndex
 PLP
 BCS C2BCA
 BIT GG
 BVC C2B7B
 BMI C2BCA
 LDX M
 LDY N
 LDA W
 STA M
 LDA RR
 STA N
 STX W
 STY RR
 DEC L001E

.C2B7B

 LDA RR
 SEC
 SBC N
 STA WW
 BPL C2B89
 LDA #0
 SEC
 SBC WW

.C2B89

 STA TT
 LDA GG
 AND #&C0
 BEQ C2BCD
 LDY L0045
 LDX L004F
 LDA var24Lo,Y
 SEC
 SBC var24Lo,X
 STA T
 LDA var24Hi,Y
 SBC var24Hi,X
 STA VV

 JSR Absolute16Bit      \ Set (A T) = |A T|

 CMP #&40
 BCS C2BB9
 ASL T
 ROL A
 CMP #&40
 BCS C2BBB
 ASL T
 ROL A
 BPL C2BBD

.C2BB9

 LSR TT

.C2BBB

 LSR TT

.C2BBD

 STA SS
 LDA VV
 EOR L001E
 STA VV
 LDA SS
 JMP C2BDB

.C2BCA

 JMP C2CFC

.C2BCD

 LDA M
 SEC
 SBC W
 ROR VV
 BMI C2BDB
 EOR #&FF
 CLC
 ADC #1

.C2BDB

 STA SS
 BNE C2BE3
 ORA TT
 BEQ C2BCA

.C2BE3

 LDA GG
 AND #&C0
 BEQ C2BED
 LDA VV
 AND #&80

.C2BED

 STA L0053
 LDA WW
 BNE C2BF9
 LDA L001E
 EOR #&FF
 STA WW

.C2BF9

 BPL C2BFF
 LDA #&88
 BNE C2C01

.C2BFF

 LDA #&C8

.C2C01

 STA C2F60
 STA C2FA2
 LDA #&EA
 STA C2F47
 STA C2F89
 LDY L0054
 LDX #0

.P2C13

 LDA L5FD0,Y
 STA objectPalette,X

 AND pixelsEdgeRight,X
 STA L629C,X

 INY
 INX

 CPX #4
 BNE P2C13

 LDA L0027
 ASL A
 ASL A
 ASL A
 STA T

 LDA objectPalette      \ Set A to logical colour 0 from the object palette

 LSR A
 LSR A
 LSR A
 AND #3
 ORA T
 ORA #&40
 STA L0034

 LDA objectPalette      \ Set A to logical colour 0 from the object palette

 BNE C2C44

 LDA #&55
 STA objectPalette

.C2C44

 STA JJ

 LDA objectPalette+3    \ Set A to logical colour 3 from the object palette

 LSR A
 AND #1
 BIT objectPalette+3
 BPL C2C53
 ORA #2

.C2C53

 ORA #&80
 ORA T
 STA L0033
 LDA thisObjectIndex
 CLC
 ADC #1
 CMP L004B
 BEQ C2C68
 LDA RR
 CMP #&50
 BCC C2C70

.C2C68

 LDA #0
 BIT WW
 BMI C2C70
 LDA #79

.C2C70

 STA RR
 LDA M
 SEC
 SBC #&30
 STA U
 LSR A
 LSR A
 STA UU
 CMP #&28
 BCS C2CE6
 LSR A
 CLC
 ADC #&30
 STA Q
 STA S
 CLC
 ADC #1
 STA NN
 LDA U
 AND #7
 TAX
 LDY N
 LDA SS
 CMP TT
 BCC C2CEF

 LDA objectPalette      \ Set A to logical colour 0 from the object palette

 CMP #&FF
 BEQ C2CB4
 LDA L0033
 AND #3
 CMP #3
 BEQ C2CB4
 LDA #&60
 STA C2FD7
 STA C2FC0
 BNE C2CDF

.C2CB4

 LDA #&E0
 STA C2FD7
 STA C2FC0
 LDA L0027
 CMP #2
 ROR A
 EOR VV
 BPL C2CDF
 LDA C2F60
 STA C2F47
 STA C2F89
 LDA #&EA
 STA C2F60
 STA C2FA2
 LDA WW
 BPL C2CDE
 INY
 JMP C2CDF

.C2CDE

 DEY

.C2CDF

 LDA VV
 BPL C2CE9
 JSR sub_C2D9A

.C2CE6

 JMP C2CFC

.C2CE9

 JSR sub_C2D17
 JMP C2CFC

.C2CEF

 LDA VV
 BPL C2CF9
 JSR sub_C2E99
 JMP C2CFC

.C2CF9

 JSR sub_C2E20

.C2CFC

 LDA L001E
 BMI C2D08
 LDA W
 STA M
 LDA RR
 STA N

.C2D08

 LDX L0045
 LDY thisObjectIndex
 RTS

 LDA L0053
 BEQ C2CFC
 JSR C2F12
 JMP C2CFC

\ ******************************************************************************
\
\       Name: sub_C2D17
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C2D17

 LDA L3E50,X
 STA mod_C2D27+1
 LDX #&80
 LDA SS
 EOR #&FF
 CLC
 ADC #1
 CLC

.mod_C2D27

 BCC C2D29

.C2D29

 LDX #&80
 ADC TT
 BCC C2D36
 SBC SS
 LDX #0
 JSR sub_C2F45

.C2D36

 ADC TT
 BCC C2D41
 SBC SS
 LDX #1
 JSR sub_C2F45

.C2D41

 ADC TT
 BCC C2D4C
 SBC SS
 LDX #2
 JSR sub_C2F45

.C2D4C

 ADC TT
 BCC C2D57
 SBC SS
 LDX #3
 JSR sub_C2F45

.C2D57

 JSR C2FD7
 INC UU
 ADC TT
 BCC C2D67
 SBC SS
 LDX #0
 JSR sub_C2F87

.C2D67

 ADC TT
 BCC C2D72
 SBC SS
 LDX #1
 JSR sub_C2F87

.C2D72

 ADC TT
 BCC C2D7D
 SBC SS
 LDX #2
 JSR sub_C2F87

.C2D7D

 ADC TT
 BCC C2D88
 SBC SS
 LDX #3
 JSR sub_C2F87

.C2D88

 JSR C2FC0
 INC S
 INC Q
 INC NN
 INC UU
 LDX S
 CPX #&44
 BNE C2D29
 RTS

\ ******************************************************************************
\
\       Name: sub_C2D9A
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C2D9A

 LDA L40D0,X
 STA mod_C2DAA+1
 LDX #&80
 LDA SS
 EOR #&FF
 CLC
 ADC #1
 CLC

.mod_C2DAA

 BCC C2DAC

.C2DAC

 LDX #&80
 ADC TT
 BCC C2DB9
 SBC SS
 LDX #3
 JSR sub_C2F87

.C2DB9

 ADC TT
 BCC C2DC4
 SBC SS
 LDX #2
 JSR sub_C2F87

.C2DC4

 ADC TT
 BCC C2DCF
 SBC SS
 LDX #1
 JSR sub_C2F87

.C2DCF

 ADC TT
 BCC C2DDA
 SBC SS
 LDX #0
 JSR sub_C2F87

.C2DDA

 JSR C2FC0
 DEC UU
 ADC TT
 BCC C2DEA
 SBC SS
 LDX #3
 JSR sub_C2F45

.C2DEA

 ADC TT
 BCC C2DF5
 SBC SS
 LDX #2
 JSR sub_C2F45

.C2DF5

 ADC TT
 BCC C2E00
 SBC SS
 LDX #1
 JSR sub_C2F45

.C2E00

 ADC TT
 BCC C2E0B
 SBC SS
 LDX #0
 JSR sub_C2F45

.C2E0B

 JSR C2FD7
 DEC S
 DEC Q
 DEC NN
 DEC UU
 LDX S
 CPX #&2F
 CLC
 BNE C2DAC
 JMP C2F12

\ ******************************************************************************
\
\       Name: sub_C2E20
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C2E20

 LDA L3ED0,X
 STA mod_C2E2E+1
 LDA TT
 EOR #&FF
 CLC
 ADC #1
 CLC

.mod_C2E2E

 BCC C2E30

.C2E30

 LDX #0
 JSR sub_C2F45
 ADC SS
 BCC C2E30
 SBC TT

.P2E3B

 LDX #1
 JSR sub_C2F45
 ADC SS
 BCC P2E3B
 SBC TT

.P2E46

 LDX #2
 JSR sub_C2F45
 ADC SS
 BCC P2E46
 SBC TT

.P2E51

 LDX #3
 JSR sub_C2F45
 ADC SS
 BCC P2E51
 SBC TT
 INC UU

.P2E5E

 LDX #0
 JSR sub_C2F87
 ADC SS
 BCC P2E5E
 SBC TT

.P2E69

 LDX #1
 JSR sub_C2F87
 ADC SS
 BCC P2E69
 SBC TT

.P2E74

 LDX #2
 JSR sub_C2F87
 ADC SS
 BCC P2E74
 SBC TT

.P2E7F

 LDX #3
 JSR sub_C2F87
 ADC SS
 BCC P2E7F
 SBC TT
 INC S
 INC Q
 INC NN
 INC UU
 LDX S
 CPX #&44
 BNE C2E30
 RTS

\ ******************************************************************************
\
\       Name: sub_C2E99
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C2E99

 LDA L3ED8,X
 STA mod_C2EA7+1
 LDA TT
 EOR #&FF
 CLC
 ADC #1
 CLC

.mod_C2EA7

 BCC C2EA9

.C2EA9

 LDX #3
 JSR sub_C2F87
 ADC SS
 BCC C2EA9
 SBC TT

.P2EB4

 LDX #2
 JSR sub_C2F87
 ADC SS
 BCC P2EB4
 SBC TT

.P2EBF

 LDX #1
 JSR sub_C2F87
 ADC SS
 BCC P2EBF
 SBC TT

.P2ECA

 LDX #0
 JSR sub_C2F87
 ADC SS
 BCC P2ECA
 SBC TT
 DEC UU

.P2ED7

 LDX #3
 JSR sub_C2F45
 ADC SS
 BCC P2ED7
 SBC TT

.P2EE2

 LDX #2
 JSR sub_C2F45
 ADC SS
 BCC P2EE2
 SBC TT

.P2EED

 LDX #1
 JSR sub_C2F45
 ADC SS
 BCC P2EED
 SBC TT

.P2EF8

 LDX #0
 JSR sub_C2F45
 ADC SS
 BCC P2EF8
 SBC TT
 DEC S
 DEC Q
 DEC NN
 DEC UU
 LDX S
 CPX #&2F
 CLC
 BNE C2EA9

.C2F12

 LDA C2F47
 STA C2F18

.C2F18

 NOP

.C2F19

 LDA L001E
 BMI C2F22
 LDA L0034
 JMP C2F2A

.C2F22

 DEY
 LDA backgroundColour,Y
 BNE C2F44
 LDA L0033

.C2F2A

 CPY #&50
 BCS C2F44
 LDX L62F2
 CPX #&28
 BCC C2F41
 STA T
 AND #3
 CMP #3
 LDA T
 BCS C2F41
 AND #&FC

.C2F41

 STA backgroundColour,Y

.C2F44

 RTS

\ ******************************************************************************
\
\       Name: sub_C2F45
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   
\
\   UU                  
\
\ Returns:
\
\   C flag              
\
\ ******************************************************************************

.sub_C2F45

 STA II                 \ Store A in II so we can retrieve it later

.C2F47

 NOP                    \ This does nothing, and is presumably left over from
                        \ development

 CPY RR                 \ If Y = RR, jump to C2F7E to return from the subroutine
 BEQ C2F7E              \ with A unchanged and the C flag clear

 LDA UU                 \ Set A = UU

.mod_C2F4E

 STA &7000,Y
 LDA (R),Y
 BNE C2F63

 LDA objectPalette,X    \ Set A to logical colour X from the object palette

.C2F58

 STA (R),Y
 LDA JJ
 STA (P),Y

.P2F5E

 LDA II                 \ Retrieve the value of A we stored above, so A is
                        \ unchanged by the routine

.C2F60

 INY

 CLC                    \ Clear the C flag

 RTS                    \ Return from the subroutine

.C2F63

 CPY #44
 BCS C2F6C

 JSR CheckDashData      \ Check whether offset Y points to dash data within
                        \ block UU, clearing the C flag if it does

 BCC P2F5E              \ If offset Y points to dash data, jump to P2F5E

.C2F6C

 CMP #&55
 BNE C2F72
 LDA #0

.C2F72

 AND pixelsToLeft,X
 ORA L629C,X
 BNE C2F58
 LDA #&55
 BNE C2F58

.C2F7E

 TSX
 INX
 INX
 TXS
 LDA L0053
 BNE C2F19
 RTS

\ ******************************************************************************
\
\       Name: sub_C2F87
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C2F87

 STA II

.C2F89

 NOP
 CPY RR
 BEQ C2F7E
 LDA UU

.mod_C2F90

 STA &7000,Y
 LDA (P),Y
 BNE C2FA5

 LDA objectPalette,X    \ Set A to logical colour X from the object palette

.C2F9A

 STA (P),Y
 LDA JJ
 STA (MM),Y

.P2FA0

 LDA II

.C2FA2

 INY
 CLC
 RTS

.C2FA5

 CPY #44
 BCS C2FAE

 JSR CheckDashData      \ Check whether offset Y points to dash data within
                        \ block UU, clearing the C flag if it does

 BCC P2FA0              \ If offset Y points to dash data, jump to P2FA0

.C2FAE

 CMP #&55
 BNE C2FB4
 LDA #0

.C2FB4

 AND pixelsToLeft,X
 ORA L629C,X
 BNE C2F9A
 LDA #&55
 BNE C2F9A

.C2FC0

 CPX #&80
 BNE C2FD3
 CPY #44
 BCS C2FCD

 JSR CheckDashData      \ Check whether offset Y points to dash data within
                        \ block UU, clearing the C flag if it does

 BCC C2FD3              \ If offset Y points to dash data, jump to C2FD3

.C2FCD

 TAX
 LDA #&FF
 STA (P),Y
 TXA

.C2FD3

 LDX #&80
 CLC
 RTS

.C2FD7

 CPX #&80
 BNE C2FEA
 CPY #44
 BCS C2FE4

 JSR CheckDashData      \ Check whether offset Y points to dash data within
                        \ block UU, clearing the C flag if it does

 BCC C2FEA              \ If offset Y points to dash data, jump to C2FEA

.C2FE4

 TAX
 LDA #&FF
 STA (R),Y
 TXA

.C2FEA

 LDX #&80
 CLC
 RTS

\ ******************************************************************************
\
\       Name: CheckDashData
\       Type: Subroutine
\   Category: Graphics
\    Summary: Check whether a dash data block index is pointing to dash data
\
\ ------------------------------------------------------------------------------
\
\ This routine checks whether an index in Y, which is relative to the start of a
\ dash data block, is pointing to dash data within the block.
\
\ Arguments:
\
\   UU                  Dash data block number (0 to 39)
\
\   Y                   The index from the start of the dash data block
\
\ Returns:
\
\   C flag              The result, as follows:
\
\                         * Clear if offset Y points to dash data
\
\                         * Set if offset Y does not point to dash data
\
\   A                   A is unchanged
\
\   X                   X is unchanged
\
\ ******************************************************************************

.CheckDashData

 STA T                  \ Store A and X in T and U so we can retrieve them below
 STX U

 LDX UU                 \ Set X to the dash data block number

 TYA                    \ Set the C flag as follows:
 CMP dashDataOffset,X   \
                        \   * C flag set if Y >= dashDataOffset,X
                        \
                        \   * C flag clear if Y < dashDataOffset,X

 BNE cdas1              \ If Y <> the dashDataOffset of block X, skip the
                        \ following instruction

 CLC                    \ If we get here then Y = the dashDataOffset of block X,
                        \ so clear the C flag

.cdas1

 LDA T                  \ Restore the values of A and X that we stored above
 LDX U

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: token26
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 26
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token26

 EQUB 200 + 54          \ Print token 54 ("FORMULA 3  CHAMPIONSHIP" header)

 EQUB 31, 10, 12        \ Move text cursor to column 10, row 12

 EQUB 131               \ Set foreground colour to yellow alphanumeric

 EQUS "STANDARD OF"     \ Print "STANDARD OF"

 EQUB 200 + 15          \ Print token 15 (" RACE")

 EQUB 31, 14, 14        \ Move text cursor to column 14, row 14

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token4
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 4
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token4

 EQUB 200 + 52          \ Print token 52 (multicoloured "REVS")

 EQUB 160 + 3           \ Print 3 spaces

 EQUB 200 + 52          \ Print token 52 (multicoloured "REVS")

 EQUB 160 + 3           \ Print 3 spaces

 EQUB 200 + 52          \ Print token 52 (multicoloured "REVS")

 EQUB 160 + 1           \ Print 1 space

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData0
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData0

 SKIP 52                \ Populated with code from &7FCC to &7FFF

\ ******************************************************************************
\
\       Name: tyreEdgeIndex
\       Type: Variable
\   Category: Graphics
\    Summary: Index of the mask and pixel bytes for the tyre edges on a specific
\             track line
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ This table points to the index of the mask or pixel byte to use from the
\ leftTyreMask/rightTyreMask and leftTyrePixels/rightTyrePixels tables for a
\ specific track line. This is used when clipping track lines to the tyre edges.
\
\ There is a byte for each track line from 27 (the track line at the top of the
\ tyres) down to 3 (the lowest track line, just above where the wing mirror
\ joins the car body). Lines 0 to 2 are not used.

\ ******************************************************************************

.tyreEdgeIndex

 EQUB 0                 \ Line  0
 EQUB 0                 \ Line  1
 EQUB 0                 \ Line  2
 EQUB 0                 \ Line  3
 EQUB 6                 \ Line  4
 EQUB 6                 \ Line  5
 EQUB 6                 \ Line  6
 EQUB 6                 \ Line  7
 EQUB 6                 \ Line  8
 EQUB 6                 \ Line  9
 EQUB 6                 \ Line 10
 EQUB 3                 \ Line 11
 EQUB 3                 \ Line 12
 EQUB 3                 \ Line 13
 EQUB 3                 \ Line 14
 EQUB 3                 \ Line 15
 EQUB 1                 \ Line 16
 EQUB 1                 \ Line 17
 EQUB 1                 \ Line 18
 EQUB 0                 \ Line 19
 EQUB 0                 \ Line 20
 EQUB 0                 \ Line 21
 EQUB 5                 \ Line 22
 EQUB 4                 \ Line 23
 EQUB 3                 \ Line 24
 EQUB 2                 \ Line 25
 EQUB 1                 \ Line 26
 EQUB 0                 \ Line 27

\ ******************************************************************************
\
\       Name: L306C
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L306C

 EQUB %00101101
 EQUB %00110011

\ ******************************************************************************
\
\       Name: L306E
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L306E

 EQUB 0, 0, 1, 1, 1, 1, 1, 1

\ ******************************************************************************
\
\       Name: L3076
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L3076

 EQUB &05, &05, &03, &04, &03, &04, &04, &04, &38, &38

\ ******************************************************************************
\
\       Name: staDrawByteTyre
\       Type: Variable
\   Category: Graphics
\    Summary: Low address bytes of the STA instructions in the DRAW_BYTE macros,
\             for use when drawing track lines around the tyres
\
\ ------------------------------------------------------------------------------
\
\ This table contains the low byte offset of the address of the STA (P),Y
\ instruction for the track line, which we convert into an RTS when drawing the
\ track line up against the right tyre, so we stop in time. As the tyres are
\ reflections of each other, we can also use this to calculate the starting
\ point for the line that starts at the left tyre: see part 3 of DrawTrackView
\ for details.
\
\ ******************************************************************************

.staDrawByteTyre

 EQUB  8 * 17 + 15      \ Line  0 = LO(address) of STA (P),Y in DRAW_BYTE 34
 EQUB  8 * 17 + 15      \ Line  1 = LO(address) of STA (P),Y in DRAW_BYTE 34
 EQUB  8 * 17 + 15      \ Line  2 = LO(address) of STA (P),Y in DRAW_BYTE 34
 EQUB  8 * 17 + 15      \ Line  3 = LO(address) of STA (P),Y in DRAW_BYTE 34
 EQUB  9 * 17 + 15      \ Line  4 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line  5 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line  6 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line  7 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line  8 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line  9 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 10 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 11 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 12 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 13 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 14 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 15 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 16 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 17 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 18 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 19 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 20 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB  9 * 17 + 15      \ Line 21 = LO(address) of STA (P),Y in DRAW_BYTE 35
 EQUB 10 * 17 + 15      \ Line 22 = LO(address) of STA (P),Y in DRAW_BYTE 36
 EQUB 10 * 17 + 15      \ Line 23 = LO(address) of STA (P),Y in DRAW_BYTE 36
 EQUB 10 * 17 + 15      \ Line 24 = LO(address) of STA (P),Y in DRAW_BYTE 36
 EQUB 10 * 17 + 15      \ Line 25 = LO(address) of STA (P),Y in DRAW_BYTE 36
 EQUB 10 * 17 + 15      \ Line 26 = LO(address) of STA (P),Y in DRAW_BYTE 36
 EQUB 10 * 17 + 15      \ Line 27 = LO(address) of STA (P),Y in DRAW_BYTE 36

\ ******************************************************************************
\
\       Name: dashData1
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData1

 SKIP 52                \ Populated with code from &7F98 to &7FCB

\ ******************************************************************************
\
\       Name: ldaDrawByte
\       Type: Variable
\   Category: Graphics
\    Summary: Low address bytes of the LDA #0 instructions in the DRAW_BYTE
\             macros, for use when drawing track lines around the dashboard
\
\ ******************************************************************************

.ldaDrawByte

IF _ACORNSOFT

 EQUB &1C               \ Line 0 is unused and contains workspace noise

ELIF _SUPERIOR

 EQUB &28               \ Line 0 is unused and contains workspace noise

ENDIF

 EQUB 8 * 17 + 5        \ Line  1 = LO(address) of LDA #0 in DRAW_BYTE 34
 EQUB 7 * 17 + 5        \ Line  2 = LO(address) of LDA #0 in DRAW_BYTE 33
 EQUB 7 * 17 + 5        \ Line  3 = LO(address) of LDA #0 in DRAW_BYTE 33
 EQUB 7 * 17 + 5        \ Line  4 = LO(address) of LDA #0 in DRAW_BYTE 33
 EQUB 7 * 17 + 5        \ Line  5 = LO(address) of LDA #0 in DRAW_BYTE 33
 EQUB 7 * 17 + 5        \ Line  6 = LO(address) of LDA #0 in DRAW_BYTE 33
 EQUB 6 * 17 + 5        \ Line  7 = LO(address) of LDA #0 in DRAW_BYTE 32
 EQUB 6 * 17 + 5        \ Line  8 = LO(address) of LDA #0 in DRAW_BYTE 32
 EQUB 6 * 17 + 5        \ Line  9 = LO(address) of LDA #0 in DRAW_BYTE 32
 EQUB 6 * 17 + 5        \ Line 10 = LO(address) of LDA #0 in DRAW_BYTE 32
 EQUB 6 * 17 + 5        \ Line 11 = LO(address) of LDA #0 in DRAW_BYTE 32
 EQUB 5 * 17 + 5        \ Line 12 = LO(address) of LDA #0 in DRAW_BYTE 31
 EQUB 5 * 17 + 5        \ Line 13 = LO(address) of LDA #0 in DRAW_BYTE 31
 EQUB 5 * 17 + 5        \ Line 14 = LO(address) of LDA #0 in DRAW_BYTE 31
 EQUB 5 * 17 + 5        \ Line 15 = LO(address) of LDA #0 in DRAW_BYTE 31
 EQUB 4 * 17 + 5        \ Line 16 = LO(address) of LDA #0 in DRAW_BYTE 30
 EQUB 4 * 17 + 5        \ Line 17 = LO(address) of LDA #0 in DRAW_BYTE 30
 EQUB 4 * 17 + 5        \ Line 18 = LO(address) of LDA #0 in DRAW_BYTE 30
 EQUB 4 * 17 + 5        \ Line 19 = LO(address) of LDA #0 in DRAW_BYTE 30
 EQUB 3 * 17 + 5        \ Line 20 = LO(address) of LDA #0 in DRAW_BYTE 29
 EQUB 3 * 17 + 5        \ Line 21 = LO(address) of LDA #0 in DRAW_BYTE 29
 EQUB 3 * 17 + 5        \ Line 22 = LO(address) of LDA #0 in DRAW_BYTE 29
 EQUB 3 * 17 + 5        \ Line 23 = LO(address) of LDA #0 in DRAW_BYTE 29
 EQUB 2 * 17 + 5        \ Line 24 = LO(address) of LDA #0 in DRAW_BYTE 28
 EQUB 2 * 17 + 5        \ Line 25 = LO(address) of LDA #0 in DRAW_BYTE 28
 EQUB 2 * 17 + 5        \ Line 26 = LO(address) of LDA #0 in DRAW_BYTE 28
 EQUB 2 * 17 + 5        \ Line 27 = LO(address) of LDA #0 in DRAW_BYTE 28
 EQUB 1 * 17 + 5        \ Line 28 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 29 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 30 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 31 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 32 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 33 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 34 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 35 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 36 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 37 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 1 * 17 + 5        \ Line 38 = LO(address) of LDA #0 in DRAW_BYTE 27
 EQUB 0 * 17 + 5        \ Line 39 = LO(address) of LDA #0 in DRAW_BYTE 26
 EQUB 0 * 17 + 5        \ Line 40 = LO(address) of LDA #0 in DRAW_BYTE 26
 EQUB 0 * 17 + 5        \ Line 41 = LO(address) of LDA #0 in DRAW_BYTE 26
 EQUB 0 * 17 + 5        \ Line 42 = LO(address) of LDA #0 in DRAW_BYTE 26
 EQUB 0 * 17 + 5        \ Line 43 = LO(address) of LDA #0 in DRAW_BYTE 26

\ ******************************************************************************
\
\       Name: L30FC
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L30FC

 EQUB &10, &00, &00, &10

\ ******************************************************************************
\
\       Name: handPixels
\       Type: Variable
\   Category: Graphics
\    Summary: The number of pixels in the longest axis for the rev counter hand
\             at various points in a half-quadrant
\
\ ------------------------------------------------------------------------------
\
\ This table contains values that are used to calculate the coordinates of the
\ end of the hand in the rev counter.
\
\ The contents of the table are very close to the following (the values from
\ the following calculation are shown in the comments below - they are close,
\ but not quite a perfect match, so I haven't got this exactly right):
\
\ FOR I%, 0, 21
\  EQUB INT(0.5 + 28 * COS((PI / 4) * I% / 21))
\ NEXT
\
\ This gives the length of the adjacent side of a right-angled triangle, with a
\ hypoteneuse of length 28, and an angle ranging from 0 to PI/4 (i.e. one
\ eighth of a circle), split up into 21 points per eighth of a circle.
\
\ In other words, if we have a clock whose centre is at the origin, then this
\ table contains the x-coordinate of the end of a clock hand of length 28 as it
\ moves from 3 o'clock to half past 4.
\
\ ******************************************************************************

.handPixels

 EQUB 28                \ INT(0.5 + 28.00) = 28
 EQUB 28                \ INT(0.5 + 27.98) = 28
 EQUB 28                \ INT(0.5 + 27.92) = 28
 EQUB 28                \ INT(0.5 + 27.82) = 28
 EQUB 28                \ INT(0.5 + 27.69) = 28
 EQUB 27                \ INT(0.5 + 27.51) = 28 (doesn't match)
 EQUB 27                \ INT(0.5 + 27.30) = 27
 EQUB 27                \ INT(0.5 + 27.05) = 27
 EQUB 27                \ INT(0.5 + 26.76) = 27
 EQUB 26                \ INT(0.5 + 26.43) = 26
 EQUB 26                \ INT(0.5 + 26.06) = 26
 EQUB 26                \ INT(0.5 + 25.66) = 26
 EQUB 25                \ INT(0.5 + 25.23) = 25
 EQUB 25                \ INT(0.5 + 24.76) = 25
 EQUB 24                \ INT(0.5 + 24.25) = 24
 EQUB 24                \ INT(0.5 + 23.71) = 24
 EQUB 23                \ INT(0.5 + 23.13) = 23
 EQUB 22                \ INT(0.5 + 22.53) = 23 (doesn't match)
 EQUB 21                \ INT(0.5 + 21.89) = 22 (doesn't match)
 EQUB 20                \ INT(0.5 + 21.22) = 21 (doesn't match)
 EQUB 20                \ INT(0.5 + 20.53) = 21 (doesn't match)
 EQUB 20                \ INT(0.5 + 19.80) = 20

 EQUB &81, &81, &81     \ These bytes appear to be unused
 EQUB &81, &81, &81

\ ******************************************************************************
\
\       Name: dashData2
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData2

 SKIP 52                \ Populated with code from &7F64 to &7F97

\ ******************************************************************************
\
\       Name: staDrawByte
\       Type: Variable
\   Category: Graphics
\    Summary: Low address bytes of the STA instructions in the DRAW_BYTE macros,
\             for use when drawing track lines around the dashboard
\
\ ******************************************************************************

.staDrawByte

 EQUB  3 * 17 + 15      \ Line  0 = LO(address) of STA (P),Y in DRAW_BYTE  3
 EQUB  5 * 17 + 15      \ Line  1 = LO(address) of STA (P),Y in DRAW_BYTE  5
 EQUB  6 * 17 + 15      \ Line  2 = LO(address) of STA (P),Y in DRAW_BYTE  6
 EQUB  6 * 17 + 15      \ Line  3 = LO(address) of STA (P),Y in DRAW_BYTE  6
 EQUB  6 * 17 + 15      \ Line  4 = LO(address) of STA (P),Y in DRAW_BYTE  6
 EQUB  6 * 17 + 15      \ Line  5 = LO(address) of STA (P),Y in DRAW_BYTE  6
 EQUB  6 * 17 + 15      \ Line  6 = LO(address) of STA (P),Y in DRAW_BYTE  6
 EQUB  7 * 17 + 15      \ Line  7 = LO(address) of STA (P),Y in DRAW_BYTE  7
 EQUB  7 * 17 + 15      \ Line  8 = LO(address) of STA (P),Y in DRAW_BYTE  7
 EQUB  7 * 17 + 15      \ Line  9 = LO(address) of STA (P),Y in DRAW_BYTE  7
 EQUB  7 * 17 + 15      \ Line 10 = LO(address) of STA (P),Y in DRAW_BYTE  7
 EQUB  7 * 17 + 15      \ Line 11 = LO(address) of STA (P),Y in DRAW_BYTE  7
 EQUB  8 * 17 + 15      \ Line 12 = LO(address) of STA (P),Y in DRAW_BYTE  8
 EQUB  8 * 17 + 15      \ Line 13 = LO(address) of STA (P),Y in DRAW_BYTE  8
 EQUB  8 * 17 + 15      \ Line 14 = LO(address) of STA (P),Y in DRAW_BYTE  8
 EQUB  8 * 17 + 15      \ Line 15 = LO(address) of STA (P),Y in DRAW_BYTE  8
 EQUB  9 * 17 + 15      \ Line 16 = LO(address) of STA (P),Y in DRAW_BYTE  9
 EQUB  9 * 17 + 15      \ Line 17 = LO(address) of STA (P),Y in DRAW_BYTE  9
 EQUB  9 * 17 + 15      \ Line 18 = LO(address) of STA (P),Y in DRAW_BYTE  9
 EQUB  9 * 17 + 15      \ Line 19 = LO(address) of STA (P),Y in DRAW_BYTE  9
 EQUB 10 * 17 + 15      \ Line 20 = LO(address) of STA (P),Y in DRAW_BYTE 10
 EQUB 10 * 17 + 15      \ Line 21 = LO(address) of STA (P),Y in DRAW_BYTE 10
 EQUB 10 * 17 + 15      \ Line 22 = LO(address) of STA (P),Y in DRAW_BYTE 10
 EQUB 10 * 17 + 15      \ Line 23 = LO(address) of STA (P),Y in DRAW_BYTE 10
 EQUB 11 * 17 + 15      \ Line 24 = LO(address) of STA (P),Y in DRAW_BYTE 11
 EQUB 11 * 17 + 15      \ Line 25 = LO(address) of STA (P),Y in DRAW_BYTE 11
 EQUB 11 * 17 + 15      \ Line 26 = LO(address) of STA (P),Y in DRAW_BYTE 11
 EQUB 11 * 17 + 15      \ Line 27 = LO(address) of STA (P),Y in DRAW_BYTE 11
 EQUB 12 * 17 + 15      \ Line 28 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 29 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 30 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 31 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 32 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 33 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 34 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 35 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 36 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 37 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 12 * 17 + 15      \ Line 38 = LO(address) of STA (P),Y in DRAW_BYTE 12
 EQUB 13 * 17 + 15      \ Line 39 = LO(address) of STA (P),Y in DRAW_BYTE 13
 EQUB 13 * 17 + 15      \ Line 40 = LO(address) of STA (P),Y in DRAW_BYTE 13
 EQUB 13 * 17 + 15      \ Line 41 = LO(address) of STA (P),Y in DRAW_BYTE 13
 EQUB 13 * 17 + 15      \ Line 42 = LO(address) of STA (P),Y in DRAW_BYTE 13
 EQUB 13 * 17 + 15      \ Line 43 = LO(address) of STA (P),Y in DRAW_BYTE 13

 EQUB &28, &28          \ These bytes appear to be unused
 EQUB &00, &00
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData3
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData3

 SKIP 58                \ Populated with code from &7F2A to &7F63

\ ******************************************************************************
\
\       Name: DrawFence (Part 2 of 2)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the fence that we crash into when running off the track
\
\ ******************************************************************************

.fenc2

 LDX #3                 \ Set X = 3, to use as an index into the fencePixelsSky
                        \ and fencePixelsGrass tables, so we draw pixel bytes
                        \ repeatedly from these two tables to build up the fence
                        \ effect

.fenc3

 CPY horizonLine        \ If Y < horizonLine, then this pixel row is below the
 BCC fenc4              \ horizon, so jump to fenc4 to draw the fence with green
                        \ grass behind it

 LDA fencePixelsSky,X   \ Otherwise this pixel row is above the horizon, so set
                        \ A to the correct pixel byte for the fence with blue
                        \ sky behind it

 BNE fenc5              \ Jump to fenc5 (this BNE is effectively a JMP as A is
                        \ never zero)

.fenc4

 LDA fencePixelsGrass,X \ Set A to the correct pixel byte for the fence with
                        \ green grass behind it

.fenc5

 STA (P),Y              \ Store A in the dash data block at (Q P), to draw this
                        \ four-pixel part of the fence in the track view

 STA tyreRightEdge,Y    \ Store A in the tyreRightEdge and dashRightEdge
 STA dashRightEdge,Y    \ entries for this row, so the drawing routines can wrap
                        \ the fence correctly around the dashboard and tyres

 DEX                    \ Decrement X to point to the next pixel byte in the
                        \ fence pixel byte tables

 BPL fenc6              \ If we just decremented X to -1, set it back to 3, so
 LDX #3                 \ X goes 3, 2, 1, 0, then 3, 2, 1, 0, and so on

.fenc6

 DEY                    \ Decrement the byte counter in Y to point to the next
                        \ byte in the dash data block

 CPY U                  \ If Y <> U then we have not yet drawn the fence in all
 BNE fenc3              \ the bytes in the dash data block (as U contains the
                        \ dashDataOffset for this block, which contains the
                        \ offset of the last byte that we need to fill), so loop
                        \ back to draw the next byte of the fence

                        \ If we get here then we have drawn fence through the
                        \ whole dash data block, so now we move on to the next
                        \ block by updating the counter in T and pointing (Q P)
                        \ to the next dash data block

 INC T                  \ Increment the loop counter to point to the next dash
                        \ data block

 LDA P                  \ Set (Q P) = (Q P) + &80
 EOR #&80               \
 STA P                  \ starting with the low bytes
                        \
                        \ We can do the addition more efficiently by using EOR
                        \ to flip between &xx00 and &xx80, as the dash data
                        \ blocks always start at these addresses

 BMI fenc7              \ We then increment the high byte, but only if the EOR
 INC Q                  \ set the low byte to &00 rather than &80 (if we just
                        \ set it to the latter, the BMI will skip the INC)

.fenc7

 JMP fenc1              \ Loop back to part 1 to draw the fence in the next dash
                        \ data block

 EQUB 0                 \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: token18
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 18
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token18

 EQUS " 5"              \ Print " 5"

 EQUB 255               \ End token

 EQUB &81               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: dashData4
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData4

 SKIP 76                \ Populated with code from &7EDE to &7F29

\ ******************************************************************************
\
\       Name: PrintDriverName
\       Type: Subroutine
\   Category: Text
\    Summary: Print a driver's name
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (Y A)               Address of 12-character driver name
\
\ ******************************************************************************

.PrintDriverName

 STY S                  \ Set (S R) = (Y A)
 STA R

 LDY #0                 \ Set a character counter in Y

.name1

 LDA (R),Y              \ Set A to the Y-th character from (S R)

 JSR PrintCharacter     \ Print the character in A

 INY                    \ Increment the character counter

 CPY #12                \ Loop back to print the next character until we have
 BNE name1              \ printed all 12 characters

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CheckRestartKeys
\       Type: Subroutine
\   Category: Keyboard
\    Summary: If the restart keys are being pressed, restart the game
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   RestartGame         Restart the game, putting the C flag into bit 7 of
\                       pressingShiftArrow
\
\ ******************************************************************************

.CheckRestartKeys

 LDX #&FF               \ Scan the keyboard to see if SHIFT is being pressed
 JSR ScanKeyboard

 BNE rest1              \ If SHIFT is not being pressed, jump to rest1

 LDX #&86               \ Scan the keyboard to see if right arrow is being
 JSR ScanKeyboard       \ pressed (if it is this will also set the C flag)

 BNE rest1              \ If right arrow is not being pressed, jump to rest1

 BIT pressingShiftArrow \ If bit 7 of pressingShiftArrow is set, then we are
 BMI rest2              \ still pressing Shift-arrow from a previous restart, so
                        \ jump to rest2 to return from the subroutine without
                        \ anything doing

                        \ If we get here then SHIFT-arrow is being pressed and
                        \ bit 7 of pressingShiftArrow is clear, so this is a
                        \ new pressing SHIFT-arrow, so we fall through into
                        \ RestartGame with the C flag set to restart the game
                        \ and set bit 7 of pressingShiftArrow

.RestartGame

 LDX startingStack      \ Set the stack pointer to the value it had when the
 TXS                    \ game started, which clears any stored addresses put on
                        \ the stack by the code we are now exiting from

 ROR pressingShiftArrow \ Shift the C flag into bit 7 of pressingShiftArrow

 JMP MainLoop           \ Jump to the start of the main gane loop to restart the
                        \ game

.rest1

 LSR pressingShiftArrow \ Clear bit 7 of pressingShiftArrow to indicate that we
                        \ are no longer pressing SHIFT-arrow

.rest2

 RTS                    \ Return from the subroutine

 EQUB 0, 0              \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: token19
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 19
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token19

 EQUS "10"              \ Print "10"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData5
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData5

 SKIP 77                \ Populated with code from &7E91 to &7EDD

\ ******************************************************************************
\
\       Name: GetNumberFromText
\       Type: Subroutine
\   Category: Text
\    Summary: Convert a two-digit string into a number
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   T                   The first digit of the number, as text
\
\   U                   The second digit of the number, as text
\
\ Returns:
\
\   A                   The numerical value of the number
\
\   C flag              The status of the conversion:
\
\                         * Clear if the string is a valid number and A <= 40
\
\                         * Set if string is not a valid number, or A > 40
\
\ ******************************************************************************

.GetNumberFromText

 LDA T                  \ Set A to the character containing the first digit

 CMP #' '               \ If the first digit is not a space, skip the following
 BNE tnum1              \ instruction

 LDA #'0'               \ The first digit is a space, so convert it to a "0"

.tnum1

 SEC                    \ Subtract the ASCII value for "0" to get the numerical
 SBC #'0'               \ value of the first digit into A

 CMP #10                \ If the value of the first digit is greater than 10,
 BCS tnum2              \ then this is not a valid number, so jump to tnum2 to
                        \ return from the subroutine with the C flag set, to
                        \ indicate an error

 STA T                  \ Set T = the value of the first digit

 LDX U                  \ Set X to the character containing the second digit

 CPX #' '               \ If the second digit is a space, then jump to tnum2 to
 CLC                    \ return from the subroutine with the value of the first
 BEQ tnum2              \ digit in A and the C flag clear, to indicate success

 ASL A                  \ Set T = (A << 2 + T) << 1
 ASL A                  \       = (A * 4 + A) * 2
 ADC T                  \       = 10 * A
 ASL A                  \
 STA T                  \ So T contains 10 * the numerical value of the first
                        \ digit

 TXA                    \ Set A to the character containing the second digit

 SEC                    \ Subtract the ASCII value for "0" to get the numerical
 SBC #'0'               \ value of the second digit

 CMP #10                \ If the value of the second digit is greater than 10,
 BCS tnum2              \ then this is not a valid number, so jump to tnum2 to
                        \ return from the subroutine with the C flag set, to
                        \ indicate an error

 ADC T                  \ Set A = A + T
                        \       = the numerical value of the second digit
                        \         + 10 * the numerical value of the first digit
                        \
                        \ which is the numerical value of the two-digit string

 CMP #41                \ If A < 41, clear the C flag, otherwise set it

.tnum2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: startDialLo
\       Type: Variable
\   Category: Dashboard
\    Summary: The low byte of the screen address of the start of the dial hand
\             on the rev counter
\
\ ******************************************************************************

.startDialLo

 EQUB &66               \ Quadrant 0 (12:00 to 3:00) = &7566
 EQUB &67               \ Quadrant 1 (3:00 to 6:00)  = &7567
 EQUB &5F               \ Quadrant 2 (6:00 to 9:00)  = &755F
 EQUB &5E               \ Quadrant 3 (9:00 to 12:00) = &755E

\ ******************************************************************************
\
\       Name: token20
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 20
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token20

 EQUS "20"              \ Print "20"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData6
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData6

 SKIP 77                \ Populated with code from &7E44 to &7E90

\ ******************************************************************************
\
\       Name: leftDashPixels
\       Type: Variable
\   Category: Graphics
\    Summary: Pixels along the left edge of the dashboard
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a pixel byte for the white border (colour 2) along the left edge of
\ the dashboard.

\ There is a byte for each track line from 43 (the track line at the top of the
\ dashboard) down to 3 (the lowest track line, just above where the wing mirror
\ joins the car body). Lines 0 to 2 are not used.
\
\ Each pixel is a colour 2 pixel, so the high nibble contains a 1 and the low
\ nibble contains a 0, to give colour %10. Colour 2 is mapped to white at this
\ point of the custom screen.
\
\ ******************************************************************************

.leftDashPixels

 EQUB %00000000         \ Line  0
 EQUB %00000000         \ Line  1
 EQUB %11110000         \ Line  2
 EQUB %01110000         \ Line  3
 EQUB %00110000         \ Line  4
 EQUB %00010000         \ Line  5
 EQUB %00000000         \ Line  6
 EQUB %01110000         \ Line  7
 EQUB %01110000         \ Line  8
 EQUB %00110000         \ Line  9
 EQUB %00010000         \ Line 10
 EQUB %00000000         \ Line 11
 EQUB %01110000         \ Line 12
 EQUB %00110000         \ Line 13
 EQUB %00010000         \ Line 14
 EQUB %00000000         \ Line 15
 EQUB %01110000         \ Line 16
 EQUB %00110000         \ Line 17
 EQUB %00010000         \ Line 18
 EQUB %00000000         \ Line 19
 EQUB %01110000         \ Line 20
 EQUB %00110000         \ Line 21
 EQUB %00010000         \ Line 22
 EQUB %00000000         \ Line 23
 EQUB %01110000         \ Line 24
 EQUB %00110000         \ Line 25
 EQUB %00010000         \ Line 26
 EQUB %00000000         \ Line 27
 EQUB %01110000         \ Line 28
 EQUB %01000000         \ Line 29
 EQUB %00110000         \ Line 30
 EQUB %00100000         \ Line 31
 EQUB %00110000         \ Line 32
 EQUB %00010000         \ Line 33
 EQUB %00010000         \ Line 34
 EQUB %00010000         \ Line 35
 EQUB %00000000         \ Line 36
 EQUB %00000000         \ Line 37
 EQUB %00000000         \ Line 38
 EQUB %01000000         \ Line 39
 EQUB %01110000         \ Line 40
 EQUB %01000000         \ Line 41
 EQUB %00110000         \ Line 42
 EQUB %00110000         \ Line 43

\ ******************************************************************************
\
\       Name: pixelsToLeft
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel byte with all the pixels to the left of position X set
\
\ ******************************************************************************

.pixelsToLeft

 EQUB %00000000
 EQUB %10001000
 EQUB %11001100
 EQUB %11101110

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData7
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData7

 SKIP 73                \ Populated with code from &7DFB to &7E43

\ ******************************************************************************
\
\       Name: rightDashPixels
\       Type: Variable
\   Category: Graphics
\    Summary: Pixels along the right edge of the dashboard
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a pixel byte for the white border (colour 2) along the right edge of
\ the dashboard.
\
\ There is a byte for each track line from 43 (the track line at the top of the
\ dashboard) down to 3 (the lowest track line, just above where the wing mirror
\ joins the car body). Lines 0 to 2 are not used.
\
\ Each pixel is a colour 2 pixel, so the high nibble contains a 1 and the low
\ nibble contains a 0, to give colour %10. Colour 2 is mapped to white at this
\ point of the custom screen.
\
\ ******************************************************************************

.rightDashPixels

 EQUB %00000000         \ Line  0
 EQUB %00000000         \ Line  1
 EQUB %11110000         \ Line  2
 EQUB %11100000         \ Line  3
 EQUB %11000000         \ Line  4
 EQUB %10000000         \ Line  5
 EQUB %00000000         \ Line  6
 EQUB %11100000         \ Line  7
 EQUB %11100000         \ Line  8
 EQUB %11000000         \ Line  9
 EQUB %10000000         \ Line 10
 EQUB %00000000         \ Line 11
 EQUB %11100000         \ Line 12
 EQUB %11000000         \ Line 13
 EQUB %10000000         \ Line 14
 EQUB %00000000         \ Line 15
 EQUB %11100000         \ Line 16
 EQUB %11000000         \ Line 17
 EQUB %10000000         \ Line 18
 EQUB %00000000         \ Line 19
 EQUB %11100000         \ Line 20
 EQUB %11000000         \ Line 21
 EQUB %10000000         \ Line 22
 EQUB %00000000         \ Line 23
 EQUB %11100000         \ Line 24
 EQUB %11000000         \ Line 25
 EQUB %10000000         \ Line 26
 EQUB %00000000         \ Line 27
 EQUB %11100000         \ Line 28
 EQUB %00100000         \ Line 29
 EQUB %11000000         \ Line 30
 EQUB %01000000         \ Line 31
 EQUB %11000000         \ Line 32
 EQUB %10000000         \ Line 33
 EQUB %10000000         \ Line 34
 EQUB %10000000         \ Line 35
 EQUB %00000000         \ Line 36
 EQUB %00000000         \ Line 37
 EQUB %00000000         \ Line 38
 EQUB %00100000         \ Line 39
 EQUB %11100000         \ Line 40
 EQUB %00100000         \ Line 41
 EQUB %11000000         \ Line 42
 EQUB %11000000         \ Line 43

\ ******************************************************************************
\
\       Name: pixelsEdgeRight
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel byte with all the pixels to the right of position X set,
\             plus pixel X
\
\ ******************************************************************************

.pixelsEdgeRight

 EQUB %11111111
 EQUB %01110111
 EQUB %00110011
 EQUB %00010001

\ ******************************************************************************
\
\       Name: token11
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 11
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token11

 EQUS "ENTER "          \ Print "ENTER "

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData8
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData8

 SKIP 68                \ Populated with code from &7DB7 to &7DFA

\ ******************************************************************************
\
\       Name: Absolute8Bit
\       Type: Subroutine
\   Category: Maths
\    Summary: Calculate the absolute value (modulus) of an 8-bit number
\
\ ------------------------------------------------------------------------------
\
\ This routine returns |A|.
\
\ It can also return A * abs(n), where A is given the sign of n.
\
\ Arguments:
\
\   A                   The number to make positive
\
\   N flag              Controls the sign to be applied:
\
\                         * If we want to calculate |A|, do an LDA or equivalent
\                           before calling the routine
\
\                         * If we want to calculate A * abs(n), do a BIT n
\                           before calling the routine
\
\                         * If we want to set the sign of A, then call with:
\
\                           * N flag clear to calculate A * 1
\
\                           * N flag set to calculate A * -1
\
\ ******************************************************************************

.Absolute8Bit

 BPL aval1              \ If A is positive then it already contains its absolute
                        \ value, so jump to aval1 to return from the subroutine

 EOR #&FF               \ Negate the value in A using two's complement, as the
 CLC                    \ following is true when A is negative:
 ADC #1                 \
                        \   |A| = -A
                        \       = ~A + 1

.aval1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: paletteSection2
\       Type: Variable
\   Category: Screen mode
\    Summary: Colour palette for screen section 2 in the custom screen mode
\             (part of the mode 5 portion)
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ------------------------------------------------------------------------------
\
\ Palette data is given as a set of bytes, with each byte mapping a logical
\ colour to a physical one. In each byte, the logical colour is given in bits
\ 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
\ for details of how palette mapping works, as in modes 4 and 5 we have to do
\ multiple palette commands to change the colours correctly, and the physical
\ colour value is EOR'd with 7, just to make things even more confusing.
\
\ Each of these mappings requires six calls to SHEILA &21 - see p.379 of the
\ Advanced User Guide for an explanation.
\
\ ******************************************************************************

.paletteSection2

 EQUB &07, &17          \ Map logical colour 0 to physical colour 0 (black)
 EQUB &47, &57

 EQUB &23, &33          \ Map logical colour 1 to physical colour 4 (blue)
 EQUB &63, &73

 EQUB &80, &90          \ Map logical colour 2 to physical colour 7 (white)
 EQUB &C0, &D0

 EQUB &A5, &B5          \ Map logical colour 3 to physical colour 2 (green)
 EQUB &E5, &F5

\ ******************************************************************************
\
\       Name: paletteSection0
\       Type: Variable
\   Category: Screen mode
\    Summary: Colour palette for screen section 0 in the custom screen mode (the
\             mode 4 portion)
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.paletteSection0

 EQUB &03, &13          \ Map logical colour 0 to physical colour 4 (blue)
 EQUB &23, &33
 EQUB &43, &53
 EQUB &63, &73

 EQUB &84, &94          \ Map logical colour 1 to physical colour 3 (yellow)
 EQUB &A4, &B4
 EQUB &C4, &D4
 EQUB &E4, &F4

\ ******************************************************************************
\
\       Name: paletteSection3
\       Type: Variable
\   Category: Screen mode
\    Summary: Colour palette for screen section 3 in the custom screen mode
\             (part of the mode 5 portion)
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.paletteSection3

 EQUB &26, &36          \ Map logical colour 1 to physical colour 1 (red)
 EQUB &66, &76

\ ******************************************************************************
\
\       Name: paletteSection4
\       Type: Variable
\   Category: Screen mode
\    Summary: Colour palette for screen section 4 in the custom screen mode
\             (part of the mode 5 portion)
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.paletteSection4

 EQUB &A1, &B1          \ Map logical colour 3 to physical colour 6 (cyan)
 EQUB &E1, &F1

\ ******************************************************************************
\
\       Name: token25
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 25
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token25

 EQUB 31, 13, 18        \ Move text cursor to column 13, row 18

 EQUS "front"           \ Print "front"

 EQUB 160 + 2           \ Print 2 spaces

 EQUB 133               \ Set foreground colour to magenta alphanumeric

 EQUB 200 + 16          \ Print token 16 (" > ")

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData9
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData9

 SKIP 64                \ Populated with code from &7D77 to &7DB6

\ ******************************************************************************
\
\       Name: WaitForSpace
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Print a prompt, wait for the SPACE key to be released, and wait
\             for SPACE to be pressed
\
\ ******************************************************************************

.WaitForSpace

 LDA #0                 \ Set A = 0 so WaitForSpaceReturn waits for SPACE to be
                        \ pressed

                        \ Fall through into WaitForSpaceReturn to print the
                        \ prompt, wait for the SPACE key to be released, and
                        \ wait for SPACE to be pressed

\ ******************************************************************************
\
\       Name: WaitForSpaceReturn
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Print a prompt, wait for the SPACE key to be released, and wait
\             for either SPACE or RETURN to be pressed
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Determines the key to wait for:
\
\                         * Bit 7 clear = wait for SPACE to be pressed
\
\                         * Bit 7 set = wait for SPACE or RETURN to be pressed
\
\ Returns:
\
\   G                   If bit 7 was set on entry, then it is cleared if RETURN
\                       was pressed, but remains set if SPACE was pressed
\
\ ******************************************************************************

.WaitForSpaceReturn

 STA G                  \ Store A in G so we can check the value of bit 7 below

 LDX #30                \ Print token 30 ("PRESS SPACE BAR TO CONTINUE" in cyan
 JSR PrintToken         \ at column 5, row 24)

.wait1

 LDX #&9D               \ Scan the keyboard to see if SPACE is being pressed
 JSR ScanKeyboard

 BEQ wait1              \ If SPACE is being pressed, loop back to wait1 until
                        \ it is released

.wait2

 LDX #&9D               \ Scan the keyboard to see if SPACE is being pressed
 JSR ScanKeyboard

 BEQ wait3              \ If SPACE is being pressed, jump to wait3 to return
                        \ from the subroutine

 JSR CheckRestartKeys   \ Check whether the restart keys are being pressed, and
                        \ if they are, restart the game (the restart keys are
                        \ SHIFT and right arrow)

 BIT G                  \ If bit 7 of G is clear, jump back to wait2 to wait for
 BPL wait2              \ SPACE to be pressed

 LDX #&B6               \ Scan the keyboard to see if RETURN is being pressed
 JSR ScanKeyboard

 BNE wait2              \ If RETURN is not being pressed, jump back to wait2 to
                        \ wait for RETURN is being pressed

 LSR G                  \ Clear bit 7 of G

.wait3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: pixelByte
\       Type: Variable
\   Category: Graphics
\    Summary: A table of pixel bytes with individual pixels set
\
\ ******************************************************************************

.pixelByte

 EQUB %10000000         \ Pixel byte with the first pixel set to colour 2
 EQUB %01000000         \ Pixel byte with the second pixel set to colour 2
 EQUB %00100000         \ Pixel byte with the third pixel set to colour 2
 EQUB %00010000         \ Pixel byte with the fourth pixel set to colour 2

 EQUB %00000000         \ Pixel byte with the first pixel set to colour 0
 EQUB %00000000         \ Pixel byte with the second pixel set to colour 0
 EQUB %00000000         \ Pixel byte with the third pixel set to colour 0
 EQUB %00000000         \ Pixel byte with the fourth pixel set to colour 0

\ ******************************************************************************
\
\       Name: token8
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 8
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token8

 EQUS "Amateur"         \ Print "Amateur"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token51
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 51
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token51

 EQUS " POINTS"         \ Print " POINTS"

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData10
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData10

 SKIP 60                \ Populated with code from &7D3B to &7D76

\ ******************************************************************************
\
\       Name: objectTop
\       Type: Variable
\   Category: 3D objects
\    Summary: Scaffold measurements for the top of each object part
\  Deep dive: Object definitions
\             Scaling objects with scaffolds
\
\ ------------------------------------------------------------------------------
\
\ Entries contain indexes into the scaledScaffold table. n + 8 points to the
\ negative value of n (as scaledScaffold+8 is filled with the negative of
\ scaledScaffold).
\
\ ******************************************************************************

.objectTop

 EQUB 7 + 8             \ Object 0, Part 0: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-4, -5, -22, -18)

 EQUB 7 + 8             \ Object 0, Part 1: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-4, -5, 18, 22)

 EQUB 6 + 8             \ Object 0, Part 2: Scaffolds: (-6, -3, -0, -4)
                        \                   Coordinates: (-5, -17, -24, -16)

 EQUB 6 + 8             \ Object 0, Part 3: Scaffolds: (-6, -3, 4, 0)
                        \                   Coordinates: (-5, -17, 16, 24)

 EQUB 5 + 8             \ Object 0, Part 4: Scaffolds: (-5, -3, -2, 2)
                        \                   Coordinates: (-8, -17, -18, 18)


 EQUB 5                 \ Object 1, Part 0: Scaffolds: (5, 6, -5, 5)
                        \                   Coordinates: (5, 2, -5, 5)

 EQUB 6                 \ Object 1, Part 1: Scaffolds: (6, -7, -3, 3)
                        \                   Coordinates: (2, -1, -8, 8)

 EQUB 7 + 8             \ Object 1, Part 2: Scaffolds: (-7, -5, -1, 1)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 4                 \ Object 1, Part 3: Scaffolds: (4, 5, -6, 6)
                        \                   Coordinates: (6, 5, -2, 2)


 EQUB 6 + 8             \ Object 2, Part 0: Scaffolds: (-6, -5, -0, -4)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 0                 \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 5 + 8             \ Object 2, Part 2: Scaffolds: (-5, -3, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 7 + 8             \ Object 2, Part 3: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-2, -3, -24, -18)

 EQUB 7 + 8             \ Object 2, Part 4: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-2, -3, 18, 24)


 EQUB 2                 \ Object 3, Part 0: Scaffolds: (2, 3, -0, 0)
                        \                   Coordinates: (6, 4, -16, 16)

 EQUB 3                 \ Object 3, Part 1: Scaffolds: (3, 4, -0, 0)
                        \                   Coordinates: (4, 3, -16, 16)

 EQUB 4                 \ Object 3, Part 2: Scaffolds: (4, -1, -5, 5)
                        \                   Coordinates: (3, -10, -1, 1)

 EQUB 1 + 8             \ Object 3, Part 3: Scaffolds: (-1, -0, -5, 5)
                        \                   Coordinates: (-10, -16, -1, 1)


 EQUB 6                 \ Object 4, Part 0: Scaffolds: (6, -7, -4, 4)
                        \                   Coordinates: (3, -1, -6, 6)

 EQUB 7 + 8             \ Object 4, Part 1: Scaffolds: (-7, -5, -3, 3)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 6 + 8             \ Object 4, Part 2: Scaffolds: (-6, -5, -0, -2)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 0                 \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 5 + 8             \ Object 4, Part 4: Scaffolds: (-5, -1, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 7                 \ Object 4, Part 5: Scaffolds: (7, -5, -7, 7)
                        \                   Coordinates: (1, -5, -1, 1)

 EQUB 4                 \ Object 4, Part 6: Scaffolds: (4, 6, -2, 2)
                        \                   Coordinates: (6, 3, -16, 16)


 EQUB 2 + 8             \ Object 5, Part 0: Scaffolds: (-2, -1, -0, 0)
                        \                   Coordinates: (-3, -17, -26, 26)


 EQUB 0                 \ Object 6, Part 0: Scaffolds: (0, 2, -1, 1)
                        \                   Coordinates: (16, 1, -10, 10)


 EQUB 1                 \ Object 7, Part 0: Scaffolds: (1, -4, -0, 0)
                        \                   Coordinates: (20, -8, -28, 28)

 EQUB 4 + 8             \ Object 7, Part 1: Scaffolds: (-4, -2, -1, -3)
                        \                   Coordinates: (-8, -18, -20, -16)

 EQUB 4 + 8             \ Object 7, Part 2: Scaffolds: (-4, -2, 3, 1)
                        \                   Coordinates: (-8, -18, 16, 20)


 EQUB 2                 \ Object 8, Part 0: Scaffolds: (2, -0, -3, 3)
                        \                   Coordinates: (3, -18, -2, 2)

 EQUB 1                 \ Object 8, Part 1: Scaffolds: (1, 2, -3, 1)
                        \                   Coordinates: (16, 3, -2, 16)


 EQUB 1                 \ Object 9, Part 0: Scaffolds: (1, -2, -0, 0)
                        \                   Coordinates: (12, -10, -16, 16)

 EQUB 2 + 8             \ Object 9, Part 1: Scaffolds: (-2, -0, -3, 3)
                        \                   Coordinates: (-10, -16, -3, 3)


 EQUB 3                 \ Object 10, Part 0: Scaffolds: (3, 4, -0, 0)
                        \                    Coordinates: (4, 1, -10, 10)

 EQUB 4                 \ Object 10, Part 1: Scaffolds: (4, -2, -0, -1)
                        \                    Coordinates: (1, -6, -10, -9)

 EQUB 0                 \ Object 10, Part 2: Scaffolds: (0, 3, 1, 0)
                        \                    Coordinates: (10, 4, 9, 10)


 EQUB 1                 \ Object 11, Part 0: Scaffolds: (1, 3, -0, 1)
                        \                    Coordinates: (8, 5, -10, 8)

 EQUB 3                 \ Object 11, Part 1: Scaffolds: (3, -2, -0, -1)
                        \                    Coordinates: (5, -6, -10, -8)


 EQUB 1                 \ Object 12, Part 0: Scaffolds: (1, 3, -1, 0)
                        \                    Coordinates: (8, 5, -8, 10)

 EQUB 3                 \ Object 12, Part 1: Scaffolds: (3, -2, 1, 0)
                        \                    Coordinates: (5, -6, 8, 10)

\ ******************************************************************************
\
\       Name: leftTyrePixels
\       Type: Variable
\   Category: Graphics
\    Summary: Pixels along the edge of the left tyre
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a pixel byte for the white border (colour 2) along the edge of the
\ left tyre.

\ The tyreEdgeIndex table maps track line numbers to entries in this table.
\
\ Each pixel is a colour 2 pixel, so the high nibble contains a 1 and the low
\ nibble contains a 0, to give colour %10. Colour 2 is mapped to white at this
\ point of the custom screen.
\
\ ******************************************************************************

.leftTyrePixels

 EQUB %00000000
 EQUB %10000000
 EQUB %11000000
 EQUB %01000000
 EQUB %01100000
 EQUB %11100000
 EQUB %00100000

\ ******************************************************************************
\
\       Name: token31
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 31
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token31

 EQUS "  "              \ Print "  "

 EQUB 156               \ Set background colour to black

 EQUB 134, 157          \ Set background colour (configurable, default is cyan)

 EQUB 132               \ Set foreground colour (configurable, default is blue
                        \ alphanumeric

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token3
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 3
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token3

 EQUS "ACCUMULATED"     \ Print "ACCUMULATED"

 EQUB 200 + 51          \ Print token 51 (" POINTS")

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData11
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData11

 SKIP 56                \ Populated with code from &7D03 to &7D3A

\ ******************************************************************************
\
\       Name: objectBottom
\       Type: Variable
\   Category: 3D objects
\    Summary: Scaffold measurements for the bottom of each object part
\  Deep dive: Object definitions
\             Scaling objects with scaffolds
\
\ ------------------------------------------------------------------------------
\
\ Entries contain indexes into the scaledScaffold table. n + 8 points to the
\ negative value of n (as scaledScaffold+8 is filled with the negative of
\ scaledScaffold).
\
\ ******************************************************************************

.objectBottom

 EQUB 6 + 8             \ Object 0, Part 0: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-4, -5, -22, -18)

 EQUB 6 + 8             \ Object 0, Part 1: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-4, -5, 18, 22)

 EQUB 3 + 8             \ Object 0, Part 2: Scaffolds: (-6, -3, -0, -4)
                        \                   Coordinates: (-5, -17, -24, -16)

 EQUB 3 + 8             \ Object 0, Part 3: Scaffolds: (-6, -3, 4, 0)
                        \                   Coordinates: (-5, -17, 16, 24)

 EQUB 3 + 8             \ Object 0, Part 4: Scaffolds: (-5, -3, -2, 2)
                        \                   Coordinates: (-8, -17, -18, 18)


 EQUB 6                 \ Object 1, Part 0: Scaffolds: (5, 6, -5, 5)
                        \                   Coordinates: (5, 2, -5, 5)

 EQUB 7 + 8             \ Object 1, Part 1: Scaffolds: (6, -7, -3, 3)
                        \                   Coordinates: (2, -1, -8, 8)

 EQUB 5 + 8             \ Object 1, Part 2: Scaffolds: (-7, -5, -1, 1)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 5                 \ Object 1, Part 3: Scaffolds: (4, 5, -6, 6)
                        \                   Coordinates: (6, 5, -2, 2)


 EQUB 5 + 8             \ Object 2, Part 0: Scaffolds: (-6, -5, -0, -4)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 7                 \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 3 + 8             \ Object 2, Part 2: Scaffolds: (-5, -3, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 6 + 8             \ Object 2, Part 3: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-2, -3, -24, -18)

 EQUB 6 + 8             \ Object 2, Part 4: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-2, -3, 18, 24)


 EQUB 3                 \ Object 3, Part 0: Scaffolds: (2, 3, -0, 0)
                        \                   Coordinates: (6, 4, -16, 16)

 EQUB 4                 \ Object 3, Part 1: Scaffolds: (3, 4, -0, 0)
                        \                   Coordinates: (4, 3, -16, 16)

 EQUB 1 + 8             \ Object 3, Part 2: Scaffolds: (4, -1, -5, 5)
                        \                   Coordinates: (3, -10, -1, 1)

 EQUB 0 + 8             \ Object 3, Part 3: Scaffolds: (-1, -0, -5, 5)
                        \                   Coordinates: (-10, -16, -1, 1)


 EQUB 7 + 8             \ Object 4, Part 0: Scaffolds: (6, -7, -4, 4)
                        \                   Coordinates: (3, -1, -6, 6)

 EQUB 5 + 8             \ Object 4, Part 1: Scaffolds: (-7, -5, -3, 3)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 5 + 8             \ Object 4, Part 2: Scaffolds: (-6, -5, -0, -2)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 7                 \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 1 + 8             \ Object 4, Part 4: Scaffolds: (-5, -1, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 5 + 8             \ Object 4, Part 5: Scaffolds: (7, -5, -7, 7)
                        \                   Coordinates: (1, -5, -1, 1)

 EQUB 6                 \ Object 4, Part 6: Scaffolds: (4, 6, -2, 2)
                        \                   Coordinates: (6, 3, -16, 16)


 EQUB 1 + 8             \ Object 5, Part 0: Scaffolds: (-2, -1, -0, 0)
                        \                   Coordinates: (-3, -17, -26, 26)


 EQUB 2                 \ Object 6, Part 0: Scaffolds: (0, 2, -1, 1)
                        \                   Coordinates: (16, 1, -10, 10)


 EQUB 4 + 8             \ Object 7, Part 0: Scaffolds: (1, -4, -0, 0)
                        \                   Coordinates: (20, -8, -28, 28)

 EQUB 2 + 8             \ Object 7, Part 1: Scaffolds: (-4, -2, -1, -3)
                        \                   Coordinates: (-8, -18, -20, -16)

 EQUB 2 + 8             \ Object 7, Part 2: Scaffolds: (-4, -2, 3, 1)
                        \                   Coordinates: (-8, -18, 16, 20)


 EQUB 0 + 8             \ Object 8, Part 0: Scaffolds: (2, -0, -3, 3)
                        \                   Coordinates: (3, -18, -2, 2)

 EQUB 2                 \ Object 8, Part 1: Scaffolds: (1, 2, -3, 1)
                        \                   Coordinates: (16, 3, -2, 16)


 EQUB 2 + 8             \ Object 9, Part 0: Scaffolds: (1, -2, -0, 0)
                        \                   Coordinates: (12, -10, -16, 16)

 EQUB 0 + 8             \ Object 9, Part 1: Scaffolds: (-2, -0, -3, 3)
                        \                   Coordinates: (-10, -16, -3, 3)


 EQUB 4                 \ Object 10, Part 0: Scaffolds: (3, 4, -0, 0)
                        \                    Coordinates: (4, 1, -10, 10)

 EQUB 2 + 8             \ Object 10, Part 1: Scaffolds: (4, -2, -0, -1)
                        \                    Coordinates: (1, -6, -10, -9)

 EQUB 3                 \ Object 10, Part 2: Scaffolds: (0, 3, 1, 0)
                        \                    Coordinates: (10, 4, 9, 10)


 EQUB 3                 \ Object 11, Part 0: Scaffolds: (1, 3, -0, 1)
                        \                    Coordinates: (8, 5, -10, 8)

 EQUB 2 + 8             \ Object 11, Part 1: Scaffolds: (3, -2, -0, -1)
                        \                    Coordinates: (5, -6, -10, -8)


 EQUB 3                 \ Object 12, Part 0: Scaffolds: (1, 3, -1, 0)
                        \                    Coordinates: (8, 5, -8, 10)

 EQUB 2 + 8             \ Object 12, Part 1: Scaffolds: (3, -2, 1, 0)
                        \                    Coordinates: (5, -6, 8, 10)

\ ******************************************************************************
\
\       Name: rightTyrePixels
\       Type: Variable
\   Category: Graphics
\    Summary: Pixels along the edge of the right tyre
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a pixel byte for the white border (colour 2) along the edge of the
\ right tyre.

\ The tyreEdgeIndex table maps track line numbers to entries in this table.
\
\ Each pixel is a colour 2 pixel, so the high nibble contains a 1 and the low
\ nibble contains a 0, to give colour %10. Colour 2 is mapped to white at this
\ point of the custom screen.
\
\ ******************************************************************************

.rightTyrePixels

 EQUB %00000000
 EQUB %00010000
 EQUB %00110000
 EQUB %00100000
 EQUB %01100000
 EQUB %01110000
 EQUB %01000000

\ ******************************************************************************
\
\       Name: token0
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 0
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token0

 EQUS "FORMULA 3  "     \ Print "FORMULA 3  "

 EQUS "CHAMPIONSHIP"    \ Print "CHAMPIONSHIP"

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData12
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData12

 SKIP 52                \ Populated with code from &7CCF to &7D02

\ ******************************************************************************
\
\       Name: objectLeft
\       Type: Variable
\   Category: 3D objects
\    Summary: Scaffold measurements for the left of each object part
\  Deep dive: Object definitions
\             Scaling objects with scaffolds
\
\ ------------------------------------------------------------------------------
\
\ Entries contain indexes into the scaledScaffold table. n + 8 points to the
\ negative value of n (as scaledScaffold+8 is filled with the negative of
\ scaledScaffold).
\
\ ******************************************************************************

.objectLeft

 EQUB 1 + 8             \ Object 0, Part 0: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-4, -5, -22, -18)

 EQUB 2                 \ Object 0, Part 1: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-4, -5, 18, 22)

 EQUB 0 + 8             \ Object 0, Part 2: Scaffolds: (-6, -3, -0, -4)
                        \                   Coordinates: (-5, -17, -24, -16)

 EQUB 4                 \ Object 0, Part 3: Scaffolds: (-6, -3, 4, 0)
                        \                   Coordinates: (-5, -17, 16, 24)

 EQUB 2 + 8             \ Object 0, Part 4: Scaffolds: (-5, -3, -2, 2)
                        \                   Coordinates: (-8, -17, -18, 18)


 EQUB 5 + 8             \ Object 1, Part 0: Scaffolds: (5, 6, -5, 5)
                        \                   Coordinates: (5, 2, -5, 5)

 EQUB 3 + 8             \ Object 1, Part 1: Scaffolds: (6, -7, -3, 3)
                        \                   Coordinates: (2, -1, -8, 8)

 EQUB 1 + 8             \ Object 1, Part 2: Scaffolds: (-7, -5, -1, 1)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 6 + 8             \ Object 1, Part 3: Scaffolds: (4, 5, -6, 6)
                        \                   Coordinates: (6, 5, -2, 2)


 EQUB 0 + 8             \ Object 2, Part 0: Scaffolds: (-6, -5, -0, -4)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 4                 \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 0 + 8             \ Object 2, Part 2: Scaffolds: (-5, -3, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 1 + 8             \ Object 2, Part 3: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-2, -3, -24, -18)

 EQUB 2                 \ Object 2, Part 4: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-2, -3, 18, 24)


 EQUB 0 + 8             \ Object 3, Part 0: Scaffolds: (2, 3, -0, 0)
                        \                   Coordinates: (6, 4, -16, 16)

 EQUB 0 + 8             \ Object 3, Part 1: Scaffolds: (3, 4, -0, 0)
                        \                   Coordinates: (4, 3, -16, 16)

 EQUB 5 + 8             \ Object 3, Part 2: Scaffolds: (4, -1, -5, 5)
                        \                   Coordinates: (3, -10, -1, 1)

 EQUB 5 + 8             \ Object 3, Part 3: Scaffolds: (-1, -0, -5, 5)
                        \                   Coordinates: (-10, -16, -1, 1)


 EQUB 4 + 8             \ Object 4, Part 0: Scaffolds: (6, -7, -4, 4)
                        \                   Coordinates: (3, -1, -6, 6)

 EQUB 3 + 8             \ Object 4, Part 1: Scaffolds: (-7, -5, -3, 3)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 0 + 8             \ Object 4, Part 2: Scaffolds: (-6, -5, -0, -2)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 2                 \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 0 + 8             \ Object 4, Part 4: Scaffolds: (-5, -1, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 7 + 8             \ Object 4, Part 5: Scaffolds: (7, -5, -7, 7)
                        \                   Coordinates: (1, -5, -1, 1)

 EQUB 2 + 8             \ Object 4, Part 6: Scaffolds: (4, 6, -2, 2)
                        \                   Coordinates: (6, 3, -16, 16)


 EQUB 0 + 8             \ Object 5, Part 0: Scaffolds: (-2, -1, -0, 0)
                        \                   Coordinates: (-3, -17, -26, 26)


 EQUB 1 + 8             \ Object 6, Part 0: Scaffolds: (0, 2, -1, 1)
                        \                   Coordinates: (16, 1, -10, 10)


 EQUB 0 + 8             \ Object 7, Part 0: Scaffolds: (1, -4, -0, 0)
                        \                   Coordinates: (20, -8, -28, 28)

 EQUB 1 + 8             \ Object 7, Part 1: Scaffolds: (-4, -2, -1, -3)
                        \                   Coordinates: (-8, -18, -20, -16)

 EQUB 3                 \ Object 7, Part 2: Scaffolds: (-4, -2, 3, 1)
                        \                   Coordinates: (-8, -18, 16, 20)


 EQUB 3 + 8             \ Object 8, Part 0: Scaffolds: (2, -0, -3, 3)
                        \                   Coordinates: (3, -18, -2, 2)

 EQUB 3 + 8             \ Object 8, Part 1: Scaffolds: (1, 2, -3, 1)
                        \                   Coordinates: (16, 3, -2, 16)


 EQUB 0 + 8             \ Object 9, Part 0: Scaffolds: (1, -2, -0, 0)
                        \                   Coordinates: (12, -10, -16, 16)

 EQUB 3 + 8             \ Object 9, Part 1: Scaffolds: (-2, -0, -3, 3)
                        \                   Coordinates: (-10, -16, -3, 3)


 EQUB 0 + 8             \ Object 10, Part 0: Scaffolds: (3, 4, -0, 0)
                        \                    Coordinates: (4, 1, -10, 10)

 EQUB 0 + 8             \ Object 10, Part 1: Scaffolds: (4, -2, -0, -1)
                        \                    Coordinates: (1, -6, -10, -9)

 EQUB 1                 \ Object 10, Part 2: Scaffolds: (0, 3, 1, 0)
                        \                    Coordinates: (10, 4, 9, 10)


 EQUB 0 + 8             \ Object 11, Part 0: Scaffolds: (1, 3, -0, 1)
                        \                    Coordinates: (8, 5, -10, 8)

 EQUB 0 + 8             \ Object 11, Part 1: Scaffolds: (3, -2, -0, -1)
                        \                    Coordinates: (5, -6, -10, -8)


 EQUB 1 + 8             \ Object 12, Part 0: Scaffolds: (1, 3, -1, 0)
                        \                    Coordinates: (8, 5, -8, 10)

 EQUB 1                 \ Object 12, Part 1: Scaffolds: (3, -2, 1, 0)
                        \                    Coordinates: (5, -6, 8, 10)

\ ******************************************************************************
\
\       Name: leftTyreMask
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel mask for the edge of the left tyre
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a mask byte for the track pixels along the edge of the left tyre.
\
\ The tyreEdgeIndex table maps track line numbers to entries in this table.
\
\ Set bits correspond to the track pixels, while clear bits correspond to the
\ tyre pixels.
\
\ ******************************************************************************

.leftTyreMask

 EQUB %11111111
 EQUB %01110111
 EQUB %00110011
 EQUB %00110011
 EQUB %00010001
 EQUB %00010001
 EQUB %00010001

\ ******************************************************************************
\
\       Name: token42
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 42
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token42

 EQUB 160 + 11          \ Print 11 spaces

 EQUS "YOUR TIME "      \ Print "YOUR TIME "

 EQUS "IS UP!"          \ Print "IS UP!"

 EQUB 160 + 11          \ Print 11 spaces

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token17
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 17
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token17

 EQUS "PRESS "          \ Print "PRESS "

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData13
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData13

 SKIP 41                \ Populated with code from &7CA6 to &7CCE

\ ******************************************************************************
\
\       Name: objectRight
\       Type: Variable
\   Category: 3D objects
\    Summary: Scaffold measurements for the right of each object part
\  Deep dive: Object definitions
\             Scaling objects with scaffolds
\
\ ------------------------------------------------------------------------------
\
\ Entries contain indexes into the scaledScaffold table. n + 8 points to the
\ negative value of n (as scaledScaffold+8 is filled with the negative of
\ scaledScaffold).
\
\ ******************************************************************************

.objectRight

 EQUB 2 + 8             \ Object 0, Part 0: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-4, -5, -22, -18)

 EQUB 1                 \ Object 0, Part 1: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-4, -5, 18, 22)

 EQUB 4 + 8             \ Object 0, Part 2: Scaffolds: (-6, -3, -0, -4)
                        \                   Coordinates: (-5, -17, -24, -16)

 EQUB 0                 \ Object 0, Part 3: Scaffolds: (-6, -3, 4, 0)
                        \                   Coordinates: (-5, -17, 16, 24)

 EQUB 2                 \ Object 0, Part 4: Scaffolds: (-5, -3, -2, 2)
                        \                   Coordinates: (-8, -17, -18, 18)


 EQUB 5                 \ Object 1, Part 0: Scaffolds: (5, 6, -5, 5)
                        \                   Coordinates: (5, 2, -5, 5)

 EQUB 3                 \ Object 1, Part 1: Scaffolds: (6, -7, -3, 3)
                        \                   Coordinates: (2, -1, -8, 8)

 EQUB 1                 \ Object 1, Part 2: Scaffolds: (-7, -5, -1, 1)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 6                 \ Object 1, Part 3: Scaffolds: (4, 5, -6, 6)
                        \                   Coordinates: (6, 5, -2, 2)


 EQUB 4 + 8             \ Object 2, Part 0: Scaffolds: (-6, -5, -0, -4)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 1 + 8             \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 0                 \ Object 2, Part 2: Scaffolds: (-5, -3, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 2 + 8             \ Object 2, Part 3: Scaffolds: (-7, -6, -1, -2)
                        \                   Coordinates: (-2, -3, -24, -18)

 EQUB 1                 \ Object 2, Part 4: Scaffolds: (-7, -6, 2, 1)
                        \                   Coordinates: (-2, -3, 18, 24)


 EQUB 0                 \ Object 3, Part 0: Scaffolds: (2, 3, -0, 0)
                        \                   Coordinates: (6, 4, -16, 16)

 EQUB 0                 \ Object 3, Part 1: Scaffolds: (3, 4, -0, 0)
                        \                   Coordinates: (4, 3, -16, 16)

 EQUB 5                 \ Object 3, Part 2: Scaffolds: (4, -1, -5, 5)
                        \                   Coordinates: (3, -10, -1, 1)

 EQUB 5                 \ Object 3, Part 3: Scaffolds: (-1, -0, -5, 5)
                        \                   Coordinates: (-10, -16, -1, 1)


 EQUB 4                 \ Object 4, Part 0: Scaffolds: (6, -7, -4, 4)
                        \                   Coordinates: (3, -1, -6, 6)

 EQUB 3                 \ Object 4, Part 1: Scaffolds: (-7, -5, -3, 3)
                        \                   Coordinates: (-1, -5, -12, 12)

 EQUB 2 + 8             \ Object 4, Part 2: Scaffolds: (-6, -5, -0, -2)
                        \                   Coordinates: (-3, -5, -26, -16)

 EQUB 1 + 8             \                   Extra edges: Scaffolds: 0, 4
                        \                                Coordinates: 26, 16

 EQUB 0                 \ Object 4, Part 4: Scaffolds: (-5, -1, -0, 0)
                        \                   Coordinates: (-5, -17, -26, 26)

 EQUB 7                 \ Object 4, Part 5: Scaffolds: (7, -5, -7, 7)
                        \                   Coordinates: (1, -5, -1, 1)

 EQUB 2                 \ Object 4, Part 6: Scaffolds: (4, 6, -2, 2)
                        \                   Coordinates: (6, 3, -16, 16)


 EQUB 0                 \ Object 5, Part 0: Scaffolds: (-2, -1, -0, 0)
                        \                   Coordinates: (-3, -17, -26, 26)


 EQUB 1                 \ Object 6, Part 0: Scaffolds: (0, 2, -1, 1)
                        \                   Coordinates: (16, 1, -10, 10)


 EQUB 0                 \ Object 7, Part 0: Scaffolds: (1, -4, -0, 0)
                        \                   Coordinates: (20, -8, -28, 28)

 EQUB 3 + 8             \ Object 7, Part 1: Scaffolds: (-4, -2, -1, -3)
                        \                   Coordinates: (-8, -18, -20, -16)

 EQUB 1                 \ Object 7, Part 2: Scaffolds: (-4, -2, 3, 1)
                        \                   Coordinates: (-8, -18, 16, 20)


 EQUB 3                 \ Object 8, Part 0: Scaffolds: (2, -0, -3, 3)
                        \                   Coordinates: (3, -18, -2, 2)

 EQUB 1                 \ Object 8, Part 1: Scaffolds: (1, 2, -3, 1)
                        \                   Coordinates: (16, 3, -2, 16)


 EQUB 0                 \ Object 9, Part 0: Scaffolds: (1, -2, -0, 0)
                        \                   Coordinates: (12, -10, -16, 16)

 EQUB 3                 \ Object 9, Part 1: Scaffolds: (-2, -0, -3, 3)
                        \                   Coordinates: (-10, -16, -3, 3)


 EQUB 0                 \ Object 10, Part 0: Scaffolds: (3, 4, -0, 0)
                        \                    Coordinates: (4, 1, -10, 10)

 EQUB 1 + 8             \ Object 10, Part 1: Scaffolds: (4, -2, -0, -1)
                        \                    Coordinates: (1, -6, -10, -9)

 EQUB 0                 \ Object 10, Part 2: Scaffolds: (0, 3, 1, 0)
                        \                    Coordinates: (10, 4, 9, 10)


 EQUB 1                 \ Object 11, Part 0: Scaffolds: (1, 3, -0, 1)
                        \                    Coordinates: (8, 5, -10, 8)

 EQUB 1 + 8             \ Object 11, Part 1: Scaffolds: (3, -2, -0, -1)
                        \                    Coordinates: (5, -6, -10, -8)


 EQUB 0                 \ Object 12, Part 0: Scaffolds: (1, 3, -1, 0)
                        \                    Coordinates: (8, 5, -8, 10)

 EQUB 0                 \ Object 12, Part 1: Scaffolds: (3, -2, 1, 0)
                        \                    Coordinates: (5, -6, 8, 10)

\ ******************************************************************************
\
\       Name: rightTyreMask
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel mask for the edge of the right tyre
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a mask byte for the track pixels along the edge of the right tyre.
\
\ The tyreEdgeIndex table maps track line numbers to entries in this table.
\
\ Set bits correspond to the track pixels, while clear bits correspond to the
\ tyre pixels.
\
\ ******************************************************************************

.rightTyreMask

 EQUB %11111111
 EQUB %11101110
 EQUB %11001100
 EQUB %11001100
 EQUB %10001000
 EQUB %10001000
 EQUB %10001000

\ ******************************************************************************
\
\       Name: token23
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 23
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token23

 EQUB 200 + 54          \ Print token 54 ("FORMULA 3  CHAMPIONSHIP" header)

 EQUB 200 + 35          \ Print token 35 (cyan, move cursor to prompt position)

 EQUB 160 + 7           \ Print 7 spaces

 EQUB 200 + 11          \ Print token 11 ("ENTER ")

 EQUS "NAME OF"         \ Print "NAME OF"

 EQUB 200 + 12          \ Print token 12 (" DRIVER")

 EQUB 31, 12, 17        \ Move text cursor to column 12, row 17

 EQUB 131               \ Set foreground colour to yellow alphanumeric

 EQUS "____________"    \ Print "____________"

 EQUB 31, 9, 16         \ Move text cursor to column 9, row 16

 EQUB 133               \ Set foreground colour to magenta alphanumeric

 EQUB 200 + 16          \ Print token 16 (" > ")

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token35
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 35
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token35

 EQUB 31, 2, 10         \ Move text cursor to column 2, row 10

 EQUB 134               \ Set foreground colour to cyan alphanumeric

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData14
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData14

 SKIP 36                \ Populated with code from &7C82 to &7CA5

\ ******************************************************************************
\
\       Name: objectColour
\       Type: Variable
\   Category: 3D objects
\    Summary: Data for the colour of each object part
\  Deep dive: Object definitions
\
\ ------------------------------------------------------------------------------
\
\ Entries contain colour numbers and flags. n + 16 draws an outside edge in the
\ fill colour rather than the edge colour. n + 64 indicates that this is the
\ last part in this object. n + 128 indicates that this is a four-edge object
\ part.
\
\ ******************************************************************************

.objectColour

 EQUB 10                \ Object 0, Part 0: Edge: 2 (white), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 10                \ Object 0, Part 1: Edge: 2 (white), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 8                 \ Object 0, Part 2: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 8                 \ Object 0, Part 3: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 5 + 64            \ Object 0, Part 4: Edge: 1 (red), Fill: 1 (red)
                        \                   Outside: 0 (no), Four-edge: 0 (no)


 EQUB 8                 \ Object 1, Part 0: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 8                 \ Object 1, Part 1: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 9                 \ Object 1, Part 2: Edge: 1 (red), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 10 + 64           \ Object 1, Part 3: Edge: 2 (white), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)


 EQUB 8 + 128           \ Object 2, Part 0: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 1 (yes)

 EQUB 8                 \                   Extra edges: Fill: 1 (red)


 EQUB 8                 \ Object 2, Part 2: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 10                \ Object 2, Part 3: Edge: 2 (white), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 10 + 64           \ Object 2, Part 4: Edge: 2 (white), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)


 EQUB 2                 \ Object 3, Part 0: Edge: 2 (white), Fill: 0 (black)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 0                 \ Object 3, Part 1: Edge: 0 (black), Fill: 0 (black)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 2                 \ Object 3, Part 2: Edge: 2 (white), Fill: 0 (black)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 10 + 64           \ Object 3, Part 3: Edge: 2 (white), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)


 EQUB 8                 \ Object 4, Part 0: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 5                 \ Object 4, Part 1: Edge: 1 (red), Fill: 1 (red)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 8 + 128           \ Object 4, Part 2: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 1 (yes)

 EQUB 8                 \                   Extra edges: Fill: 1 (red)


 EQUB 8                 \ Object 4, Part 4: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 2                 \ Object 4, Part 5: Edge: 2 (white), Fill: 0 (black)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 2 + 64            \ Object 4, Part 6: Edge: 2 (white), Fill: 0 (black)
                        \                   Outside: 0 (no), Four-edge: 0 (no)


 EQUB 8 + 64            \ Object 5, Part 0: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)


 EQUB 2 + 16 + 64       \ Object 6, Part 0: Edge: 2 (white), Fill: 0 (black)
                        \                   Outside: 1 (yes), Four-edge: 0 (no)


 EQUB 8                 \ Object 7, Part 0: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 1 + 16            \ Object 7, Part 1: Edge: 1 (red), Fill: 0 (black)
                        \                   Outside: 1 (yes), Four-edge: 0 (no)

 EQUB 1 + 16 + 64       \ Object 7, Part 2: Edge: 1 (red), Fill: 0 (black)
                        \                   Outside: 1 (yes), Four-edge: 0 (no)


 EQUB 0                 \ Object 8, Part 0: Edge: 0 (black), Fill: 0 (black)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 8 + 64            \ Object 8, Part 1: Edge: 0 (black), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)


 EQUB 10                \ Object 9, Part 0: Edge: 2 (white), Fill: 2 (white)
                        \                   Outside: 0 (no), Four-edge: 0 (no)

 EQUB 2 + 16 + 64       \ Object 9, Part 1: Edge: 2 (white), Fill: 0 (black)
                        \                   Outside: 1 (yes), Four-edge: 0 (no)


 EQUB 0                 \ Object 10, Part 0: Edge: 0 (black), Fill: 0 (black)
                        \                    Outside: 0 (no), Four-edge: 0 (no)

 EQUB 0                 \ Object 10, Part 1: Edge: 0 (black), Fill: 0 (black)
                        \                    Outside: 0 (no), Four-edge: 0 (no)

 EQUB 0 + 64            \ Object 10, Part 2: Edge: 0 (black), Fill: 0 (black)
                        \                    Outside: 0 (no), Four-edge: 0 (no)


 EQUB 0                 \ Object 11, Part 0: Edge: 0 (black), Fill: 0 (black)
                        \                    Outside: 0 (no), Four-edge: 0 (no)

 EQUB 0 + 64            \ Object 11, Part 1: Edge: 0 (black), Fill: 0 (black)
                        \                    Outside: 0 (no), Four-edge: 0 (no)


 EQUB 0                 \ Object 12, Part 0: Edge: 0 (black), Fill: 0 (black)
                        \                    Outside: 0 (no), Four-edge: 0 (no)

 EQUB 0 + 64            \ Object 12, Part 1: Edge: 0 (black), Fill: 0 (black)
                        \                    Outside: 0 (no), Four-edge: 0 (no)

\ ******************************************************************************
\
\       Name: gearNumberText
\       Type: Variable
\   Category: Text
\    Summary: The character to print on the gear stick for each gear
\
\ ******************************************************************************

.gearNumberText

 EQUS "RN12345"

\ ******************************************************************************
\
\       Name: token43
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 43
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token43

 EQUS "Position"        \ Print "Position"

 EQUB 160 + 8           \ Print 8 spaces

 EQUS "In front:"       \ Print "In front:"

 EQUB 160 + 13          \ Print 13 spaces

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token44
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 44
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token44

 EQUS "Laps to go"      \ Print "Laps to go"

 EQUB 160 + 8           \ Print 8 spaces

 EQUS "Behind:"         \ Print "Behind:"

 EQUB 160 + 18          \ Print 18 spaces

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token45
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 45
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token45

 EQUB 160 + 38          \ Print 38 spaces

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: dashData15
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData15

 SKIP 36                \ Populated with code from &7C5E to &7C81

\ ******************************************************************************
\
\       Name: Print2DigitBCD
\       Type: Subroutine
\   Category: Text
\    Summary: Print a binary coded decimal (BCD) number in the specified format
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number to print (in BCD)
\
\   G                   Flags to control how the number is printed:
\
\                         * Bit 7: clear = do not print leading zeroes
\                                  set = print leading zeroes
\
\                         * Bit 6: clear = print second digit
\                                  set = do not print second digit
\
\ Returns:
\
\   G                   G is shifted left by two places, so bits 4 and 5 will be
\                       used to determine the printing style in the next call to
\                       Print2DigitBCD
\
\ Other entry points:
\
\   Print2DigitBCD-6    Print the number at screen coordinate (X, Y), where X
\                       is the character column and Y is the pixel row of the
\                       bottom of the character
\
\ ******************************************************************************

 STX xCursor            \ Set the cursor to (X, Y), so we print the number at
 STY yCursor            \ the specified screen location

.Print2DigitBCD

 PHA                    \ Store A on the stack so we can retrieve it later

 LSR A                  \ Shift the high nibble of A into bits 0-3, so A
 LSR A                  \ contains the first digit of the BCD number
 LSR A
 LSR A

 BNE pnum1              \ If the result is non-zero, jump to pnum1 to print the
                        \ digit in A

                        \ Otherwise the first digit is a zero, which we either
                        \ print as a capital "O" (so it doesn't have a line
                        \ through it), or as a space, depending on the setting
                        \ in G, which controls whether or not to print leading
                        \ zeroes

 LDA #'O'-'0'           \ Set A so we print a capital "O" in pnum1

 BIT G                  \ If bit 7 of G is set, jump to pnum1 to print a capital
 BMI pnum1              \ "O"

 LDA #LO(' '-'0')       \ Otherwise bit 7 of G is clear and we do not print
                        \ leading zeroes, so instead set A so we print a space
                        \ in pnum1

.pnum1

 CLC                    \ Print the high nibble in A as a digit (or, if the high
 ADC #'0'               \ nibble is zero, print a capitel "O" or a space, as per
 JSR PrintCharacter     \ the above)

                        \ Now for the second digit

 ASL G                  \ Shift G to the left, so bit 6 is now in bit 7

 PLA                    \ Retrieve the original value of A, which contains the
                        \ BCD number to print

 ASL G                  \ If bit 7 of G is set (i.e. bit 6 of the original G),
 BCS pnum3              \ jump to pnum3 to skip printing the second digit, and
                        \ return from the subroutine

 AND #%00001111         \ Extract the low nibble of the BCD number into A

 BNE pnum2              \ If the low nibble is non-zero, jump to pnum2 to skip
                        \ the following instruction

 LDA #'O'-'0'           \ Set A so we print a capital "O" in pnum2

.pnum2

 CLC                    \ Print the low nibble in A as a digit (or, if the low
 ADC #'0'               \ nibble is zero, print a capital "O")
 JSR PrintCharacter

.pnum3

 RTS                    \ Return from the subroutine

 EQUB &FF               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: token22
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 22
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token22

 EQUB 200 + 54          \ Print token 54 ("FORMULA 3  CHAMPIONSHIP" header)

 EQUB 200 + 36          \ Print token 36 (menu option 1 with "PRESS" prompt)

 EQUB 200 + 18          \ Print token 18 (" 5")

 EQUB 200 + 13          \ Print token 13 (" mins")

 EQUB 200 + 37          \ Print token 37 (menu option 2)

 EQUB 200 + 19          \ Print token 19 ("10")

 EQUB 200 + 13          \ Print token 13 (" mins")

 EQUB 200 + 38          \ Print token 38 (menu option 3)

 EQUB 200 + 20          \ Print token 20 ("20")

 EQUB 200 + 13          \ Print token 13 (" mins")

 EQUB 200 + 35          \ Print token 35 (cyan, move cursor to prompt position)

 EQUB 200 + 10          \ Print token 10 ("SELECT ")

 EQUS "DURATION OF "    \ Print "DURATION OF "

 EQUS "QUALIFYING LAPS" \ Print "QUALIFYING LAPS"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token16
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 16
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token16

 EQUS " ] "             \ Print " ] "

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData16
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData16

 SKIP 36                \ Populated with code from &7C3A to &7C5D

\ ******************************************************************************
\
\       Name: carSpeedLo
\       Type: Variable
\   Category: Driving model
\    Summary: Low byte of each car's forward speed
\
\ ------------------------------------------------------------------------------
\
\ Stored as an 8-bit value (carSpeedHi carSpeedLo).
\
\ ******************************************************************************

.carSpeedLo

IF _ACORNSOFT

 EQUB &FF, &88          \ These values are workspace noise and have no meaning
 EQUB &88, &CC
 EQUB &CC, &CC
 EQUB &CC, &CC
 EQUB &CC, &EE
 EQUB &EE, &EE
 EQUB &EE, &FF
 EQUB &FF, &FF
 EQUB &88, &88
 EQUB &88, &CC

ELIF _SUPERIOR

 SKIP 20

ENDIF

\ ******************************************************************************
\
\       Name: totalPointsLo
\       Type: Variable
\   Category: Drivers
\    Summary: Low byte of total accumulated points for each driver
\
\ ------------------------------------------------------------------------------
\
\ Indexed by driver number (0 to 19).
\
\ Gets set in InitialiseDrivers.
\
\ Stored as a 24-bit value (totalPointsTop totalPointsHi totalPointsLo).
\
\ ******************************************************************************

.totalPointsLo

IF _ACORNSOFT

 EQUB &CC, &CC          \ These values are workspace noise and have no meaning
 EQUB &EE, &FF
 EQUB &FF, &88
 EQUB &CC, &EE
 EQUB &FF, &FF
 EQUB &FF, &FF
 EQUB &FF, &FF
 EQUB &FF, &FF
 EQUB &FF, &FF
 EQUB &FF, &FF

ELIF _SUPERIOR

 SKIP 20

ENDIF

\ ******************************************************************************
\
\       Name: racePointsLo
\       Type: Variable
\   Category: Drivers
\    Summary: Used to store the low byte of the race points being awarded to
\             the driver in race position X
\
\ ******************************************************************************

.racePointsLo

IF _ACORNSOFT

 EQUB &FF, &FF          \ These values are workspace noise and have no meaning
 EQUB &FF, &FF
 EQUB &FF, &FF
 EQUB &FF, &FF

ELIF _SUPERIOR

 SKIP 8

ENDIF

\ ******************************************************************************
\
\       Name: token39
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 39
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token39

 EQUB 200 + 36          \ Print token 36 (menu option 1 with "PRESS" prompt)

 EQUS "PRACTICE"        \ Print "PRACTICE"

 EQUB 200 + 37          \ Print token 37 (menu option 2)

 EQUS "COMPETITION"     \ Print "COMPETITION"

 EQUB 255               \ End token

 EQUB &FF               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: token48
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 48
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token48

 EQUB 160 + 13          \ Print 13 spaces

 EQUS "PLEASE"          \ Print "PLEASE"

 EQUB 160 + 2           \ Print 2 spaces

 EQUS "WAIT"            \ Print "WAIT"

 EQUB 160 + 13          \ Print 13 spaces

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token49
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 49
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token49

 EQUB 31, 9, 2          \ Move text cursor to column 9, row 2

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData17
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData17

 SKIP 36                \ Populated with code from &7C16 to &7C39

\ ******************************************************************************
\
\       Name: leftDashMask
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel mask for the left edge of the dashboard
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a mask byte for the track pixels along the left edge of the central
\ part of the dashboard.
\
\ There is a byte for each track line from 43 (the track line at the top of the
\ dashboard) down to 3 (the lowest track line, just above where the wing mirror
\ joins the car body). Lines 0 to 2 are not used.
\
\ Set bits correspond to the track pixels, while clear bits correspond to the
\ dashboard pixels.
\
\ ******************************************************************************

.leftDashMask

 EQUB %11111111         \ Line  0
 EQUB %11111111         \ Line  1
 EQUB %10001000         \ Line  2
 EQUB %10001000         \ Line  3
 EQUB %11001100         \ Line  4
 EQUB %11101110         \ Line  5
 EQUB %11111111         \ Line  6
 EQUB %10001000         \ Line  7
 EQUB %10001000         \ Line  8
 EQUB %11001100         \ Line  9
 EQUB %11101110         \ Line 10
 EQUB %11111111         \ Line 11
 EQUB %10001000         \ Line 12
 EQUB %11001100         \ Line 13
 EQUB %11101110         \ Line 14
 EQUB %11111111         \ Line 15
 EQUB %10001000         \ Line 16
 EQUB %11001100         \ Line 17
 EQUB %11101110         \ Line 18
 EQUB %11111111         \ Line 19
 EQUB %10001000         \ Line 20
 EQUB %11001100         \ Line 21
 EQUB %11101110         \ Line 22
 EQUB %11111111         \ Line 23
 EQUB %10001000         \ Line 24
 EQUB %11001100         \ Line 25
 EQUB %11101110         \ Line 26
 EQUB %11111111         \ Line 27
 EQUB %10001000         \ Line 28
 EQUB %10001000         \ Line 29
 EQUB %11001100         \ Line 30
 EQUB %11001100         \ Line 31
 EQUB %11001100         \ Line 32
 EQUB %11101110         \ Line 33
 EQUB %11101110         \ Line 34
 EQUB %11101110         \ Line 35
 EQUB %11111111         \ Line 36
 EQUB %11111111         \ Line 37
 EQUB %11111111         \ Line 38
 EQUB %10001000         \ Line 39
 EQUB %10001000         \ Line 40
 EQUB %10001000         \ Line 41
 EQUB %11001100         \ Line 42
 EQUB %11001100         \ Line 43

\ ******************************************************************************
\
\       Name: colourPalette
\       Type: Variable
\   Category: Graphics
\    Summary: The main colour palette that maps logical colours 0 to 3 to
\             physical colours
\
\ ******************************************************************************

.colourPalette

 EQUB %00000000         \ Four pixels of colour 0
 EQUB %00001111         \ Four pixels of colour 1
 EQUB %11110000         \ Four pixels of colour 2
 EQUB %11111111         \ Four pixels of colour 3

\ ******************************************************************************
\
\       Name: dashDataOffset
\       Type: Variable
\   Category: Dashboard
\    Summary: Offset of the dash data within each dash data block
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashDataOffset

 EQUB dashData0  - (dashData + &80 *  0) - 1
 EQUB dashData1  - (dashData + &80 *  1) - 1
 EQUB dashData2  - (dashData + &80 *  2) - 1
 EQUB dashData3  - (dashData + &80 *  3) - 1
 EQUB dashData4  - (dashData + &80 *  4) - 1
 EQUB dashData5  - (dashData + &80 *  5) - 1
 EQUB dashData6  - (dashData + &80 *  6) - 1
 EQUB dashData7  - (dashData + &80 *  7) - 1
 EQUB dashData8  - (dashData + &80 *  8) - 1
 EQUB dashData9  - (dashData + &80 *  9) - 1
 EQUB dashData10 - (dashData + &80 * 10) - 1
 EQUB dashData11 - (dashData + &80 * 11) - 1
 EQUB dashData12 - (dashData + &80 * 12) - 1
 EQUB dashData13 - (dashData + &80 * 13) - 1
 EQUB dashData14 - (dashData + &80 * 14) - 1
 EQUB dashData15 - (dashData + &80 * 15) - 1
 EQUB dashData16 - (dashData + &80 * 16) - 1
 EQUB dashData17 - (dashData + &80 * 17) - 1
 EQUB dashData18 - (dashData + &80 * 18) - 1
 EQUB dashData19 - (dashData + &80 * 19) - 1
 EQUB dashData20 - (dashData + &80 * 20) - 1
 EQUB dashData21 - (dashData + &80 * 21) - 1
 EQUB dashData22 - (dashData + &80 * 22) - 1
 EQUB dashData23 - (dashData + &80 * 23) - 1
 EQUB dashData24 - (dashData + &80 * 24) - 1
 EQUB dashData25 - (dashData + &80 * 25) - 1
 EQUB dashData26 - (dashData + &80 * 26) - 1
 EQUB dashData27 - (dashData + &80 * 27) - 1
 EQUB dashData28 - (dashData + &80 * 28) - 1
 EQUB dashData29 - (dashData + &80 * 29) - 1
 EQUB dashData30 - (dashData + &80 * 30) - 1
 EQUB dashData31 - (dashData + &80 * 31) - 1
 EQUB dashData32 - (dashData + &80 * 32) - 1
 EQUB dashData33 - (dashData + &80 * 33) - 1
 EQUB dashData34 - (dashData + &80 * 34) - 1
 EQUB dashData35 - (dashData + &80 * 35) - 1
 EQUB dashData36 - (dashData + &80 * 36) - 1
 EQUB dashData37 - (dashData + &80 * 37) - 1
 EQUB dashData38 - (dashData + &80 * 38) - 1
 EQUB dashData39 - (dashData + &80 * 39) - 1
 EQUB dashData40 - (dashData + &80 * 40) - 1

 EQUB &FF, &81          \ These bytes appear to be unused
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData18
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData18

 SKIP 36                \ Populated with code from &7BF2 to &7C15

\ ******************************************************************************
\
\       Name: rightDashMask
\       Type: Variable
\   Category: Dashboard
\    Summary: Pixel mask for the right edge of the dashboard
\  Deep dive: Drawing around the dashboard
\
\ ------------------------------------------------------------------------------
\
\ Contains a mask byte for the track pixels along the right edge of the central
\ part of the dashboard.
\
\ There is a byte for each track line from 43 (the track line at the top of the
\ dashboard) down to 3 (the lowest track line, just above where the wing mirror
\ joins the car body). Lines 0 to 2 are not used.
\
\ Set bits correspond to the track pixels, while clear bits correspond to the
\ dashboard pixels.
\
\ ******************************************************************************

.rightDashMask

 EQUB %11111111         \ Line  0
 EQUB %11111111         \ Line  1
 EQUB %00010001         \ Line  2
 EQUB %00010001         \ Line  3
 EQUB %00110011         \ Line  4
 EQUB %01110111         \ Line  5
 EQUB %11111111         \ Line  6
 EQUB %00010001         \ Line  7
 EQUB %00010001         \ Line  8
 EQUB %00110011         \ Line  9
 EQUB %01110111         \ Line 10
 EQUB %11111111         \ Line 11
 EQUB %00010001         \ Line 12
 EQUB %00110011         \ Line 13
 EQUB %01110111         \ Line 14
 EQUB %11111111         \ Line 15
 EQUB %00010001         \ Line 16
 EQUB %00110011         \ Line 17
 EQUB %01110111         \ Line 18
 EQUB %11111111         \ Line 19
 EQUB %00010001         \ Line 20
 EQUB %00110011         \ Line 21
 EQUB %01110111         \ Line 22
 EQUB %11111111         \ Line 23
 EQUB %00010001         \ Line 24
 EQUB %00110011         \ Line 25
 EQUB %01110111         \ Line 26
 EQUB %11111111         \ Line 27
 EQUB %00010001         \ Line 28
 EQUB %00010001         \ Line 29
 EQUB %00110011         \ Line 30
 EQUB %00110011         \ Line 31
 EQUB %00110011         \ Line 32
 EQUB %01110111         \ Line 33
 EQUB %01110111         \ Line 34
 EQUB %01110111         \ Line 35
 EQUB %11111111         \ Line 36
 EQUB %11111111         \ Line 37
 EQUB %11111111         \ Line 38
 EQUB %00010001         \ Line 39
 EQUB %00010001         \ Line 40
 EQUB %00010001         \ Line 41
 EQUB %00110011         \ Line 42
 EQUB %00110011         \ Line 43

\ ******************************************************************************
\
\       Name: startDialHi
\       Type: Variable
\   Category: Dashboard
\    Summary: The high byte of the screen address of the start of the dial hand
\             on the rev counter
\
\ ******************************************************************************

.startDialHi

 EQUB &75               \ Quadrant 0 (12:00 to 3:00) = &7566
 EQUB &75               \ Quadrant 1 (3:00 to 6:00)  = &7567
 EQUB &75               \ Quadrant 2 (6:00 to 9:00)  = &755F
 EQUB &75               \ Quadrant 3 (9:00 to 12:00) = &755E

\ ******************************************************************************
\
\       Name: wheelPixels
\       Type: Variable
\   Category: Graphics
\    Summary: The number of pixels in the longest axis for the steering wheel
\             line at various points in a quadrant
\
\ ------------------------------------------------------------------------------
\
\ This table contains values that are used to calculate the coordinates of the
\ end of the line on the steering wheel.
\
\ The contents of the table are very close to the following (the values from
\ the following calculation are shown in the comments below - they are close,
\ but not quite a perfect match, so I haven't got this exactly right):
\
\ FOR I%, 0, 37
\  EQUB INT(0.5 + 53 * COS((PI / 8) * I% / 21))
\ NEXT
\
\ This gives the length of the adjacent side of a right-angled triangle, with a
\ hypoteneuse of length 53, and an angle ranging from 0 to PI/4 (i.e. one
\ eighth of a circle), split up into 21 points per eighth of a circle (so the
\ table's 38 points cover almost a quarter of a circle).
\
\ In other words, if we have a clock whose centre is at the origin, then this
\ table contains the x-coordinate of the end of a clock hand of length 28 as it
\ moves from 3 o'clock to half past 4.
\
\ ******************************************************************************

.wheelPixels

 EQUB 53                \ INT(0.5 + 53.00) = 53
 EQUB 53                \ INT(0.5 + 52.99) = 53
 EQUB 53                \ INT(0.5 + 52.96) = 53
 EQUB 53                \ INT(0.5 + 52.92) = 53
 EQUB 53                \ INT(0.5 + 52.85) = 53
 EQUB 53                \ INT(0.5 + 52.77) = 53
 EQUB 53                \ INT(0.5 + 52.67) = 53
 EQUB 53                \ INT(0.5 + 52.55) = 53
 EQUB 52                \ INT(0.5 + 52.41) = 52
 EQUB 52                \ INT(0.5 + 52.25) = 52
 EQUB 52                \ INT(0.5 + 52.08) = 52
 EQUB 52                \ INT(0.5 + 51.88) = 52
 EQUB 52                \ INT(0.5 + 51.67) = 52
 EQUB 52                \ INT(0.5 + 51.44) = 51 (doesn't match)
 EQUB 51                \ INT(0.5 + 51.19) = 51
 EQUB 51                \ INT(0.5 + 50.93) = 51
 EQUB 51                \ INT(0.5 + 50.65) = 51
 EQUB 50                \ INT(0.5 + 50.34) = 50
 EQUB 50                \ INT(0.5 + 50.03) = 50
 EQUB 50                \ INT(0.5 + 49.69) = 50
 EQUB 49                \ INT(0.5 + 49.34) = 49
 EQUB 49                \ INT(0.5 + 48.97) = 49
 EQUB 48                \ INT(0.5 + 48.58) = 49 (doesn't match)
 EQUB 48                \ INT(0.5 + 48.17) = 48
 EQUB 47                \ INT(0.5 + 47.75) = 48 (doesn't match)
 EQUB 47                \ INT(0.5 + 47.31) = 47
 EQUB 46                \ INT(0.5 + 46.86) = 47 (doesn't match)
 EQUB 46                \ INT(0.5 + 46.39) = 46
 EQUB 45                \ INT(0.5 + 45.90) = 46 (doesn't match)
 EQUB 45                \ INT(0.5 + 45.40) = 45
 EQUB 44                \ INT(0.5 + 44.88) = 45 (doesn't match)
 EQUB 44                \ INT(0.5 + 44.34) = 44
 EQUB 43                \ INT(0.5 + 43.79) = 44 (doesn't match)
 EQUB 42                \ INT(0.5 + 43.22) = 43 (doesn't match)
 EQUB 41                \ INT(0.5 + 42.64) = 43 (doesn't match)
 EQUB 40                \ INT(0.5 + 42.05) = 42 (doesn't match)
 EQUB 39                \ INT(0.5 + 41.44) = 41 (doesn't match)
 EQUB 38                \ INT(0.5 + 40.81) = 41 (doesn't match)

\ ******************************************************************************
\
\       Name: token32
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 32
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token32

 EQUB 160 + 2           \ Print 2 spaces

 EQUB 156               \ Set background colour to black

 EQUB 8, 8              \ Backspace to the left by two characters

 EQUB 200 + 31          \ Print token 31 (two spaces and configurable colours)

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData19
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData19

 SKIP 36                \ Populated with code from &7BCE to &7BF1

\ ******************************************************************************
\
\       Name: pixelsToRight
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel byte with all the pixels to the right of position X set
\
\ ******************************************************************************

.pixelsToRight

 EQUB %01110111
 EQUB %00110011
 EQUB %00010001
 EQUB %00000000

\ ******************************************************************************
\
\       Name: configKeys
\       Type: Variable
\   Category: Keyboard
\    Summary: Details of the configuration settings that are set by the shifted
\             configuration keys
\
\ ------------------------------------------------------------------------------
\
\ The low nibble of each setting indicates which configuration byte should be
\ updated when this key is pressed, as an offset from configStop, and the high
\ nibble contains the value that it should be set to.
\
\ The values in this table correspond with the keys defined in the shiftedKeys
\ table.
\
\ ******************************************************************************

.configKeys

                        \ SHIFT + key   Bits affected     Config byte      Value

 EQUB &80               \ Right arrow   Set bit 7         configStop         &80
 EQUB &01               \ f1            Clear all bits    configJoystick     &00
 EQUB &C1               \ f2            Set bits 6 & 7    configJoystick     &C0
 EQUB &81               \ f2            Set bit 7         configJoystick     &80
 EQUB &C2               \ f4            Set bits 6 & 7    configVolume       &C0
 EQUB &42               \ f5            Set bit 6         configVolume       &40
 EQUB &C0               \ f0            Set bits 6 & 7    configStop         &C0
 EQUB &83               \ COPY          Set bit 7         configPause        &80
 EQUB &43               \ DELETE        Set bit 6         configPause        &40
 EQUB &20               \ f7            Set bit 5         configStop         &20

IF _ACORNSOFT

 EQUB &77, &BB          \ These values are workspace noise and have no meaning

ELIF _SUPERIOR

 EQUB &04               \ f3            Clear all bits    configAssist       &00
 EQUB &84               \ f6            Set bit 7         configAssist       &80

ENDIF

\ ******************************************************************************
\
\       Name: menuKeysSuperior
\       Type: Variable
\   Category: Keyboard
\    Summary: Negative inkey values for the menu keys (SPACE, "1", "2" and "3")
\             for the Superior Software release
\
\ ******************************************************************************

IF _ACORNSOFT

 EQUB &DD, &EE          \ These values are workspace noise and have no meaning
 EQUB &77, &BB

ELIF _SUPERIOR

.menuKeysSuperior

 EQUB &9D               \ Negative inkey value for SPACE
 EQUB &CF               \ Negative inkey value for "1"
 EQUB &CE               \ Negative inkey value for "2"
 EQUB &EE               \ Negative inkey value for "3"

ENDIF

\ ******************************************************************************
\
\       Name: totalPointsHi
\       Type: Variable
\   Category: Drivers
\    Summary: High byte of total accumulated points for each driver
\
\ ------------------------------------------------------------------------------
\
\ Indexed by driver number (0 to 19).
\
\ Gets set in InitialiseDrivers.
\
\ Stored as a 24-bit value (totalPointsTop totalPointsHi totalPointsLo).
\
\ ******************************************************************************

.totalPointsHi

 EQUB &DD, &EE          \ These values are workspace noise and have no meaning
 EQUB 0, 0, 0, 0, 0, 0
 EQUB 0, 0, 0, 0, 0, 0
 EQUB 0, 0, 0, 0, 0, 0

\ ******************************************************************************
\
\       Name: racePointsHi
\       Type: Variable
\   Category: Drivers
\    Summary: High byte of race points calculated for each position
\
\ ******************************************************************************

.racePointsHi

 EQUB &77, &BB          \ These values are workspace noise and have no meaning
 EQUB &DD, &EE
 EQUB &77, &BB
 EQUB &DD, &EE

\ ******************************************************************************
\
\       Name: token30
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 30
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token30

 EQUB 31, 5, 24         \ Move text cursor to column 5, row 24

 EQUB 134               \ Set foreground colour to cyan alphanumeric

 EQUB 200 + 17          \ Print token 17 ("PRESS ")

 EQUS "SPACE BAR "      \ Print "SPACE BAR "

 EQUS "TO CONTINUE"     \ Print "TO CONTINUE"

 EQUB 255               \ End token

 EQUB &45, &FF          \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: token2
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 2
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token2

 EQUS "GRID POSITIONS"  \ Print "GRID POSITIONS"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData20
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData20

 SKIP 36                \ Populated with code from &7BAA to &7BCD

\ ******************************************************************************
\
\       Name: PrintHeaderChecks
\       Type: Subroutine
\   Category: Text
\    Summary: Print chequered lines above and below the header
\
\ ******************************************************************************

.PrintHeaderChecks

 LDY #1                 \ We are about to print two chequered lines, so set a
                        \ line counter in Y

.head1

 LDA endChecks,Y        \ Set T to the screen address offset of the end of the
 STA T                  \ Y-th chequered line

 LDX startChecks,Y      \ Set A to the screen address offset of the start of the
                        \ Y-th chequered line

 LDA #151               \ Poke the "white graphics" character into the X-th byte
 STA row2_column1,X     \ of screen memory at column 1, row 2, so the subsequent
                        \ bytes are shown as graphics characters

 LDA #226               \ Set A to the graphics character with the top-right and
                        \ bottom-right blocks set to white, to form the first
                        \ character of the line (i.e. the first two checks in
                        \ the chequered line)

.head2

 INX                    \ Increment the screen address offset to move along one
                        \ character

 STA row2_column1,X     \ Poke character A into screen memory

 LDA #230               \ Set A to the graphics character with the top-right,
                        \ bottom-right and centre-left blocks set to white, to
                        \ form the rest of the checks on the chequered line

 CPX T                  \ Loop back to print the next character in the line
 BNE head2              \ until we have reached the screen address in T

 DEY                    \ Decrement the line counter

 BPL head1              \ Loop back to print the second line

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: startChecks
\       Type: Variable
\   Category: Text
\    Summary: The screen address offset of the start of each chequered header
\             line
\
\ ******************************************************************************

.startChecks

 EQUB 0                 \ Start the first line at row 2, column 1 (as the offset
                        \ is added to row2_column1)

 EQUB 40 * 3            \ Start the second line on row 5, column 1 (as there are
                        \ 40 characters per row)

\ ******************************************************************************
\
\       Name: endChecks
\       Type: Variable
\   Category: Text
\    Summary: The screen address offset of the end of each chequered header line
\
\ ******************************************************************************

.endChecks

 EQUB 35                \ End the first line after 35 characters

 EQUB 35 + (40 * 3)     \ End the first line after 35 characters

\ ******************************************************************************
\
\       Name: token53
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 53
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token53

 EQUB 160 + 15          \ Print 15 spaces

 EQUS "FINISHED"        \ Print "FINISHED"

 EQUB 160 + 15          \ Print 15 spaces

 EQUB 255               \ End token

 EQUB 0, 0              \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: token41
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 41
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token41

 EQUB 160 + 6           \ Print 6 spaces

 EQUS "Less than one "  \ Print "Less than one "

 EQUS "minute to go"    \ Print "minute to go"

 EQUB 160 + 6           \ Print 6 spaces

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token38
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 38
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token38

 EQUB 31, 5, 20         \ Move text cursor to column 5, row 20

 EQUB 132, 157          \ Set background colour to blue

 EQUB 134               \ Set foreground colour to cyan alphanumeric

 EQUS "3"               \ Print "3"

 EQUB 160 + 2           \ Print 2 spaces

 EQUB 156               \ Set background colour to black

 EQUB 160 + 5           \ Print 5 spaces

 EQUB 131               \ Set foreground colour to yellow alphanumeric

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData21
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData21

 SKIP 36                \ Populated with code from &7B86 to &7BA9

\ ******************************************************************************
\
\       Name: tokenLo
\       Type: Variable
\   Category: Text
\    Summary: Low byte of the token address lookup table
\  Deep dive: Text tokens
\
\ ------------------------------------------------------------------------------
\
\ Note that token 47 is not used.
\
\ ******************************************************************************

.tokenLo

 EQUB LO(token0)
 EQUB LO(token1)
 EQUB LO(token2)
 EQUB LO(token3)
 EQUB LO(token4)
 EQUB LO(token5)
 EQUB LO(token6)
 EQUB LO(token7)
 EQUB LO(token8)
 EQUB LO(token9)
 EQUB LO(token10)
 EQUB LO(token11)
 EQUB LO(token12)
 EQUB LO(token13)
 EQUB LO(token14)
 EQUB LO(token15)
 EQUB LO(token16)
 EQUB LO(token17)
 EQUB LO(token18)
 EQUB LO(token19)
 EQUB LO(token20)
 EQUB LO(token21)
 EQUB LO(token22)
 EQUB LO(token23)
 EQUB LO(token24)
 EQUB LO(token25)
 EQUB LO(token26)
 EQUB LO(token27)
 EQUB LO(token28)
 EQUB LO(token29)
 EQUB LO(token30)
 EQUB LO(token31)
 EQUB LO(token32)
 EQUB LO(token33)
 EQUB LO(token34)
 EQUB LO(token35)
 EQUB LO(token36)
 EQUB LO(token37)
 EQUB LO(token38)
 EQUB LO(token39)
 EQUB LO(token40)
 EQUB LO(token41)
 EQUB LO(token42)
 EQUB LO(token43)
 EQUB LO(token44)
 EQUB LO(token45)
 EQUB LO(token46)
 EQUB 0
 EQUB LO(token48)
 EQUB LO(token49)
 EQUB LO(token50)
 EQUB LO(token51)
 EQUB LO(token52)
 EQUB LO(token53)

\ ******************************************************************************
\
\       Name: yLookupHi
\       Type: Variable
\   Category: Graphics
\    Summary: Lookup table for converting pixel y-coordinate to high byte of
\             screen address
\
\ ------------------------------------------------------------------------------
\
\ This table returns the high byte of the screen address of the start of the
\ row, for the custom screen mode.
\
\ Note that the custom screen mode starts at address &5A80, so the first two
\ entries in this table do not point to screen memory; the first two character
\ rows in this table are off the top of the custom screen, so the first row
\ on-screen is the third row. This is why, when we print the top two lines of
\ text in the custom screen with the PrintCharacter routine, we do so at the
\ following y-coordinates:
\
\   * yCursor = 24 for the first line of text
\
\   * yCursor = 33 for the second line of text
\
\ To see where these are on-screen, we need to subtract 16 for the first two
\ character rows which are off the top of the screen, to give:
\
\   * y-coordinate = 8 for the first line of text
\
\   * y-coordinate = 17 for the second line of text
\
\ The value passed to PrintCharacter points to the bottom row of the character
\ to print, so the first coordinate points to the ninth pixel row (as the first
\ pixel row is row 0), and the second points to the 18th pixel row. There are
\ eight pixels in each character row, so this prints the first row of text so
\ that it has a one-pixel margin between the top of the text and the top of the
\ screen, and i prints the second row so that it has a one-pixel margin between
\ the top of the text and the bottom of the line above.
\
\ I don't know why this table starts at &5800 and not &5A80, but that's how it
\ is.
\
\ ******************************************************************************

.yLookupHi

FOR I%, 0, 31

 EQUB HI(&5800 + (I% * &140))

NEXT

\ ******************************************************************************
\
\       Name: mirrorAddressLo
\       Type: Variable
\   Category: Dashboard
\    Summary: The low byte of the base screen address of each mirror segment
\
\ ******************************************************************************

.mirrorAddressLo

 EQUB LO(mirror0)
 EQUB LO(mirror1)
 EQUB LO(mirror2)
 EQUB LO(mirror3)
 EQUB LO(mirror4)
 EQUB LO(mirror5)

\ ******************************************************************************
\
\       Name: dashData22
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData22

 SKIP 36                \ Populated with code from &7B62 to &7B85

\ ******************************************************************************
\
\       Name: tokenHi
\       Type: Variable
\   Category: Text
\    Summary: high byte of the token address lookup table
\  Deep dive: Text tokens
\
\ ------------------------------------------------------------------------------
\
\ Note that token 47 is not used.
\
\ ******************************************************************************

.tokenHi

 EQUB HI(token0)
 EQUB HI(token1)
 EQUB HI(token2)
 EQUB HI(token3)
 EQUB HI(token4)
 EQUB HI(token5)
 EQUB HI(token6)
 EQUB HI(token7)
 EQUB HI(token8)
 EQUB HI(token9)
 EQUB HI(token10)
 EQUB HI(token11)
 EQUB HI(token12)
 EQUB HI(token13)
 EQUB HI(token14)
 EQUB HI(token15)
 EQUB HI(token16)
 EQUB HI(token17)
 EQUB HI(token18)
 EQUB HI(token19)
 EQUB HI(token20)
 EQUB HI(token21)
 EQUB HI(token22)
 EQUB HI(token23)
 EQUB HI(token24)
 EQUB HI(token25)
 EQUB HI(token26)
 EQUB HI(token27)
 EQUB HI(token28)
 EQUB HI(token29)
 EQUB HI(token30)
 EQUB HI(token31)
 EQUB HI(token32)
 EQUB HI(token33)
 EQUB HI(token34)
 EQUB HI(token35)
 EQUB HI(token36)
 EQUB HI(token37)
 EQUB HI(token38)
 EQUB HI(token39)
 EQUB HI(token40)
 EQUB HI(token41)
 EQUB HI(token42)
 EQUB HI(token43)
 EQUB HI(token44)
 EQUB HI(token45)
 EQUB HI(token46)
 EQUB 0
 EQUB HI(token48)
 EQUB HI(token49)
 EQUB HI(token50)
 EQUB HI(token51)
 EQUB HI(token52)
 EQUB HI(token53)

\ ******************************************************************************
\
\       Name: shortAxis
\       Type: Variable
\   Category: Graphics
\    Summary: Code modifications for the DrawDashboardLine line-drawing routine
\
\ ------------------------------------------------------------------------------
\
\ When drawing a line, the short axis is only stepped along when the slope error
\ adds up to a whole pixel, so this steps along the shorter axis of the line's
\ vector. See the DrawDashboardLine routine for details.
\
\ ******************************************************************************

.shortAxis

 INX                    \ V = 0, INX and DEY = Steep slope, right and up
 DEY                    \ V = 1, DEY and INX = Shallow slope, right and up
 INY                    \ V = 2, INY and INX = Shallow slope, right and down
 INX                    \ V = 3, INX and INY = Steep slope, right and down
 DEX                    \ V = 4, DEX and INY = Steep slope, left and down
 INY                    \ V = 5, INY and DEX
 DEY                    \ V = 6, DEY and DEX
 DEX                    \ V = 7, DEX and DEY

\ ******************************************************************************
\
\       Name: stepAxis
\       Type: Variable
\   Category: Graphics
\    Summary: Code modifications for the DrawDashboardLine line-drawing routine
\
\ ------------------------------------------------------------------------------
\
\ When drawing a line, we step along the longer axis of the line's vector by one
\ pixel for loop around the line-drawing routine. See the DrawDashboardLine
\ routine for details.
\
\ ******************************************************************************

.stepAxis

 DEY                    \ V = 0, INX and DEY = Steep slope, right and up
 INX                    \ V = 1, DEY and INX = Shallow slope, right and up
 INX                    \ V = 2, INY and INX = Shallow slope, right and down
 INY                    \ V = 3, INX and INY = Steep slope, right and down
 INY                    \ V = 4, DEX and INY = Steep slope, left and down
 DEX                    \ V = 5, INY and DEX
 DEX                    \ V = 6, DEY and DEX
 DEY                    \ V = 7, DEX and DEY

 EQUB &18, &EA
 EQUB &EA, &18
 EQUB &18, &EA
 EQUB &EA, &18

\ ******************************************************************************
\
\       Name: mirrorAddressHi
\       Type: Variable
\   Category: Dashboard
\    Summary: The high byte of the base screen address of each mirror segment
\
\ ******************************************************************************

.mirrorAddressHi

 EQUB HI(mirror0)
 EQUB HI(mirror1)
 EQUB HI(mirror2)
 EQUB HI(mirror3)
 EQUB HI(mirror4)
 EQUB HI(mirror5)

\ ******************************************************************************
\
\       Name: mirrorSegment
\       Type: Variable
\   Category: Dashboard
\    Summary: Lookup table for working out which mirror segment a car should
\             appear in
\
\ ******************************************************************************

.mirrorSegment

 EQUB 18                \ Mirror segment 0 (left mirror, outer segment)
 EQUB 17                \ Mirror segment 1 (left mirror, middle segment)
 EQUB 16                \ Mirror segment 2 (left mirror, inner segment)

 EQUB 14                \ Mirror segment 3 (right mirror, inner segment)
 EQUB 13                \ Mirror segment 4 (right mirror, middle segment)
 EQUB 12                \ Mirror segment 5 (right mirror, outer segment)

 EQUB &81, &81          \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: dashData23
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData23

 SKIP 36                \ Populated with code from &7B3E to &7B61

\ ******************************************************************************
\
\       Name: xHeader
\       Type: Variable
\   Category: Text
\    Summary: Column number for printing mode 7 headers
\
\ ------------------------------------------------------------------------------
\
\ The values in this table are used by the PrintHeader routine to print out
\ headers in mode 7.
\
\ ******************************************************************************

.xHeader

 EQUB 4
 EQUB 7
 EQUB 9
 EQUB 7
 EQUB 0
 EQUB 3 + 8
 EQUB 7

\ ******************************************************************************
\
\       Name: yHeader
\       Type: Variable
\   Category: Text
\    Summary: Row number for printing mode 7 headers
\
\ ------------------------------------------------------------------------------
\
\ The values in this table are used by the PrintHeader routine to print out
\ headers in mode 7.
\
\ ******************************************************************************

.yHeader

 EQUB 3
 EQUB 0
 EQUB 0
 EQUB 0
 EQUB 4
 EQUB 4
 EQUB 0

\ ******************************************************************************
\
\       Name: headerSpaces
\       Type: Variable
\   Category: Text
\    Summary: Number of spaces for printing mode 7 headers
\
\ ------------------------------------------------------------------------------
\
\ The values in this table are used by the PrintHeader routine to print out
\ headers in mode 7.
\
\ ******************************************************************************

.headerSpaces

 EQUB 160 + 10
 EQUB 160 + 15
 EQUB 160 + 19
 EQUB 160 + 15
 EQUB 160 + 2
 EQUB 160 + 24
 EQUB 160 + 15

\ ******************************************************************************
\
\       Name: headerBackground
\       Type: Variable
\   Category: Text
\    Summary: Background colour for printing mode 7 headers
\
\ ------------------------------------------------------------------------------
\
\ The values in this table are used by the PrintHeader routine to print out
\ headers in mode 7.
\
\ ******************************************************************************

.headerBackground

 EQUB 129
 EQUB 129
 EQUB 133
 EQUB 132
 EQUB 163
 EQUB 131
 EQUB 133

\ ******************************************************************************
\
\       Name: headerForeground
\       Type: Variable
\   Category: Text
\    Summary: Foreground colour for printing mode 7 headers
\
\ ------------------------------------------------------------------------------
\
\ The values in this table are used by the PrintHeader routine to print out
\ headers in mode 7.
\
\ ******************************************************************************

.headerForeground

 EQUB 131
 EQUB 131
 EQUB 135
 EQUB 135
 EQUB 127
 EQUB 132
 EQUB 135

\ ******************************************************************************
\
\       Name: token46
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 46
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token46

 EQUB 22, 7             \ Switch to screen mode 7

 EQUB 23, 0, 10, 32     \ Disable cursor
 EQUB 0, 0, 0
 EQUB 0, 0, 0

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token24
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 24
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token24

 EQUB 200 + 35          \ Print token 35 (cyan, move cursor to prompt position)

 EQUB 200 + 10          \ Print token 10 ("SELECT ")

 EQUS "WING SETTINGS"   \ Print "WING SETTINGS"

 EQUB 200 + 16          \ Print token 16 (" > ")

 EQUS "range 0 to 40"   \ Print "range 0 to 40"

 EQUB 31, 14, 16        \ Move text cursor to column 14, row 16

 EQUS "rear"            \ Print "rear"

 EQUB 160 + 2           \ Print 2 spaces

 EQUB 133               \ Set foreground colour to magenta alphanumeric

 EQUB 200 + 16          \ Print token 16 (" > ")

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData24
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code that gets moved into screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData24

 SKIP 36                \ Populated with code from &7B1A to &7B3D

\ ******************************************************************************
\
\       Name: GetWingSettings
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Get the front and rear wing settings from the player
\
\ ******************************************************************************

.GetWingSettings

 LDX #5                 \ Print "THE  PITS" as a double-height header at column
 JSR PrintHeader        \ 11, row 4, in blue text on a yellow background

 LDX #24                \ Print token 24, which shows the prompt "SELECT WING
 JSR PrintToken         \ SETTINGS > range 0 to 40" and a further prompt of
                        \ "rear > "

 JSR GetNumberInput     \ Fetch a number from the keyboard

 STA rearWingSetting    \ Store the entered number in rearWingSetting

 LDX #25                \ Print token 25, which shows a prompt of "front > "
 JSR PrintToken

 JSR GetNumberInput     \ Fetch a number from the keyboard

 STA frontWingSetting   \ Store the entered number in frontWingSetting

 JSR WaitForSpace       \ Print a prompt and wait for SPACE to be pressed

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintRaceClass
\       Type: Subroutine
\   Category: Text
\    Summary: Print the race class
\
\ ******************************************************************************

.PrintRaceClass

 LDA raceClass          \ Set A to the race class + 7, so that gives us:
 CLC                    \
 ADC #7                 \   * 7 for Novice
 TAX                    \   * 8 for Amateur
                        \   * 9 for Professional

 JSR PrintToken         \ Print token X, which will be token 7 ("Novice"), token
                        \ 8 ("Amateur") or token 9 ("Professional")

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: token50
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 50
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token50

 EQUB 31, 24, 2         \ Move text cursor to column 24, row 2

 EQUB 200 + 18          \ Print token (configurable token number, default is 18,
                        \ which is " 5")

 EQUB 200 + 14          \ Print token 14 (" laps")

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token6
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 6
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token6

 EQUB 160 + 2           \ Print 2 spaces

 EQUS "BEST LAP TIMES"  \ Print "BEST LAP TIMES"

 EQUB 160 + 2           \ Print 2 spaces

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token13
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 13
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token13

 EQUS " mins"           \ Print " mins"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token14
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 14
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token14

 EQUS " laps"           \ Print " laps"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token15
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 15
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token15

 EQUS " RACE"           \ Print " RACE"

 EQUB 255               \ End token

 EQUS "ins"             \ These bytes appear to be unused
 EQUB &FF, &81
 EQUB &81, &81
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData25
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains code and part of the dashboard image that gets moved into
\             screen memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData25

 SKIP 10                \ Populated with part of the dashboard image

 SKIP 26                \ Populated with code from &7B00 to &7B19

\ ******************************************************************************
\
\       Name: objectIndex
\       Type: Variable
\   Category: 3D objects
\    Summary: Index range of an object's data in the object data tables
\  Deep dive: Object definitions
\
\ ------------------------------------------------------------------------------
\
\ Given an object type, this table contains the index range for the object's
\ data in the objectTop, objectBottom, objectLeft, objectRight and objectColour
\ tables.
\
\ ******************************************************************************

.objectIndex

 EQUB 0                 \ Object type  0 =  0 to  4
 EQUB 5                 \ Object type  1 =  5 to  8
 EQUB 9                 \ Object type  2 =  9 to 13
 EQUB 14                \ Object type  3 = 14 to 17
 EQUB 18                \ Object type  4 = 18 to 24
 EQUB 25                \ Object type  5 = 25
 EQUB 26                \ Object type  6 = 26
 EQUB 27                \ Object type  7 = 27 to 29
 EQUB 30                \ Object type  8 = 30 to 31
 EQUB 32                \ Object type  9 = 32 to 33
 EQUB 34                \ Object type 10 = 34 to 36
 EQUB 37                \ Object type 11 = 37 to 38
 EQUB 39                \ Object type 12 = 39 to 40

\ ******************************************************************************
\
\       Name: scaffoldIndex
\       Type: Variable
\   Category: 3D objects
\    Summary: Index of an object's scaffold in the objectScaffold table
\  Deep dive: Scaling objects with scaffolds
\
\ ------------------------------------------------------------------------------
\
\ Given an object type, this table contains the index range for the object's
\ scaffold in the objectScaffold table.
\
\ ******************************************************************************

.scaffoldIndex

 EQUB 0                 \ Object type  0 =  0 to  7
 EQUB 8                 \ Object type  1 =  8 to 15
 EQUB 16                \ Object type  2 = 16 to 23
 EQUB 24                \ Object type  3 = 24 to 29
 EQUB 30                \ Object type  4 = 30 to 37
 EQUB 38                \ Object type  5 = 38 to 40
 EQUB 41                \ Object type  6 = 41 to 43
 EQUB 44                \ Object type  7 = 44 to 48
 EQUB 49                \ Object type  8 = 49 to 52
 EQUB 53                \ Object type  9 = 53 to 56
 EQUB 57                \ Object type 10 = 57 to 61
 EQUB 62                \ Object type 11 = 62 to 65
 EQUB 66                \ Object type 12 = 66 to 69
 EQUB 70

\ ******************************************************************************
\
\       Name: GetDriverAddress
\       Type: Subroutine
\   Category: Text
\    Summary: Get the address of the specified driver's name
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates the address of driver A's name using the following:
\
\   (Y A) = driverNames1 + (A div 4) * &100 + (A mod 4) * 12
\
\ The names of the 20 drivers are stored in in five blocks within the main game
\ code. Each block of contains four names, each of which is 12 characters long.
\ The blocks start every &100 (256) bytes, starting with the first block at
\ driverNames1 and going through to driverNames5.
\
\ Given driver number A, A div 4 is the block number, while A mod 4 is the
\ number of the 12-character name within that block. So we have:
\
\   * (A div 4) * &100 is the address of the start of the block containing the
\     name of driver A
\
\   * (A mod 4) * 12 is the offset of driver A's 12-character name within that
\     block
\
\ The first block is at driverNames1, so we add them together to arrive at the
\ calculation above.
\
\ Arguments:
\
\   X                   The driver number (0 to 19)
\
\ Returns:
\
\   (Y A)               The address of the driver's 12-character name
\
\ ******************************************************************************

.GetDriverAddress

 TXA                    \ We start with the high byte of the calculation, which
 LSR A                  \ is Y = HI(driverNames1) + (A div 4)
 LSR A
 CLC
 ADC #HI(driverNames1)
 TAY

                        \ And now we do the low byte calculation, which is
                        \ A = LO(driverNames1) + (A mod 4) * 12

 TXA                    \ Set A = (A mod 4) * 4
 AND #3
 ASL A
 ASL A

 STA T                  \ Set T = A
                        \       = (A mod 4) * 4

 ASL A                  \ Set A = (A mod 4) * 8

 CLC                    \ Set A = A + T
 ADC T                  \       = (A mod 4) * 8 + (A mod 4) * 4
                        \       = (A mod 4) * 12

 ADC #LO(driverNames1)  \ Set A = LO(driverNames1) + A
                        \       = LO(driverNames1) + (A mod 4) * 12

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: token27
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 27
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token27

 EQUB 200 + 54          \ Print token 54 ("FORMULA 3  CHAMPIONSHIP" header)

 EQUB 200 + 36          \ Print token 36 (menu option 1 with "PRESS" prompt)

 EQUB 200 + 11          \ Print token 11 ("ENTER ")

 EQUS "ANOTHER"         \ Print "ANOTHER"

 EQUB 200 + 12          \ Print token 12 (" DRIVER")

 EQUB 200 + 37          \ Print token 37 (menu option 2)

 EQUS "START"           \ Print "START"

 EQUB 200 + 15          \ Print token 15 (" RACE")

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token34
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 34
\
\ ------------------------------------------------------------------------------
\
\ The configurable values below are set in the PrintHeader routine.
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token34

 EQUB 141               \ Set double-height text

 EQUB 129, 157          \ Set background colour (configurable, default is red)

 EQUB 131               \ Set foreground colour (configurable, default is yellow
                        \ alphanumeric)

 EQUB 200+0             \ Print token (configurable token number, default is 0,
                        \ which is "FORMULA 3  CHAMPIONSHIP")

 EQUB 160+2             \ Print spaces (configurable, default is 2 spaces)

 EQUB 156               \ Set background colour to black

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData26
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData26

 SKIP 41

\ ******************************************************************************
\
\       Name: PrintSpaces
\       Type: Subroutine
\   Category: Text
\    Summary: Print the specified number of spaces
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of spaces to print (1 to 39)
\
\ Returns:
\
\   Z flag              Set (so a BEQ following the routine call will always
\                       branch)
\
\ ******************************************************************************

.PrintSpaces

 STA T                  \ Set T to the number of spaces to print to use as a
                        \ loop counter

.spac1

 LDA #' '               \ Print a space
 JSR PrintCharacter

 DEC T                  \ Decrement the loop counter

 BNE spac1              \ Loop back until we have printed the right number of
                        \ spaces

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawFence (Part 1 of 2)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the fence that we crash into when running off the track
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   DrawFence-1         Contains an RTS
\
\ ******************************************************************************

.DrawFence

 LDA #0                 \ Set playerMoving = 0 to denote that the player's car
 STA playerMoving       \ is not moving

 STA T                  \ Set T = 0, to use as a counter as we work our way
                        \ through the 40 dash data blocks that contain the track
                        \ view

 STA P                  \ Set (Q P) to point to the first dash data block at
 LDA #HI(dashData)      \ dashData (this works because the low byte of dashData
 STA Q                  \ is zero)

.fenc1

 LDX T                  \ If X = 40 then we have drawn the fencs across all the
 CPX #40                \ dash data blocks, so return from the subroutine (as
 BEQ DrawFence-1        \ DrawFence-1 contains an RTS)

 LDA dashDataOffset,X   \ Set U to the dashDataOffset for the current dash data
 STA U                  \ block

 LDY #70                \ Set Y = 70, to use as a loop counter that works
                        \ through all 70 bytes in the dash data block

 JMP fenc2              \ We now jump to part 2 to work our way through the 70
                        \ bytes in the dash data block, each of which represents
                        \ a four-pixel line, with 70 lines stacked one on top of
                        \ the other, in a four-pixel-wide vertical strip

\ ******************************************************************************
\
\       Name: fencePixelsGrass
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel bytes for the fence with green grass behind it
\
\ ******************************************************************************

.fencePixelsGrass

 EQUB %10101010         \ Four pixels: green, black, green, black
 EQUB %01110111         \ Four pixels: black, green, green, green
 EQUB %10101010         \ Four pixels: green, black, green, black
 EQUB %11011101         \ Four pixels: green, green, black, green

\ ******************************************************************************
\
\       Name: fencePixelsSky
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel bytes for the fence with blue sky behind it
\
\ ******************************************************************************

.fencePixelsSky

 EQUB %00001010         \ Four pixels: blue, black, blue, black
 EQUB %00000111         \ Four pixels: black, blue, blue, blue
 EQUB %00001010         \ Four pixels: blue, black, blue, black
 EQUB %00001101         \ Four pixels: blue, blue, black, blue

\ ******************************************************************************
\
\       Name: token21
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 21
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token21

 EQUB 200 + 54          \ Print token 54 ("FORMULA 3  CHAMPIONSHIP" header)

 EQUB 200 + 36          \ Print token 36 (menu option 1 with "PRESS" prompt)

 EQUB 200 + 7           \ Print token 7 ("Novice")

 EQUB 200 + 37          \ Print token 37 (menu option 2)

 EQUB 200 + 8           \ Print token 8 ("Amateur")

 EQUB 200 + 38          \ Print token 38 (menu option 3)

 EQUB 200 + 9           \ Print token 9 ("Professional")

 EQUB 200 + 35          \ Print token 35 (cyan, move cursor to prompt position)

 EQUB 160 + 4           \ Print 4 spaces

 EQUB 200 + 10          \ Print token 10 ("SELECT ")

 EQUS "THE CLASS OF"    \ Print "THE CLASS OF"

 EQUB 200 + 15          \ Print token 15 (" RACE")

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData27
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData27

 SKIP 52

\ ******************************************************************************
\
\       Name: L3DD0
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L3DD0

 EQUB &00, &27, &12, &09, &03, &03, &03, &03, &03, &03, &03, &03
 EQUB &03, &03, &03, &03, &03, &03

\ ******************************************************************************
\
\       Name: shiftedKeys
\       Type: Variable
\   Category: Keyboard
\    Summary: Negative inkey values for the configuration keys that are pressed
\             in combination with SHIFT
\
\ ******************************************************************************

.shiftedKeys

 EQUB &86               \ Right arrow
 EQUB &8E               \ f1
 EQUB &8D               \ f2
 EQUB &8D               \ f2
 EQUB &EB               \ f4
 EQUB &8B               \ f5
 EQUB &DF               \ f0
 EQUB &96               \ COPY
 EQUB &A6               \ DELETE
 EQUB &E9               \ f7

IF _SUPERIOR

 EQUB &8C               \ f3
 EQUB &8A               \ f6

ENDIF

\ ******************************************************************************
\
\       Name: menuKeys
\       Type: Variable
\   Category: Keyboard
\    Summary: Negative inkey values for the menu keys (SPACE, "1", "2" and "3")
\             for the Acornsoft release
\
\ ******************************************************************************

IF _ACORNSOFT

.menuKeys

 EQUB &9D               \ Negative inkey value for SPACE
 EQUB &CF               \ Negative inkey value for "1"
 EQUB &CE               \ Negative inkey value for "2"
 EQUB &EE               \ Negative inkey value for "3"

ELIF _SUPERIOR

 EQUB &CE, &EE          \ These bytes appear to be unused

ENDIF

\ ******************************************************************************
\
\       Name: timeFromOption
\       Type: Variable
\   Category: Drivers
\    Summary: Table to convert from the option numbers in the qualifying lap
\             duration menu to the actual number of minutes
\
\ ------------------------------------------------------------------------------
\
\ Interestingly, the menu offers 5, 10 and 20 minutes, but these translate into
\ 5, 10 and 26 minutes of actual qualifying time.
\
\ ******************************************************************************

.timeFromOption

 EQUB 4, 9, 25

 EQUB 0                 \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: lapsFromOption
\       Type: Variable
\   Category: Drivers
\    Summary: Table to convert from the option numbers in the laps menu to the
\             actual number of laps
\
\ ******************************************************************************

.lapsFromOption

 EQUB 5, 10, 20

\ ******************************************************************************
\
\       Name: pointsForPlace
\       Type: Variable
\   Category: Drivers
\    Summary: The points awarded for the top six places, plus the fastest lap
\
\ ******************************************************************************

.pointsForPlace

 EQUB 9                 \ Points for first place
 EQUB 6                 \ Points for second place
 EQUB 4                 \ Points for third place
 EQUB 3                 \ Points for fourth place
 EQUB 2                 \ Points for fifth place
 EQUB 1                 \ Points for sixth place

 EQUB 1                 \ Points for the fastest lap

 EQUB 0, 0              \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: token29
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 29
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token29

 EQUB 200 + 54          \ Print token 54 ("FORMULA 3  CHAMPIONSHIP" header)

 EQUB 200 + 35          \ Print token 35 (cyan, move cursor to prompt position)

 EQUB 160 + 5           \ Print 5 spaces

 EQUB 130               \ Set foreground colour to green alphanumeric

 EQUB 200 + 12          \ Print token 12 (" DRIVER")

 EQUB 200 + 16          \ Print token 16 (" > ")

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token9
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 9
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token9

 EQUS "Professional"    \ Print "Professional"

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData28
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData28

 SKIP 56

\ ******************************************************************************
\
\       Name: L3E50
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L3E50

 EQUB &08, &13, &1E, &29, &39, &44, &4F, &5A, &02, &0D, &18, &23
 EQUB &33, &3E, &49, &54

\ ******************************************************************************
\
\       Name: SetRowColours
\       Type: Subroutine
\   Category: Text
\    Summary: Set the foreground and background colorus for a table row
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   Table row number
\
\   colourScheme        Colour scheme: 0, 4, 8
\
\ ******************************************************************************

.SetRowColours

 TYA                    \ Set X = colourScheme      if Y is even
 AND #1                 \       = colourScheme + 1  if Y is odd
 CLC                    \
 ADC colourScheme       \ So X is now one of the following, depending on the
 TAX                    \ colour scheme and whether the row number is even or
                        \ odd:
                        \
                        \   * Scheme 0: 0 (even) or 1 (odd)
                        \   * Scheme 4: 4 (even) or 5 (odd)
                        \   * Scheme 8: 8 (even) or 9 (odd)
                        \
                        \ We now fetch the colour palette from the rowColours
                        \ table using the following offsets:
                        \
                        \   * Scheme 0: 0 on 2  (even) or 1 on 3  (odd)
                        \   * Scheme 4: 4 on 6  (even) or 5 on 7  (odd)
                        \   * Scheme 8: 8 on 10 (even) or 9 on 11 (odd)

 LDA rowColours,X       \ Set the configurable foreground colour in token 31 to
 STA token31+5          \ the X-th entry in the rowColours table

 LDA rowColours+2,X     \ Set the configurable background colour in token 31 to
 STA token31+3          \ the X+2-th entry in the rowColours table

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: rowColours
\       Type: Variable
\   Category: Text
\    Summary: Three different palettes for displaying even-odd rows in tables
\
\ ******************************************************************************

.rowColours

 EQUB 132, 133          \ Scheme 0: Even rows: 132 on 134 (blue on cyan)
 EQUB 134, 135          \           Odd rows:  134 on 135 (cyan on white)

 EQUB 129, 132          \ Scheme 4: Even rows: 129 on 132 (red on blue)
 EQUB 131, 130          \           Odd rows:  131 on 130 (yellow on green)

 EQUB 131, 132          \ Scheme 8: Even rows: 131 on 132 (yellow on blue)
 EQUB 129, 135          \           Odd rows:  129 on 135 (red on white)

\ ******************************************************************************
\
\       Name: token10
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 10
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token10

 EQUS "SELECT "         \ Print "SELECT "

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token12
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 12
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token12

 EQUS " DRIVER"         \ Print " DRIVER"

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData29
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData29

 SKIP 60

\ ******************************************************************************
\
\       Name: L3ED0
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L3ED0

 EQUB &00, &0B, &16, &21, &2E, &39, &44, &4F

\ ******************************************************************************
\
\       Name: L3ED8
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L3ED8

 EQUB &4F, &44, &39, &2E, &21, &16, &0B, &00

\ ******************************************************************************
\
\       Name: GetNumberInput
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Fetch a number between 0 and 40 from the keyboard
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The value of the number entered (0 to 40)
\
\ ******************************************************************************

.GetNumberInput

 LDA #LO(T)             \ Set (Y A) = T
 LDY #HI(T)

 LDX #2                 \ Fetch a string of up to two characters from the
 JSR GetTextInput       \ keyboard, store the characters at location T and U (as
                        \ U = T + 1), and set Y to the number of characters
                        \ entered

 JSR GetNumberFromText  \ Convert the two-character input into a number in A,
                        \ and report the conversion status in the C flag

 BCC numb2              \ If we got a valid number that is 40 or less then the C
                        \ flag will be clear, so jump to numb2 to return from
                        \ the subroutine

.numb1

 DEY                    \ Decrement the number of characters in the entered
                        \ string, which is in Y

 BMI GetNumberInput     \ If Y is now negative, then there are no characters
                        \ left on-screen, so jump back to the start of the
                        \ routine to try fetching another number

 LDA #127               \ Otherwise delete the last character shown on-screen by
 JSR OSWRCH             \ printing a delete character (ASCII 127)

 JMP numb1              \ Jump back to numb1 to delete any other on-screen
                        \ characters before starting again

.numb2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: startMirror
\       Type: Variable
\   Category: Dashboard
\    Summary: The offset from mirrorAddress for the start of each mirror segment
\
\ ******************************************************************************

.startMirror

 EQUB &AA               \ Mirror segment 0 (left mirror, outer segment)
 EQUB &AC               \ Mirror segment 1 (left mirror, middle segment)
 EQUB &B0               \ Mirror segment 2 (left mirror, inner segment)

 EQUB &B0               \ Mirror segment 3 (right mirror, inner segment)
 EQUB &AC               \ Mirror segment 4 (right mirror, middle segment)
 EQUB &AA               \ Mirror segment 5 (right mirror, outer segment)

\ ******************************************************************************
\
\       Name: token37
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 37
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token37

 EQUB 31, 5, 18         \ Move text cursor to column 5, row 18

 EQUB 132, 157          \ Set background colour to blue

 EQUB 134               \ Set foreground colour to cyan alphanumeric

 EQUS "2"               \ Print "2"

 EQUB 160 + 2           \ Print 2 spaces

 EQUB 156               \ Set background colour to black

 EQUB 160 + 5           \ Print 5 spaces

 EQUB 131               \ Set foreground colour to yellow alphanumeric

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData30
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData30

 SKIP 64

\ ******************************************************************************
\
\       Name: fillDataOffset
\       Type: Variable
\   Category: Graphics
\    Summary: Dash data offsets, tweaked to give bottom line values that are
\             compatible with the process of filling blocks to the left
\  Deep dive: Creating objects from edges
\
\ ------------------------------------------------------------------------------
\
\ Contains dash data offsets that are skewed so that dash data blocks whose left
\ neighbours start lower down the screen than they do (i.e. they have a smaller
\ offset) contain the left neighbour's offset rather than their own.
\
\ This ensures that when filling blocks to the left of the current block, the
\ value of the bottom line (i.e. the offset) is set to the bottom of the column
\ being filled, rather than the smaller column to its right.
\
\ ******************************************************************************

.fillDataOffset

 EQUB dashData0  - (dashData + &80 *  0) - 1    \ These match dashDataOffset
 EQUB dashData1  - (dashData + &80 *  1) - 1
 EQUB dashData2  - (dashData + &80 *  2) - 1
 EQUB dashData3  - (dashData + &80 *  3) - 1
 EQUB dashData4  - (dashData + &80 *  4) - 1
 EQUB dashData5  - (dashData + &80 *  5) - 1
 EQUB dashData6  - (dashData + &80 *  6) - 1

 EQUB dashData6  - (dashData + &80 *  6) - 1    \ dashData6 repeated, as block 7
                                                \ is smaller than block 6

 EQUB dashData7  - (dashData + &80 *  7) - 1    \ These are out by one, so the
 EQUB dashData8  - (dashData + &80 *  8) - 1    \ X-th entry is the offset for
 EQUB dashData9  - (dashData + &80 *  9) - 1    \ block X - 1
 EQUB dashData10 - (dashData + &80 * 10) - 1
 EQUB dashData11 - (dashData + &80 * 11) - 1
 EQUB dashData12 - (dashData + &80 * 12) - 1
 EQUB dashData13 - (dashData + &80 * 13) - 1
 EQUB dashData14 - (dashData + &80 * 14) - 1
 EQUB dashData15 - (dashData + &80 * 15) - 1
 EQUB dashData16 - (dashData + &80 * 16) - 1
 EQUB dashData17 - (dashData + &80 * 17) - 1
 EQUB dashData18 - (dashData + &80 * 18) - 1
 EQUB dashData19 - (dashData + &80 * 19) - 1
 EQUB dashData20 - (dashData + &80 * 20) - 1
 EQUB dashData21 - (dashData + &80 * 21) - 1
 EQUB dashData22 - (dashData + &80 * 22) - 1
 EQUB dashData23 - (dashData + &80 * 23) - 1
 EQUB dashData24 - (dashData + &80 * 24) - 1

                                                \ dashData25 skipped as block 26
                                                \ is larger than block 25

 EQUB dashData26 - (dashData + &80 * 26) - 1    \ These match dashDataOffset
 EQUB dashData27 - (dashData + &80 * 27) - 1
 EQUB dashData28 - (dashData + &80 * 28) - 1
 EQUB dashData29 - (dashData + &80 * 29) - 1
 EQUB dashData30 - (dashData + &80 * 30) - 1
 EQUB dashData31 - (dashData + &80 * 31) - 1
 EQUB dashData32 - (dashData + &80 * 32) - 1
 EQUB dashData33 - (dashData + &80 * 33) - 1
 EQUB dashData34 - (dashData + &80 * 34) - 1

 EQUB dashData34 - (dashData + &80 * 34) - 1    \ dashData34 repeated, as block
                                                \ 35 is smaller than block 34

 EQUB dashData35 - (dashData + &80 * 35) - 1    \ These are out by one, so the
 EQUB dashData36 - (dashData + &80 * 36) - 1    \ X-th entry is the offset for
                                                \ block X - 1

                                                \ dashData37 skipped as block 38
                                                \ is larger than block 37

 EQUB dashData38 - (dashData + &80 * 38) - 1    \ These match dashDataOffset
 EQUB dashData39 - (dashData + &80 * 39) - 1

 EQUB dashData40 - (dashData + &80 * 40) - 1    \ Not used for the screen buffer

 EQUB &20, &20          \ These bytes appear to be unused
 EQUB &20, &42
 EQUB &65, &68
 EQUB &69

\ ******************************************************************************
\
\       Name: token7
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 7
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token7

 EQUS "Novice"          \ Print "Novice"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: L3F87
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L3F87

 EQUB &81, &81, &81, &81, &81

\ ******************************************************************************
\
\       Name: dashData31
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData31

 SKIP 68

 EQUB &88, &EA          \ These bytes appear to be unused
 EQUB &EA, &C8
 EQUB &EA, &88
 EQUB &C8, &EA
 EQUB &C8, &EA
 EQUB &EA, &88
 EQUB &EA, &C8
 EQUB &88, &EA

\ ******************************************************************************
\
\       Name: yLookupLo
\       Type: Variable
\   Category: Graphics
\    Summary: Lookup table for converting pixel y-coordinate to low byte of
\             screen address
\
\ ------------------------------------------------------------------------------
\
\ For character rows 0 to 7 and 16 to 31, this table returns the low byte of
\ the screen address of the start of the row, for the custom screen mode.
\
\ For character rows 8 to 15, the table is reused, as these locations would
\ point to the blue sky, and we don't draw in the sky as it contains working
\ game code. Instead, the lookup table at yLookupLo+8 contains pixel masks for
\ use in the line-drawing routine at DrawDashboardLine.
\
\ ******************************************************************************

.yLookupLo

FOR I%, 0, 7

 EQUB LO(&5800 + (I% * &140))

NEXT

 EQUB %01110111         \ Clear the first pixel of a mode 5 pixel byte
 EQUB %10111011         \ Clear the second pixel of a mode 5 pixel byte
 EQUB %11011101         \ Clear the third pixel of a mode 5 pixel byte
 EQUB %11101110         \ Clear the fourth pixel of a mode 5 pixel byte

 EQUB %01110111         \ Clear the first pixel of a mode 5 pixel byte
 EQUB %10111011         \ Clear the second pixel of a mode 5 pixel byte
 EQUB %11011101         \ Clear the third pixel of a mode 5 pixel byte
 EQUB %11101110         \ Clear the fourth pixel of a mode 5 pixel byte

FOR I%, 16, 31

 EQUB LO(&5800 + (I% * &140))

NEXT

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData32
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData32

 SKIP 73

\ ******************************************************************************
\
\       Name: driverNames1
\       Type: Variable
\   Category: Text
\    Summary: The first batch of driver names (1 of 5)
\
\ ******************************************************************************

.driverNames1

 EQUS "Max Throttle"
 EQUS "Johnny Turbo"
 EQUS "Davey Rocket"
 EQUS "Gloria Slap "

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData33
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData33

 SKIP 77

\ ******************************************************************************
\
\       Name: L40D0
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L40D0

 EQUB &5A, &4F, &44, &39, &29, &1E, &13, &08, &54, &49, &3E, &33
 EQUB &23, &18, &0D, &02

\ ******************************************************************************
\
\       Name: token33
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 33
\
\ ------------------------------------------------------------------------------
\
\ The configurable values below are set in the PrintHeader routine.
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token33

 EQUB 12                \ Clear text area (clear screen)

 EQUB 31, 4, 3          \ Move text cursor (configurable, default is column 4,
                        \ row 3)

 EQUB 200 + 34          \ Print token 34 (double-height, text and colours are
                        \ configurable)

 EQUB 160 + 10          \ Print spaces (configurable, default is 10 spaces)

 EQUB 200 + 34          \ Print token 34 (double-height, text and colours are
                        \ configurable)

 EQUB 31, 36, 2         \ Move text cursor to column 36, row 2

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: ResetBestLapTime
\       Type: Subroutine
\   Category: Drivers
\    Summary: Reset the best lap time to 10:00.0 for a specific driver
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The driver number (0 to 19)
\
\ ******************************************************************************

.ResetBestLapTime

 LDA #0                 \ Zero the bestLapTenths entry for driver X
 STA bestLapTenths,X

 STA bestLapSeconds,X   \ Zero the bestLapSeconds entry for driver X

 LDA #&10               \ Set the bestLapMinutes for driver X to 10 (as is it a
 STA bestLapMinutes,X   \ BCD number)

 RTS                    \ Return from the subroutine

 EQUB &77               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: endMirror
\       Type: Variable
\   Category: Dashboard
\    Summary: The offset from mirrorAddress for the end of each mirror segment
\
\ ******************************************************************************

.endMirror

 EQUB &C2               \ Mirror segment 0 (left mirror, outer segment)
 EQUB &C0               \ Mirror segment 1 (left mirror, middle segment)
 EQUB &BC               \ Mirror segment 2 (left mirror, inner segment)

 EQUB &BC               \ Mirror segment 3 (right mirror, inner segment)
 EQUB &C0               \ Mirror segment 4 (right mirror, middle segment)
 EQUB &C2               \ Mirror segment 5 (right mirror, outer segment)

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81

\ ******************************************************************************
\
\       Name: dashData34
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData34

 SKIP 77

\ ******************************************************************************
\
\       Name: driverNames2
\       Type: Variable
\   Category: Text
\    Summary: The second batch of driver names (2 of 5)
\
\ ******************************************************************************

.driverNames2

 EQUS "Hugh Jengine"
 EQUS "Desmond Dash"
 EQUS "Percy Veer  "
 EQUS "Gary Clipper"

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData35
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData35

 SKIP 76

\ ******************************************************************************
\
\       Name: PrintHeader
\       Type: Subroutine
\   Category: Text
\    Summary: Configure and print a double-height header in screen mode 7
\  Deep dive: Text tokens
\
\ ------------------------------------------------------------------------------
\
\ Prints a token as a double-height header, with the position and colours given
\ in the header tables, and a specific number of spaces between the top and
\ bottom parts of the double-height text (to ensure they line up).
\
\ The tokens are formatted as follows:
\
\   * Token 0 ("FORMULA 3  CHAMPIONSHIP")
\     Column 4, row 3
\     Yellow on red
\     10 spaces
\
\   * Token 1 ("      POINTS      ")
\     Column 7, row 0
\     Yellow on red
\     15 spaces
\
\   * Token 2 ("GRID POSITIONS")
\     Column 9, row 0
\     White on magenta
\     19 spaces
\
\   * Token 3 ("ACCUMULATED POINTS")
\     Column 7, row 0
\     White on blue
\     15 spaces
\
\   * Token 4 ("REVS   REVS   REVS")
\     Column 0, row 4
\     The colours of each letter in REVS are magenta/yellow/cyan/green
\     2 spaces
\
\     This token actually prints characters 141, 163, 157, 127 before printing
\     token 4 (which it does twice, one for each part of the header). 127 is
\     the DEL character, so this is the same as printing just 141 and 163,
\     which sets double-height, and then shows graphics character 163. This
\     latter character will blank as we are still in alphanumeric text mode...
\     so overall this just displays a double-height token 4, as token 4 contains
\     all the colour information for the individual letters
\
\   * Token 5 ("THE  PITS")
\     Column 11, row 4
\     Blue on yellow
\     24 spaces
\
\   * Token 6 ("  BEST LAP TIMES  ")
\     Column 7, row 0
\     White on magenta
\     15 spaces
\
\ Arguments:
\
\   X                   The number of the token to print as a double-height
\                       header
\
\ ******************************************************************************

.PrintHeader

 LDA xHeader,X          \ Set the x-coordinate for the text in token 33
 STA token33+2

 LDA yHeader,X          \ Set the y-coordinate for the text in token 33
 STA token33+3

 LDA headerSpaces,X     \ Set the number of spaces in token 33
 STA token33+5

 LDA headerBackground,X \ Set the background colour in token 34
 STA token34+1

 LDA headerForeground,X \ Set the foreground colour in token 34
 STA token34+3

 TXA                    \ Set the token embedded in token 34 to token X
 CLC
 ADC #200
 STA token34+4

 LDX #33                \ Print token 33, which prints token 34 in double-height
 JSR PrintToken         \ text with the colours and position configured above

 RTS                    \ Return from the subroutine

 EQUB &79, &7B          \ These bytes appear to be unused
 EQUB &7C, &7D
 EQUB &7E

\ ******************************************************************************
\
\       Name: token1
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 1
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token1

 EQUB 160 + 5           \ Print 5 spaces

 EQUB 200 + 51          \ Print token 51 (" POINTS")

 EQUB 160 + 6           \ Print 6 spaces

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData36
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData36

 SKIP 58

\ ******************************************************************************
\
\       Name: driverNames3
\       Type: Variable
\   Category: Text
\    Summary: The third batch of driver names (3 of 5)
\
\ ******************************************************************************

.driverNames3

 EQUS "Willy Swerve"
 EQUS "Sid Spoiler "
 EQUS "Billy Bumper"
 EQUS "Slim Chance "

\ ******************************************************************************
\
\       Name: token40
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 40
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token40

 EQUS "Lap Time"        \ Print "Lap Time"

 EQUB 160 + 3           \ Print 3 spaces

 EQUS ":"               \ Print ":"

 EQUB 160 + 9           \ Print 9 spaces

 EQUS "Best Time"       \ Print "Best Time"

 EQUB 160 + 8           \ Print 8 spaces

 EQUB 255               \ End token

 EQUB &81, &81          \ These bytes appear to be unused
 EQUB &81, &81
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData37
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData37

 SKIP 52

\ ******************************************************************************
\
\       Name: PrintGearNumber
\       Type: Subroutine
\   Category: Text
\    Summary: Print the number of the current gear in double-width characters on
\             the gear stick
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The gear number to print on the stick:
\
\                         * 0 = reverse
\
\                         * 1 = neutral
\
\                         * 2-7 = 1 to 5
\
\ ******************************************************************************

.PrintGearNumber

 LDA #34                \ Move the cursor to character column 34
 STA xCursor

 STA W                  \ Set W to a non-zero value with bit 7 clear, so the
                        \ call to PrintCharacter-6 prints the left half of the
                        \ double-width character

 LDA #215               \ Move the cursor to pixel row 215
 STA yCursor

 LDX gearNumber         \ Set X to the current gear number

 LDA gearNumberText,X   \ Set A to the character to print for this gear number

 JSR PrintCharacter-6   \ Print the left half of the double-width character

 LDX #&FF               \ Set W to a non-zero value with bit 7 set, so the
 STX W                  \ call to PrintCharacter-6 prints the right half of the
                        \ double-width character

 JSR PrintCharacter-6   \ Print the right half of the double-width character

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ResetBestLapTimes
\       Type: Subroutine
\   Category: Drivers
\    Summary: Reset the best lap times to 10:00.0 for all drivers
\
\ ******************************************************************************

.ResetBestLapTimes

 LDX #19                \ We are about to reset the current lap times for
                        \ all 20 drivers, so set a driver counter in X

.rall1

 JSR ResetBestLapTime   \ Reset the best lap time to 10:00.0 for driver X

 DEX                    \ Decrement the driver counter

 BPL rall1              \ Loop back to reset the next set of bytes until we have
                        \ reset all 20 drivers

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: token52
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 52
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token52

 EQUB 133               \ Set foreground colour to magenta alphanumeric

 EQUS "R"               \ Print "R"

 EQUB 131               \ Set foreground colour to yellow alphanumeric

 EQUS "E"               \ Print "E"

 EQUB 134               \ Set foreground colour to cyan alphanumeric

 EQUS "V"               \ Print "V"

 EQUB 130               \ Set foreground colour to green alphanumeric

 EQUS "S"               \ Print "S"

 EQUB 255               \ End token

 EQUB &75, &75          \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: token28
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 28
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token28

 EQUB 200 + 54          \ Print token 54 ("FORMULA 3  CHAMPIONSHIP" header)

 EQUB 200 + 35          \ Print token 35 (cyan, move cursor to prompt position)

 EQUB 160 + 6           \ Print 6 spaces

 EQUB 200 + 10          \ Print token 10 ("SELECT ")

 EQUS "NUMBER OF LAPS"  \ Print "NUMBER OF LAPS"

 EQUB 200 + 36          \ Print token 36 (menu option 1 with "PRESS" prompt)

 EQUB 200 + 18          \ Print token 18 (" 5")

 EQUB 200 + 14          \ Print token 14 (" laps")

 EQUB 200 + 37          \ Print token 37 (menu option 2)

 EQUB 200 + 19          \ Print token 19 ("10")

 EQUB 200 + 14          \ Print token 14 (" laps")

 EQUB 200 + 38          \ Print token 38 (menu option 3)

 EQUB 200 + 20          \ Print token 20 ("20")

 EQUB 200 + 14          \ Print token 14 (" laps")

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData38
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData38

 SKIP 52

\ ******************************************************************************
\
\       Name: driverNames4
\       Type: Variable
\   Category: Text
\    Summary: The fourth batch of driver names (4 of 5)
\
\ ******************************************************************************

.driverNames4

 EQUS "Harry Fume  "
 EQUS "Dan Dipstick"
 EQUS "Wilma Cargo "
 EQUS "Miles Behind"

\ ******************************************************************************
\
\       Name: token5
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 5
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token5

 EQUS "THE  PITS"       \ Print "THE  PITS"

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: token36
\       Type: Variable
\   Category: Text
\    Summary: Text for recursive token 36
\  Deep dive: Text tokens
\
\ ******************************************************************************

.token36

 EQUB 31, 4, 14         \ Move text cursor to column 4, row 14

 EQUB 136               \ Set flashing text

 EQUB 134               \ Set foreground colour to cyan alphanumeric

 EQUB 200 + 17          \ Print token 17 ("PRESS ")

 EQUB 31, 5, 16         \ Move text cursor to column 5, row 16

 EQUB 132, 157          \ Set background colour to blue

 EQUB 134               \ Set foreground colour to cyan alphanumeric

 EQUS "1"               \ Print "1"

 EQUB 160 + 2           \ Print 2 spaces

 EQUB 156               \ Set background colour to black

 EQUB 160 + 5           \ Print 5 spaces

 EQUB 131               \ Set foreground colour to yellow alphanumeric

 EQUB 255               \ End token

\ ******************************************************************************
\
\       Name: dashData39
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData39

 SKIP 52

\ ******************************************************************************
\
\       Name: Print234DigitBCD
\       Type: Subroutine
\   Category: Text
\    Summary: Print a specific driver's accumulated points as a padded two-,
\             three- or four-digit number
\
\ ------------------------------------------------------------------------------
\
\ Print (totalPointsHi totalPointsLo) for driver X as a four-digit number,
\ followed by a space. The first two digits are printed as spaces if the high
\ byte is zero, and the third digit is printed as a space if applicable.
\
\ ******************************************************************************

.Print234DigitBCD

 LDA #2                 \ Print two spaces
 JSR PrintSpaces

 LDA #%00100000         \ Set G = %00100000, so if we print the high byte and
 STA G                  \ the first digit is 0, it will be replaced by a space

 LDA totalPointsHi,X    \ Set A to the X-th totalPointsHi value

 BNE Print4DigitBCD     \ If A is non-zero, jump to Print4DigitBCD to print the
                        \ (totalPointsHi totalPointsLo) for driver X as a
                        \ four-digit number

 LDA #2                 \ Otherwise print two spaces for the first two digits,
 JSR PrintSpaces        \ as the high byte is zero

 LSR G                  \ Shift G right one place to give to %00010000, so the
                        \ next call to Print2DigitBCD will print a space for the
                        \ first digit if it is zero

 BNE Print4DigitBCD+3   \ Jump to Print4DigitBCD+3 to print the second two
                        \ digits in totalPointsLo (this BNE is effectively a JMP
                        \ as the result of the LSR is never zero)

\ ******************************************************************************
\
\       Name: Print4DigitBCD
\       Type: Subroutine
\   Category: Text
\    Summary: Print a specific driver's accumulated points as a four-digit
\             number
\
\ ------------------------------------------------------------------------------
\
\ Print (totalPointsHi totalPointsLo) for driver X as a 4-digit number, followed
\ by a space. The second digit is always printed.
\
\ Arguments:
\
\   A                   Always called with totalPointsHi,X
\
\ Other entry points:
\
\   Print4DigitBCD+3    Do not print the first two digits (i.e. omit printing A)
\
\ ******************************************************************************

.Print4DigitBCD

 JSR Print2DigitBCD     \ Print the binary coded decimal (BCD) number in A

 LDA totalPointsLo,X    \ Print the low byte of the total accumulated points for
 JSR Print2DigitBCD     \ driver X, which is a binary coded decimal (BCD) number

 LDA #1                 \ Print a space
 JSR PrintSpaces

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FlushSoundBuffers
\       Type: Subroutine
\   Category: Sound
\    Summary: Flush all four specified sound buffers
\
\ ******************************************************************************

.FlushSoundBuffers

 LDX #3                 \ We are about to flush all four sound channel buffers
                        \ (0 to 3), so set a loop counter in X

.P43F8

 JSR FlushSoundBuffer   \ Flush the buffer for sound channel X

 DEX                    \ Decrement the loop counter

 BPL P43F8              \ Loop back until we have flushed all four buffers

 RTS                    \ Return from the subroutine

 EQUB 0                 \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: dashRightEdge
\       Type: Variable
\   Category: Graphics
\    Summary: Storage for the first track pixel byte along the right edge of the
\             dashboard
\
\ ------------------------------------------------------------------------------
\
\ This table is used to store the track pixel byte that would be shown along
\ the right edge of the dashboard, but which is partially obscured by the edge.
\ This is stored so we can retrieve it when masking the pixel byte with the
\ dashboard edge when we draw the track line that starts at the right edge of
\ the dashboard.
\
\ There is a byte for each track line from 43 (the track line at the top of the
\ dashboard) down to 3 (the lowest track line, just above where the wing mirror
\ joins the car body). Lines 0 to 2 are not used.
\
\ ******************************************************************************

.dashRightEdge

 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81
 EQUB &81, &81

\ ******************************************************************************
\
\       Name: dashData40
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

.dashData40

 SKIP 52

\ ******************************************************************************
\
\       Name: driverNames5
\       Type: Variable
\   Category: Text
\    Summary: The fifth batch of driver names (5 of 5)
\
\ ------------------------------------------------------------------------------
\
\ The last driver name in this batch is used to store the player's name.
\
\ ******************************************************************************

.driverNames5

 EQUS "Roland Slide"
 EQUS "Rick Shaw   "
 EQUS "Peter Out   "
 EQUS "Dummy Driver"

\ ******************************************************************************
\
\       Name: objectScaffold
\       Type: Variable
\   Category: 3D objects
\    Summary: The scaffold used to construct each object, in a scalable format
\  Deep dive: Scaling objects with scaffolds
\
\ ------------------------------------------------------------------------------
\
\ This table contains an object's scaffold, in a format that supports quick and
\ easy scaling (see the ScaleObject routine).
\
\ Each object has its own scaffold, which contains all the measurements that we
\ need to build that object. The object is constructed using only measurements
\ from the scaffold, so if we want to scale the object, we can just scale the
\ scaffold.
\
\ Each object has a number of entries in this table, one for each scaffold
\ measurement, in decreasing order of size (so the largest measurements come
\ first). Each scaffold measurement is in one of these binary formats:
\
\   %00000ccc
\   %1abbbccc
\
\ where a = %a, b = %bbb and c = %ccc.
\
\ The value represented by %00000ccc is:
\
\       1
\   ---------
\   2^(c - 2)
\
\ and the value represented by %1abbbccc is:
\
\   a         1             1
\   -  +  ---------  +  ---------
\   2     2^(b - 2)     2^(c - 2)
\
\ In both cases, the result is a multiple of 1/32, so each of these entries
\ represents a fraction of the form n/32.
\
\ The ScaleObject routine takes the scaffold for a specific object and scales it
\ by multiplying each scaffold measurement by the following:
\
\     scaleUp
\   -----------
\   2^scaleDown
\
\ The resulting values are stored in the scaledScaffold table, which uses the
\ same structure as the object's section in the objectScaffold table, but
\ contains the scaled scaffold to use when drawing the scaled object.
\
\ ******************************************************************************

.objectScaffold

                        \ Object type 0 = 24, 22, 18, 17, 16, 8, 5, 4

 EQUB %10011100         \ 1 0 011 100    a = 0   b = 3   c = 4
                        \                0/2   + 1/2^1 + 1/2^2      = 24/32
 EQUB %11101110         \ 1 1 101 110    a = 1   b = 5   c = 6
                        \                1/2   + 1/2^3 + 1/2^4      = 22/32
 EQUB %10011110         \ 1 0 011 110    a = 0   b = 3   c = 6
                        \                0/2   + 1/2^1 + 1/2^4      = 18/32
 EQUB %10011111         \ 1 0 011 111    a = 0   b = 3   c = 7
                        \                0/2   + 1/2^1 + 1/2^5      = 17/32
 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %00000100         \ 0 0 000 100    c = 4
                        \                1/2^2                      =  8/32
 EQUB %10101111         \ 1 0 101 111    a = 0   b = 5   c = 7
                        \                0/2   + 1/2^3 + 1/2^5      =  5/32
 EQUB %00000101         \ 0 0 000 101    c = 5
                        \                1/2^3                      =  4/32

                        \ Object type 1 = 20, 12, 9, 8, 6, 5, 2, 1

 EQUB %10011101         \ 1 0 011 101    a = 0   b = 3   c = 5
                        \                0/2   + 1/2^1 + 1/2^3      = 20/32
 EQUB %10100101         \ 1 0 100 101    a = 0   b = 4   c = 5
                        \                0/2   + 1/2^2 + 1/2^3      = 12/32
 EQUB %10100111         \ 1 0 100 111    a = 0   b = 4   c = 7
                        \                0/2   + 1/2^2 + 1/2^5      =  9/32
 EQUB %00000100         \ 0 0 000 100    c = 4
                        \                1/2^2                      =  8/32
 EQUB %10101110         \ 1 0 101 110    a = 0   b = 5   c = 6
                        \                0/2   + 1/2^3 + 1/2^4      =  6/32
 EQUB %10101111         \ 1 0 101 111    a = 0   b = 5   c = 7
                        \                0/2   + 1/2^3 + 1/2^5      =  5/32
 EQUB %00000110         \ 0 0 000 110    c = 6
                        \                1/2^4                      =  2/32
 EQUB %00000111         \ 0 0 000 111    c = 7
                        \                1/2^5                      =  1/32

                        \ Object type 2 = 26, 24, 18, 17, 16, 5, 3, 2

 EQUB %11100110         \ 1 1 100 110    a = 1   b = 4   c = 6
                        \                1/2   + 1/2^2 + 1/2^4      = 26/32
 EQUB %10011100         \ 1 0 011 100    a = 0   b = 3   c = 4
                        \                0/2   + 1/2^1 + 1/2^2      = 24/32
 EQUB %10011110         \ 1 0 011 110    a = 0   b = 3   c = 6
                        \                0/2   + 1/2^1 + 1/2^4      = 18/32
 EQUB %10011111         \ 1 0 011 111    a = 0   b = 3   c = 7
                        \                0/2   + 1/2^1 + 1/2^5      = 17/32
 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %10101111         \ 1 0 101 111    a = 0   b = 5   c = 7
                        \                0/2   + 1/2^3 + 1/2^5      =  5/32
 EQUB %10110111         \ 1 0 110 111    a = 0   b = 6   c = 7
                        \                0/2   + 1/2^4 + 1/2^5      =  3/32
 EQUB %00000110         \ 0 0 000 110    c = 6
                        \                1/2^4                      =  2/32

                        \ Object type 3 = 16, 10, 6, 4, 3, 1

 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %10100110         \ 1 0 100 110    a = 0   b = 4   c = 6
                        \                0/2   + 1/2^2 + 1/2^4      = 10/32
 EQUB %10101110         \ 1 0 101 110    a = 0   b = 5   c = 6
                        \                0/2   + 1/2^3 + 1/2^4      =  6/32
 EQUB %00000101         \ 0 0 000 101    c = 5
                        \                1/2^3                      =  4/32
 EQUB %10110111         \ 1 0 110 111    a = 0   b = 6   c = 7
                        \                0/2   + 1/2^4 + 1/2^5      =  3/32
 EQUB %00000111         \ 0 0 000 111    c = 7
                        \                1/2^5                      =  1/32

                        \ Object type 4 = 26, 17, 16, 12, 6, 5, 3, 1

 EQUB %11100110         \ 1 1 100 110    a = 1   b = 4   c = 6
                        \                1/2   + 1/2^2 + 1/2^4      = 26/32
 EQUB %10011111         \ 1 0 011 111    a = 0   b = 3   c = 7
                        \                0/2   + 1/2^1 + 1/2^5      = 17/32
 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %10100101         \ 1 0 100 101    a = 0   b = 4   c = 5
                        \                0/2   + 1/2^2 + 1/2^3      = 12/32
 EQUB %10101110         \ 1 0 101 110    a = 0   b = 5   c = 6
                        \                0/2   + 1/2^3 + 1/2^4      =  6/32
 EQUB %10101111         \ 1 0 101 111    a = 0   b = 5   c = 7
                        \                0/2   + 1/2^3 + 1/2^5      =  5/32
 EQUB %10110111         \ 1 0 110 111    a = 0   b = 6   c = 7
                        \                0/2   + 1/2^4 + 1/2^5      =  3/32
 EQUB %00000111         \ 0 0 000 111    c = 7
                        \                1/2^5                      =  1/32

                        \ Object type 5 = 26, 17, 3

 EQUB %11100110         \ 1 1 100 110    a = 1   b = 4   c = 6
                        \                1/2   + 1/2^2 + 1/2^4      = 26/32
 EQUB %10011111         \ 1 0 011 111    a = 0   b = 3   c = 7
                        \                0/2   + 1/2^1 + 1/2^5      = 17/32
 EQUB %10110111         \ 1 0 110 111    a = 0   b = 6   c = 7
                        \                0/2   + 1/2^4 + 1/2^5      =  3/32

                        \ Object type 6 = 16, 10, 1


 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %10100110         \ 1 0 100 110    a = 0   b = 4   c = 6
                        \                0/2   + 1/2^2 + 1/2^4      = 10/32
 EQUB %00000111         \ 0 0 000 111    c = 7
                        \                1/2^5                      =  1/32

                        \ Object type 7 = 28, 20, 18, 16, 8


 EQUB %11100101         \ 1 1 100 101    a = 1   b = 4   c = 5
                        \                1/2   + 1/2^2 + 1/2^3      = 28/32
 EQUB %10011101         \ 1 0 011 101    a = 0   b = 3   c = 5
                        \                0/2   + 1/2^1 + 1/2^3      = 20/32
 EQUB %10011110         \ 1 0 011 110    a = 0   b = 3   c = 6
                        \                0/2   + 1/2^1 + 1/2^4      = 18/32
 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %00000100         \ 0 0 000 100    c = 4
                        \                1/2^2                      =  8/32

                        \ Object type 8 = 18, 16, 3, 2

 EQUB %10011110         \ 1 0 011 110    a = 0   b = 3   c = 6
                        \                0/2   + 1/2^1 + 1/2^4      = 18/32
 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %10110111         \ 1 0 110 111    a = 0   b = 6   c = 7
                        \                0/2   + 1/2^4 + 1/2^5      =  3/32
 EQUB %00000110         \ 0 0 000 110    c = 6
                        \                1/2^4                      =  2/32

                        \ Object type 9 = 16, 12, 10, 3

 EQUB %00000011         \ 0 0 000 011    c = 3
                        \                1/2^1                      = 16/32
 EQUB %10100101         \ 1 0 100 101    a = 0   b = 4   c = 5
                        \                0/2   + 1/2^2 + 1/2^3      = 12/32
 EQUB %10100110         \ 1 0 100 110    a = 0   b = 4   c = 6
                        \                0/2   + 1/2^2 + 1/2^4      = 10/32
 EQUB %10110111         \ 1 0 110 111    a = 0   b = 6   c = 7
                        \                0/2   + 1/2^4 + 1/2^5      =  3/32

                        \ Object type 10 = 10, 9, 6, 4, 1

 EQUB %10100110         \ 1 0 100 110    a = 0   b = 4   c = 6
                        \                0/2   + 1/2^2 + 1/2^4      = 10/32
 EQUB %10100111         \ 1 0 100 111    a = 0   b = 4   c = 7
                        \                0/2   + 1/2^2 + 1/2^5      =  9/32
 EQUB %10101110         \ 1 0 101 110    a = 0   b = 5   c = 6
                        \                0/2   + 1/2^3 + 1/2^4      =  6/32
 EQUB %00000101         \ 0 0 000 101    c = 5
                        \                1/2^3                      =  4/32
 EQUB %00000111         \ 0 0 000 111    c = 7
                        \                1/2^5                      =  1/32

                        \ Object type 11 = 10, 8, 6, 5

 EQUB %10100110         \ 1 0 100 110    a = 0   b = 4   c = 6
                        \                0/2   + 1/2^2 + 1/2^4      = 10/32
 EQUB %00000100         \ 0 0 000 100    c = 4
                        \                1/2^2                      =  8/32
 EQUB %10101110         \ 1 0 101 110    a = 0   b = 5   c = 6
                        \                0/2   + 1/2^3 + 1/2^4      =  6/32
 EQUB %10101111         \ 1 0 101 111    a = 0   b = 5   c = 7
                        \                0/2   + 1/2^3 + 1/2^5      =  5/32

                        \ Object type 12 = 10, 8, 6, 5

 EQUB %10100110         \ 1 0 100 110    a = 0   b = 4   c = 6
                        \                0/2   + 1/2^2 + 1/2^4      = 10/32
 EQUB %00000100         \ 0 0 000 100    c = 4
                        \                1/2^2                      =  8/32
 EQUB %10101110         \ 1 0 101 110    a = 0   b = 5   c = 6
                        \                0/2   + 1/2^3 + 1/2^4      =  6/32

 EQUB %10101111         \ 1 0 101 111    c = 0   b = 5   c = 7
                        \                0/2   + 1/2^3 + 1/2^5      =  5/32

\ ******************************************************************************
\
\       Name: SetBestRacingLine
\       Type: Subroutine
\   Category: Driving model
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The class of race:
\
\                         * 0 = Novice
\
\                         * 1 = Amateur
\
\                         * 2 = Professional
\
\ Returns:
\
\   X                   X is unchanged
\
\ ******************************************************************************

.SetBestRacingLine

 LDA trackBaseSpeed,X   \ Set baseSpeed = the X-th byte of trackBaseSpeed
 STA baseSpeed          \
                        \ so baseSpeed contains the base speed for cars at the
                        \ chosen class or race, on this track
                        \
                        \ For Silverstone, this is:
                        \
                        \   * 134 for Novice
                        \   * 146 for Amateur
                        \   * 152 for Professional

 STA U                  \ Set U = baseSpeed

 LDA trackSectionCount  \ Set Y = trackSectionCount >> 3
 LSR A                  \
 LSR A                  \ so Y contains the number of sections in this track
 LSR A
 TAY

                        \ Now we copy Y bytes (one per track section) from
                        \ trackRacingLine to bestRacingLine, processing each
                        \ byte as we go (i.e. taking the input from
                        \ trackRacingLine and storing the result in
                        \ bestRacingLine):
                        \
                        \   * Bit 7 of the result = bit 0 of the input
                        \
                        \   * Bit 6 of the result = 0
                        \
                        \   * Bits 0-5 of the result are:
                        \
                        \     * A >> 2 * U / 256 if bit 1 of the input is clear
                        \     * A >> 2           if bit 1 of the input is set
                        \
                        \ where A is the input from trackRacingLine and U is the
                        \ base speed from above

.slin1

 LDA trackRacingLine,Y  \ Fetch the Y-th byte from trackRacingLine as the input

 LSR A                  \ Shift bit 0 of the input into the C flag and store it
 PHP                    \ on the stack so we can put it into bit 7 of the result

 LSR A                  \ Shift bit 1 of the input into the C flag

 BCS slin2              \ If bit 1 of the input is set, skip the following
                        \ instruction

 JSR Multiply8x8        \ Bit 1 of the input is clear, so set (A T) = A * U
                        \
                        \ i.e. A = A * U / 256

.slin2

 ASL A                  \ Set bit 7 of the result to bit 0 of the input
 PLP
 ROR A

 STA bestRacingLine,Y   \ Store the result in the Y-th byte of bestRacingLine

 DEY                    \ Decrement the loop counter

 BPL slin1              \ Loop back until we have processed all Y bytes

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C44EA
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C44EA

 LDA L002D
 BEQ C44F5
 DEC L0028
 DEC L0028
 JMP C452D

.C44F5

 STA L0028
 STA L0026
 LDY L62F0
 LDA gearNumber
 BEQ C4510
 LDA throttleBrakeState
 BMI C4510
 BEQ C450C
 LDA L003D
 BNE C4516
 BEQ C4510

.C450C

 LDA speedHi
 BNE C4521

.C4510

 TYA
 BEQ C452D
 BPL C4521
 INY

.C4516

 INY
 BMI C452A
 CPY #4
 BCC C452A
 LDY #3
 BCS C452A

.C4521

 DEY
 BPL C452A
 CPY #&FB
 BCS C452A
 LDY #&FB

.C452A

 STY L62F0

.C452D

 LDX segmentIndex96
 LDY segmentVector,X
 LDA L000D
 STA V
 LDA xTrackVectorI,Y
 EOR zTrackVectorI,Y
 PHP
 LDA zTrackVectorI,Y
 PHP

 JSR Absolute8Bit       \ Set A = |A|

 CMP #&3C
 PHP
 BCC C454F
 LDA xTrackVectorI,Y

 JSR Absolute8Bit       \ Set A = |A|

.C454F

 STA T
 LSR A
 CLC
 ADC T
 LSR A
 LSR A
 PLP
 BCS C455C
 EOR #&3F

.C455C

 PLP
 BPL C4561
 EOR #&80

.C4561

 PLP

 JSR Absolute8Bit       \ Set A = |A|

 SEC
 SBC playerRotationHi
 STA L0044
 BPL C456E
 EOR #&FF

.C456E

 CMP #&40
 BCC C4574
 EOR #&7F

.C4574

 STA L62F2
 EOR #&3F
 STA T
 LSR A
 CLC
 ADC T
 JSR MultiplyHeight
 CLC
 ADC L005D
 CLC
 ADC L62F0
 CLC
 ADC L0028
 CLC
 ADC L000D
 CLC
 BPL C4593
 SEC

.C4593

 ROR A
 STA L000D
 SEC
 SBC V
 STA L004E
 LDA #0
 STA W
 LDA L0026
 SEC
 SBC #4
 BVC C45A8
 LDA #&C8

.C45A8

 STA L0026
 CLC
 ADC L002D
 BEQ C45B3
 BVS C45C7
 BPL C45C9

.C45B3

 LDA L0026

 JSR Absolute8Bit       \ Set A = |A|

 CMP #5
 BCC C45C3
 JSR sub_C4DCB
 LDA #1
 BNE C45C9

.C45C3

 LDA #0
 BEQ C45C9

.C45C7

 LDA #&7F

.C45C9

 STA L002D
 ASL A
 ROL W
 ASL A
 ROL W
 STA V
 LDX currentPlayer
 LDA carProgress,X
 JSR MultiplyHeight
 BPL C45DF
 DEC W

.C45DF

 LDY segmentIndex96
 CLC
 ADC ySegmentCoordILo,Y
 PHP
 CLC
 ADC #&AC
 PHP
 CLC
 ADC V
 STA yPlayerCoordLo
 LDA ySegmentCoordIHi,Y
 ADC W
 PLP
 ADC #0
 PLP
 ADC #0
 STA yPlayerCoordHi
 LDA speedHi
 STA U
 LDA #&21

 JSR Multiply8x8        \ Set (A T) = A * U

 ASL U
 CLC
 ADC U
 STA carSpeedHi,X
 RTS

\ ******************************************************************************
\
\       Name: MultiplyHeight
\       Type: Subroutine
\   Category: Track
\    Summary: Multiply track height by A
\
\ ------------------------------------------------------------------------------
\
\ For track vector Y, calculate:
\
\   A = A * yTrackVectorI
\
\ flipping the sign if we are facing backwards.
\
\ Arguments:
\
\   A                   The number to multiply the height by
\
\   Y                   Index of the track vector to multiply
\
\ Returns:
\
\   N flag              Set according to the result in A
\
\ ******************************************************************************

.MultiplyHeight

 STA U                  \ Set U to the multiplication factor in A

 LDA yTrackVectorI,Y    \ Store the sign of the height * directionFacing on
 EOR directionFacing    \ the stack
 PHP

 LDA yTrackVectorI,Y    \ Set A to the track height in the Y-th yTrackVectorI

 JSR Absolute8Bit       \ Set A = |A|
                        \       = |yTrackVectorI|

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = U * |yTrackVectorI|

 PLP                    \ Set the N flag to the sign of yTrackVectorI *
                        \ directionFacing, so this will be set if the height
                        \ sign is different to bit 7 of directionFacing, clear
                        \ if the height sign matches bit 7 of directionFacing

 JSR Absolute8Bit       \ Give A the sign in the N flag

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C4626
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4626

 LDA L005E
 SEC
 SBC L0044

 JSR Absolute8Bit       \ Set A = |A|

 CMP #&40
 ROR L0043
 BPL C4639
 EOR #&7F
 CLC
 ADC #1

.C4639

 PHA

 LDY #186
 JSR sub_C4676

 LDX L005C
 CPX #&28
 BCC C4647
 EOR #&FF

.C4647

 LDX currentPlayer
 BIT directionFacing

 JSR Absolute8Bit       \ Set A = |A|

 PHA
 SBC carRacingLine,X
 BCS C4656
 EOR #&FF

.C4656

 CMP #&16

IF _ACORNSOFT

 ROR L62FB

ELIF _SUPERIOR

 JSR sub_C1FA8

ENDIF

 PLA
 STA carRacingLine,X
 PLA
 EOR #&FF
 CLC
 ADC #&41

 LDY #136
 JSR sub_C4676

 ASL A
 ASL A
 BIT L0043
 BMI C4672
 EOR #&FF

.C4672

 STA carProgress,X
 RTS

\ ******************************************************************************
\
\       Name: sub_C4676
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   
\
\   Y                   Called with Y = 136 or 186
\
\ ******************************************************************************

.sub_C4676

 JSR sub_C4687          \ Set U = A, scaled up by sub_C4687
 STA U                  \ Call it A+

 TYA                    \ Set (A T) = A * U
 JSR Multiply8x8        \           = Y * A+

 STA U                  \ Set (U T) = (A T)
                        \           = Y * A+

 LDA L0010              \ Set (A T) = A * U
 JSR Multiply8x8        \           = L0010 * U
                        \           = L0010 * (Y * A+ / 256)
                        \           = L0010 * A+ * (Y / 256)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C4687
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\   When            Calculate               Range of result
\
\   A < 26          A = 3 * A               0 to 78
\   26 <= A < 46    A = 4 * A + 52          156 to 232
\   A >= 46         A = A + 190             236 and up
\
\ ******************************************************************************

.sub_C4687

 CMP #26                \ If A < 26, jump to C4699
 BCC C4699

 CMP #46                \ If A < 46, jump to C4693
 BCC C4693

                        \ If we get here then A >= 46

 CLC                    \ Set A = A + 190
 ADC #190

 RTS                    \ Return from the subroutine

.C4693

                        \ If we get here then 26 <= A < 46

 ASL A                  \ Set A = A << 2 + 52
 ASL A                  \       = 4 * A + 52
 CLC
 ADC #52

 RTS                    \ Return from the subroutine

.C4699

                        \ If we get here then A < 26

 STA T                  \ Set T = A

 ASL A                  \ Set A = A << 1 + T
 CLC                    \       = A * 2 + A
 ADC T                  \       = 3 * A
 ASL A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C46A1
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C46A1

 LDA playerRotationHi
 LDX playerRotationLo
 JSR sub_C0D01
 JSR sub_C48B9

 LDA var07Lo
 STA var15Lo
 LDA var07Hi
 STA var15Hi

 LDA var08Lo
 STA T
 LDA var08Hi

 JSR Absolute16Bit      \ Set (A T) = |A T|

 STA speedHi

 LDA T
 STA speedLo

 LDY speedHi
 BNE C46CD
 AND #&F0
 TAY

.C46CD

 STY playerMoving
 JSR sub_C4729
 JSR sub_C4BCF
 JSR sub_C49CE
 LDX #1
 JSR sub_C4779
 LDA var15Lo
 STA var07Lo
 LDA var15Hi
 STA var07Hi
 LDA var07Lo
 CLC
 ADC var16Lo
 STA var07Lo
 LDA var07Hi
 ADC var16Hi
 STA var07Hi
 JSR sub_C47A5
 LDX #0
 JSR sub_C4779
 JSR sub_C47C5
 JSR sub_C47F9
 LDA L002D
 CMP #2
 BCC C4719
 LDX #2
 LDA #0

.P4710

 STA var05Lo,X
 STA var05Hi,X
 DEX
 BPL P4710

.C4719

 JSR sub_C4C65
 JSR sub_C48C1
 JSR sub_C4937
 JSR sub_C48EF
 JSR sub_C44EA
 RTS

\ ******************************************************************************
\
\       Name: sub_C4729
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4729

 LDA spinSpeedLo
 STA T
 LDY #&58
 LDA spinSpeedHi
 JSR sub_C4753
 STA U
 LDA var07Lo
 SEC
 SBC T
 STA var07Lo
 LDA var07Hi
 SBC U
 STA var07Hi
 JSR sub_C4765
 STA var16Hi
 LDA T
 STA var16Lo
 RTS

\ ******************************************************************************
\
\       Name: sub_C4753
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4753

 PHP

 JSR Absolute16Bit      \ Set (A T) = |A T|

 STA V
 STY U

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256

 LDA U
 PLP

 JSR Absolute16Bit      \ Set (A T) = |A T|

 RTS

\ ******************************************************************************
\
\       Name: sub_C4765
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4765

 LDA U
 CLC
 BPL C476B
 SEC

.C476B

 ROR A
 PHA
 LDA T
 ROR A
 CLC
 ADC T
 STA T
 PLA
 ADC U
 RTS

\ ******************************************************************************
\
\       Name: sub_C4779
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   0 or 1 (for left or right tyres?)
\
\ ******************************************************************************

.sub_C4779

 LDA L002D              \ If L002D >= 2, jump to C478F to stop the tyres from
 CMP #2                 \ squealing
 BCS C478F

 JSR sub_C4A91

 LDA L62A6,X            \ Set A to L62A6 (when X = 0) or L62A7 (when X = 1)

 AND #%11000000         \ If either of bit 6 or 7 is set in A, jump to C4795 to
 BNE C4795              \ make the tyres squeal

 LDA mainLoopCounterLo  \ If bit 1 of mainLoopCounterLo is set, which it is on
 AND #%00000010         \ two out of every four iterations round the main loop,
 BNE C4794              \ then jump to C4794 to return from the subroutine

.C478F

 LDX #3                 \ Flush the buffer for sound channel 3 to stop any tyre
 JSR FlushSoundBuffer   \ squeals we might already be making

.C4794

 RTS                    \ Return from the subroutine

.C4795

 JSR sub_C4AF7

 LDA soundBuffer+3      \ If sound buffer 3 is currently being used, then we are
 BNE C47A4              \ already making the sound of the tyres squealing, so
                        \ jump to C47A4 to return from the subroutine

 LDY #1                 \ Make sound #3 (tyre squeal) using envelope 1
 LDA #3
 JSR MakeSound

.C47A4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C47A5
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C47A5

 LDX #2
 LDY #9
 LDA #&80
 STA H
 LDA #&0E
 JSR sub_C4874
 LDX #2
 LDY #8
 LDA #&40
 STA H
 LDA #9
 JSR sub_C4874

 LDX #8                 \ Add (var12Hi var12Lo) to (var07Hi var07Lo)
 JSR sub_C47E5

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C47C5
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C47C5

 LDX #2
 LDY #&0C
 LDA #0
 STA H
 LDA #&0E
 JSR sub_C4874
 LDX #2
 LDY #&0A
 LDA #&C0
 STA H
 LDA #&0C
 JSR sub_C4874

 LDX #10                \ Add (var12Hi var12Lo) to (var09Hi var09Lo)
 JSR sub_C47E5

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C47E5
\       Type: Subroutine
\   Category: 
\    Summary: Add (var12Hi var12Lo) to (var02Hi+X var02Lo+X)
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   Called with either 8 or 10:
\
\                         *  8 = add (var12Hi var12Lo) to (var07Hi var07Lo)
\
\                         * 10 = add (var12Hi var12Lo) to (var09Hi var09Lo)
\
\ ******************************************************************************

.sub_C47E5

 LDA var02Lo,X          \ Add (var12Hi var12Lo) to (var02Hi+X var02Lo+X),
 CLC                    \ starting with the low bytes
 ADC var12Lo
 STA var02Lo,X

 LDA var02Hi,X          \ And then the high bytes
 ADC var12Hi
 STA var02Hi,X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C47F9
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C47F9

 LDY #&4E
 LDA var09Lo
 SEC
 SBC var10Lo
 STA T
 LDA var09Hi
 SBC var10Hi
 JSR sub_C4753
 STA var05Hi
 LDA T
 STA var05Lo
 LDY #1

.P4817

 LDX #3

.P4819

 LDA var09Hi,X
 CLC
 BPL C4820
 SEC

.C4820

 ROR var09Hi,X
 ROR var09Lo,X
 DEX
 BPL P4819
 DEY
 BPL P4817
 LDX #2
 LDA #1
 STA G

.C4832

 LDA var10Lo,X
 STA T
 LDA var10Hi,X
 STA U
 JSR sub_C4765
 STA U
 LDA T
 CLC
 ADC var09Lo,X
 STA T
 LDY #&CD
 LDA U
 ADC var09Hi,X
 JSR sub_C4753
 ASL T
 ROL A
 LDY G
 STA var06Hi,Y
 LDA T
 STA var06Lo,Y
 DEC G
 DEX
 DEX
 BPL C4832
 LDA L62E7Hi
 STA L62FF
 RTS

\ ******************************************************************************
\
\       Name: sub_C486D
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C486D

 LDY N
 STA H
 JMP C4876

\ ******************************************************************************
\
\       Name: sub_C4874
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4874

 STA K

.C4876

 LDA var02Lo,Y
 STA PP
 LDA var02Hi,Y
 STA QQ
 LDA var26Lo,X
 STA RR
 LDA var26Hi,X
 STA SS
 JSR sub_C0DD7
 STA U
 LDY K
 BIT H
 BVS C48A7
 LDA T
 STA var02Lo,Y
 LDA U
 STA var02Hi,Y
 RTS

\ ******************************************************************************
\
\       Name: sub_C48A0
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C48A0

 BMI C48A7

 JSR Negate16Bit+2      \ Set (A T) = -(U T)

 STA U

.C48A7

 LDA var02Lo,Y
 CLC
 ADC T
 STA var02Lo,Y
 LDA var02Hi,Y
 ADC U
 STA var02Hi,Y
 RTS

\ ******************************************************************************
\
\       Name: sub_C48B9
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C48B9

 LDY #0
 LDA #8
 LDX #&C0
 BNE C48C7

\ ******************************************************************************
\
\       Name: sub_C48C1
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C48C1

 LDY #6
 LDA #3
 LDX #&40

.C48C7

 STY N
 STA K
 STX GG
 LDX #1
 LDA #0
 JSR sub_C486D
 DEX
 INC N
 LDA GG
 JSR sub_C486D
 INX
 INC K
 LDA #0
 JSR sub_C486D
 DEX
 DEC N
 LDA GG
 EOR #&80
 JSR sub_C486D
 RTS

\ ******************************************************************************
\
\       Name: sub_C48EF
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C48EF

 LDX #1
 LDY #2

.C48F3

 LDA #0
 STA V
 LDA var02Lo,X
 STA T
 LDA var02Hi,X
 BPL C4903
 DEC V

.C4903

 ASL T
 ROL A
 ROL V
 STA U
 LDA L62B1,Y
 ADC T
 STA L62B1,Y
 LDA xPlayerCoordLo,Y
 ADC U
 STA xPlayerCoordLo,Y
 LDA xPlayerCoordHi,Y
 ADC V
 STA xPlayerCoordHi,Y
 DEY
 DEY
 DEX
 BPL C48F3
 LDA playerRotationLo
 CLC
 ADC spinSpeedLo
 STA playerRotationLo
 LDA playerRotationHi
 ADC spinSpeedHi
 STA playerRotationHi
 RTS

\ ******************************************************************************
\
\       Name: sub_C4937
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4937

 LDX #2

.C4939

 LDA #0
 STA V
 LDA var04Lo,X
 STA T
 LDA var04Hi,X
 BPL C4949
 DEC V

.C4949

 LDY #3
 CPX #2
 BNE C4951
 LDY #5

.C4951

 ASL T
 ROL A
 ROL V
 DEY
 BNE C4951
 STA U
 LDA L62AE,X
 CLC
 ADC T
 STA L62AE,X
 LDA var02Lo,X
 ADC U
 STA var02Lo,X
 LDA var02Hi,X
 ADC V
 STA var02Hi,X
 DEX
 BPL C4939
 RTS

\ ******************************************************************************
\
\       Name: sub_C4978
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4978

 LDX #&DC               \ Scan the keyboard to see if "T" is being pressed
 JSR ScanKeyboard

 BEQ C498C              \ If "T" is being pressed, jump to C498C

 LDY gearNumber
 DEY
 BEQ C4988
 LDA speedHi
 BNE C4993

.C4988

 LDA #0
 BEQ C49C5

.C498C

 LDA VIA+&68            \ Read 6522 User VIA T1C-L timer 2 low-order counter
                        \ (SHEILA &68), which will be a pretty random figure

 AND L0009
 BNE C49BB

.C4993

 LDX #7
 STX L0009

 LDX #&FF               \ Set engineStatus = &FF to turn on the engine
 STX engineStatus

 BMI C49BB

.C499D

 STA L0059

.C499F

 LDA revCount
 LDX throttleBrakeState
 DEX
 BNE C49B0
 ADC #7
 CMP throttleBrake
 BCS C49B0
 CMP #&8C
 BCC C49C5

.C49B0

 CMP #&2A
 BCC C49B9
 SEC
 SBC #&0C
 BCS C49BB

.C49B9

 LDA #&28

.C49BB

 STA T

 LDA VIA+&68            \ Read 6522 User VIA T1C-L timer 2 low-order counter
                        \ (SHEILA &68), which will be a pretty random figure

 AND #7
 CLC
 ADC T

.C49C5

 STA revCount
 STA L005A

.C49C9

 LDA #0
 JMP C4A87

\ ******************************************************************************
\
\       Name: sub_C49CE
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C49CE

 LDA engineStatus
 BEQ sub_C4978

 LDA L002D
 BNE C499F

 LDA gearChangeKey      \ If bit 7 of gearChangeKey is set then a gear change
 BMI C499D              \ key is being pressed, so jump to C499D

 LDY gearNumber
 DEY
 BEQ C499F
 LDA speedLo
 STA T
 LDA speedHi
 ASL T
 ROL A
 PHP
 BMI C49EE
 ASL T
 ROL A

.C49EE

 STA U
 LDX gearNumber
 LDA trackGearRatio,X

 JSR Multiply8x8        \ Set (A T) = A * U

 ASL T
 ROL A
 PLP
 BPL C4A01
 ASL T
 ROL A

.C4A01

 BIT L0059
 BPL C4A37
 LDY throttleBrakeState
 DEY
 BNE C4A26
 LDY speedHi
 CPY #&16
 BCS C4A26

 LDY raceStarting       \ Set Y = raceStarting

 BPL C4A22              \ If bit 7 of raceStarting is clear, jump to C4A22

 CPY #%10100000
 BNE C4A26

 PHA
 LDA mainLoopCounterLo
 AND #&3F
 CMP #&35
 PLA
 BCC C4A26

.C4A22

 CMP L005A
 BCC C4A2C

.C4A26

 LDY #0
 STY L0059
 BEQ C4A37

.C4A2C

 LDA L005A
 CMP #&6C
 BCC C4A37
 SEC
 SBC #2
 STA L005A

.C4A37

 STA revCount
 CMP #&AA
 BCC C4A3F
 LDA #&AA

.C4A3F

 CMP #3
 BCS C4A48
 INC engineStatus
 JMP C49C9

.C4A48

 SEC
 SBC #&42
 BMI C4A51
 CMP #&11
 BCS C4A58

.C4A51

 ASL A
 CLC
 ADC #&98
 JMP C4A7F

.C4A58

 SEC
 SBC #&11
 CMP #4
 BCS C4A66
 EOR #&FF
 CLC
 ADC #&BB
 BCS C4A7F

.C4A66

 SEC
 SBC #4
 CMP #5
 BCS C4A76
 ASL A
 ASL A
 EOR #&FF
 CLC
 ADC #&B7
 BCS C4A7F

.C4A76

 SEC
 SBC #5
 ASL A
 EOR #&FF
 CLC
 ADC #&A3

.C4A7F

 STA U
 LDA trackGearPower,X

 JSR Multiply8x8        \ Set (A T) = A * U

.C4A87

 STA L003D

 LDA revCount           \ Set soundRevTarget = revCount + 25
 CLC
 ADC #25
 STA soundRevTarget

 RTS

\ ******************************************************************************
\
\       Name: sub_C4A91
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   0 or 1 (for left or right tyres?)
\
\ ******************************************************************************

.sub_C4A91

 LDA var07Lo
 STA T
 ORA var07Hi
 PHP
 LDA var07Hi

 JSR Negate16Bit        \ Set (A T) = -(A T)

 LDY #5

.P4AA2

 ASL T
 ROL A
 DEY
 BNE P4AA2
 STA var09Hi,X
 PLP
 BEQ C4AB4
 EOR var07Hi
 SEC
 BPL C4AF3

.C4AB4

 LDA T
 STA var09Lo,X
 JSR sub_C4B88
 BCC C4ACF

 LDA #0
 STA var11Lo
 STA var11Hi

 LDA var09Hi

 JSR Absolute8Bit       \ Set A = |A|

 JMP C4AED

.C4ACF

 JSR sub_C4B42
 LDA var11Hi,X

 JSR Absolute8Bit       \ Set A = |A|

 STA T
 LDA var09Hi,X

 JSR Absolute8Bit       \ Set A = |A|

 CMP T
 BCC C4AE9
 LSR T
 JMP C4AEA

.C4AE9

 LSR A

.C4AEA

 CLC
 ADC T

.C4AED

 CMP L62AA,X
 BNE C4AF3
 CLC

.C4AF3

 ROR L62A6,X
 RTS

\ ******************************************************************************
\
\       Name: sub_C4AF7
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   0 or 1 (for left or right tyres?)
\
\ ******************************************************************************

.sub_C4AF7

 LDA #0
 STA var11Hi,X
 STA var11Lo,X
 LDY #8
 JSR sub_C4B61
 LDA var07Hi
 EOR #&80
 STA H
 LDA #0
 STA T
 LDA L62AC,X
 STX G
 JSR sub_C4B47
 JSR sub_C4B88
 BCS C4B41
 CMP L62AC,X
 BCC C4B3E
 LDA #0
 STA T
 LDA L62AC,X
 JSR sub_C4B42
 LDY throttleBrakeState
 DEY
 BNE C4B41
 CPX #0
 BEQ C4B41
 LDA #0
 STA var09Hi,X
 STA var09Lo,X
 BEQ C4B41

.C4B3E

 JSR sub_C4B42

.C4B41

 RTS

\ ******************************************************************************
\
\       Name: sub_C4B42
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4B42

 LDY throttleBrakeState
 DEY
 BEQ C4B51

\ ******************************************************************************
\
\       Name: sub_C4B47
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4B47

 CMP NN
 BCC C4B51
 LDA MM
 STA T
 LDA NN

.C4B51

 BIT H

 JSR Absolute16Bit      \ Set (A T) = |A T|

 LDY G
 STA var09Hi,Y
 LDA T
 STA var09Lo,Y
 RTS

\ ******************************************************************************
\
\       Name: sub_C4B61
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4B61

 LDA var02Lo,Y
 STA MM
 LDA var02Hi,Y
 BPL C4B77
 LDA #0
 SEC
 SBC MM
 STA MM
 LDA #0
 SBC var02Hi,Y

.C4B77

 LDY #5

.P4B79

 ASL MM
 ROL A
 BMI C4B84
 DEY
 BNE P4B79

.P4B81

 STA NN
 RTS

.C4B84

 LDA #&7F
 BNE P4B81

\ ******************************************************************************
\
\       Name: sub_C4B88
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4B88

 TXA
 CLC
 ADC #2
 STA G
 LDY throttleBrakeState
 DEY
 BEQ C4BAF
 LDY #9
 JSR sub_C4B61
 LDA var08Hi
 EOR #&80
 STA H
 LDA L62AA,X
 CPX #1
 BEQ C4BBC
 LSR A
 CLC
 ADC L62AA,X
 LSR A
 JMP C4BBC

.C4BAF

 CPX #1
 BNE C4BCD
 LDA gearNumber
 SEC
 SBC #1
 STA H
 LDA L003D

.C4BBC

 STA U
 LDA throttleBrake

 JSR Multiply8x8        \ Set (A T) = A * U

 LDY throttleBrakeState
 DEY
 BNE C4BCB
 LSR A
 ROR T

.C4BCB

 CLC
 RTS

.C4BCD

 SEC
 RTS

\ ******************************************************************************
\
\       Name: sub_C4BCF
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4BCF

 LDA #0
 LDY throttleBrakeState
 BNE C4BE1
 LDA L62FF
 PHP
 LSR A
 LSR A
 LSR A
 PLP
 BPL C4BE1
 ORA #&E0

.C4BE1

 STA H
 EOR #&FF
 CLC
 ADC #1
 STA G
 LDA speedHi
 STA U
 LDX #0
 LDA L713D
 AND L7205
 STA W
 LDA L713D
 CMP #&FF
 BEQ C4C06
 LDA L7205
 CMP #&FF
 BNE C4C24

.C4C06

 LDA VIA+&68            \ Read 6522 User VIA T1C-L timer 2 low-order counter
                        \ (SHEILA &68), which will be a pretty random figure

 JSR Multiply8x8        \ Set (A T) = A * U

 AND #7
 TAX
 BNE C4C12
 INX

.C4C12

 LDA L005D
 BNE C4C24
 LDA L005D
 ORA L002D
 BNE C4C24
 BIT L62FB
 BPL C4C24
 JSR sub_C4DC9

.C4C24

 STX L005D
 LDX #1

.C4C28

 LDA speedHi
 CMP #&35
 BCC C4C30
 LDA #&35

.C4C30

 STA U

 LDA wingSetting,X

 JSR Multiply8x8        \ Set (A T) = A * U

 BIT var08Hi

 JSR Absolute8Bit       \ Set A = |A|

 CLC
 ADC L4C61,X
 LDY #&F3
 STY U
 LDY W
 CPY #&FF
 BNE C4C51
 LDA L4C63,X
 LDY #&FF

.C4C51

 CLC
 ADC G,X
 STA L62AA,X

 JSR Multiply8x8        \ Set (A T) = A * U

 STA L62AC,X
 DEX
 BPL C4C28
 RTS

\ ******************************************************************************
\
\       Name: L4C61
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L4C61

 EQUB &35, &35

\ ******************************************************************************
\
\       Name: L4C63
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L4C63

 EQUB &19, &1A

\ ******************************************************************************
\
\       Name: sub_C4C65
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4C65

 LDA var15Hi

 JSR Absolute8Bit       \ Set A = |A|

 STA U
 CMP speedHi
 BCS C4C72
 LDA speedHi

.C4C72

 LDY L005D
 BEQ C4C77
 ASL A

.C4C77

 STA W

 JSR Multiply8x8        \ Set (A T) = A * U

 STA U
 LDY #6
 LDA var15Hi
 JSR sub_C48A0
 LDA speedHi
 STA U
 LDA wingBalance

 JSR Multiply8x8        \ Set (A T) = A * U

 CLC
 ADC #8
 STA V
 LDA W
 STA U

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256

 LDY #7
 LDA var08Hi
 JSR sub_C48A0
 RTS

\ ******************************************************************************
\
\       Name: BuildRoadSign
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Create an object for the road sign
\
\ ------------------------------------------------------------------------------
\
\ This routine uses the track data to build the correct sign object for the
\ player's current track section.
\
\ If we just entered a new track section and the sign number from the new track
\ section's trackSectionData is different to the previous section, then we
\ build the new sign number, otherwise we build the next sign number.
\
\ The 3D coordinates of the sign are calculated using the section number in the
\ trackSignData for the sign. This section number is only used for calculating
\ the 3D coordinates - it isn't related to the section we are currently in.
\
\ In Silverstone, the 16 signs are drawn when entering these sections (as
\ defined in trackSectionData):
\
\   0,  1,  3,  5,  6,  7,  9, 11, 14, 15, 16, 17, 19, 20, 21, 22
\
\ and those signs are drawn relative to the following section coordinates (as
\ defined in trackSignData):
\
\   0,  2,  3,  5,  7,  9, 12, 14, 14, 14, 18, 19, 20, 21, 22, 23
\
\ This can get a little confusing, but the first batch defines when to show the
\ signs, and the second batch defines where to show them.
\
\ ******************************************************************************

.BuildRoadSign

 LDX currentPlayer      \ Set X to the driver number of the current player

 LDY objTrackSection,X  \ Set Y to the track section number * 8 for the current
                        \ player

 LDA trackSectionData,Y \ Set A to bits 4-7 of the trackSectionData for the
 LSR A                  \ track section, shifted into bits 0-3, so A contains
 LSR A                  \ the number of the sign for this section (0 to 15)
 LSR A
 LSR A

 STA temp4              \ Store the sign number in temp4, so we can retrieve it
                        \ below

 CMP previousSignNumber \ If previousSignNumber doesn't already contain this
 BNE sign1              \ sign number, jump to sign1 to skip the following

                        \ We get here if we are calling BuildRoadSign again for
                        \ the same sign number (we set previousSignNumber to
                        \ the current sign number later in the routine)
                        \
                        \ This ensures that we display signs at the start of
                        \ sections that have a different value in bits 4-7 of
                        \ trackSectionData compared to the previous section, so
                        \ signs appear when we move into a section with a new
                        \ value in bits 4-7 of the trackSectionData (and that
                        \ value is the number of the sign to show)

 ADC #0                 \ Increment the sign number in A (we know the C flag is
                        \ set, as the above comparison was equal)

 AND #15                \ Restrict the result to the range 0 to 15, i.e. set A
                        \ to A mod 16

.sign1

 TAX                    \ Set X to the sign number, which will either be the
                        \ sign number from trackSectionData for this section, or
                        \ the sign number plus 1

                        \ We now draw sign number X, by fetching the track sign
                        \ vector, adding it to the track section coordinate to
                        \ get the sign's 3D coordinates, and subtracting the
                        \ player's coordinates to get the sign's vector relative
                        \ to the player (i.e. relative to the camera)
                        \
                        \ We then calculate the rotation and elevation angles
                        \ and create an object in driver 23, so it can be drawn
                        \ by the call to DrawCarOrSign from the main driving
                        \ loop

 LDY #2                 \ Set Y = 2, so the call to AddScaledVector scales by
                        \ 2 ^ (8 - Y) = 2 ^ 6

 STY W                  \ Set W = 2, which gets decremented through each call
                        \ to AddScaledVector as we work through each axis, so it
                        \ stores the results in each axis of xVector6 in turn

 LDA zTrackSignVector,X \ Set A to the 3D z-coordinate of the track sign vector

 JSR AddScaledVector    \ Set zVector6 = zPlayerCoord - zTrackSignVector * 2 ^ 6

 LDY #4                 \ Set Y = 4, so the call to AddScaledVector scales by
                        \ 2 ^ (8 - Y) = 2 ^ 4

 LDA yTrackSignVector,X \ Set A to the 3D y-coordinate of the track sign vector

 JSR AddScaledVector    \ Set yVector6 = yPlayerCoord - yTrackSignVector * 2 ^ 4

 LDY #2                 \ Set Y = 2, so the call to AddScaledVector scales by
                        \ 2 ^ (8 - Y) = 2 ^ 6

 LDA xTrackSignVector,X \ Set A to the 3D x-coordinate of the track sign vector

 JSR AddScaledVector    \ Set xVector6 = xPlayerCoord - xTrackSignVector * 2 ^ 6

                        \ We now have:
                        \
                        \   [ xVector6 ]   [ xPlayerCoord ]
                        \   [ yVector6 ] = [ yPlayerCoord ]
                        \   [ zVector6 ]   [ zPlayerCoord ]
                        \
                        \                  [ xTrackSignVector * 2 ^ 6 ]
                        \                - [ yTrackSignVector * 2 ^ 4 ]
                        \                  [ zTrackSignVector * 2 ^ 6 ]

 LDA trackSignData,X    \ Set objectType to the object type for road sign X,
 AND #%00000111         \ which comes from bits 0-2 of trackSignData, and
 CLC                    \ gets 7 added to get the range 7 to 12
 ADC #7
 STA objectType

 LDA trackSignData,X    \ Set Y to the track section number for road sign X,
 AND #%11111000         \ which comes from bits 3-7 of trackSignData
 TAY

 LDX #&FD               \ Set X = &FD so the calls to GetSectionCoord,
                        \ GetObjRotation and GetObjElevation use xVector4,
                        \ yVector4 and zVector4

 JSR GetSectionCoord    \ Copy the first trackSectionI coordinate for track
                        \ section Y into xVector4, so xVector4 contains the 3D
                        \ coordinates of the inside track for the start of this
                        \ track section, i.e.
                        \
                        \   [ xVector4 ]   [ xTrackSectionI ]
                        \   [ yVector4 ] = [ yTrackSectionI ]
                        \   [ zVector4 ]   [ zTrackSectionI ]

 LDY #6                 \ Set Y = 6 so the call to GetObjRotation uses xVector6
                        \ for the second variable, so we calculate the rotation
                        \ and elevation angles for an object at the following 3D
                        \ coordinates (if we just consider the the x-axis, for
                        \ clarity):
                        \
                        \    xVector4 - xVector6
                        \  = xTrackSectionI - (xPlayerCoord - xTrackSignVector)
                        \  = xTrackSectionI - xPlayerCoord + xTrackSignVector
                        \  = xTrackSectionI + xTrackSignVector - xPlayerCoord
                        \
                        \ The xPlayerCoord vector contains the 3D coordinates
                        \ of the player's car, so the above gives us the vector
                        \ from the player's car to the sign
                        \
                        \ So this is the vector we use to calculate the object's
                        \ angles, to show the sign in the correct place by the
                        \ side of the track from the viewpoint of the player

 JSR GetObjRotation     \ Calculate the object's rotation angle about the
                        \ y-axis, returning it in (JJ II)

 LDA II                 \ Set the rotation about the y-axis in (objRotationHi+23
 STA objRotationLo+23   \ objRotationLo+23) to (JJ II), so we use driver 23 to
 LDA JJ                 \ store the sign's object
 STA objRotationHi+23

                        \ Now that the sign object has been built and the angles
                        \ calculated, we can check for any collisions between
                        \ the player and the sign

 SEC                    \ Set A = JJ - playerRotationHi
 SBC playerRotationHi

 JSR Absolute8Bit       \ Set A = |A|
                        \       = |JJ - playerRotationHi|
                        \
                        \ So A contains the screen distance between the player
                        \ and the sign in the x-axis

 CMP #64                \ If A < 64, jump to sign2 to skip the following
 BCC sign2

 LDY temp4              \ Set previousSignNumber to the sign number from the
 STY previousSignNumber \ trackSectionData, so the next time we display a sign
                        \ it will be the next sign

.sign2

 LDY #37                \ Set Y = 37 to use as the collision distance in the
                        \ call to CheckForContact below

 CMP #110               \ If A < 110, jump to sign3 to skip the following
 BCC sign3

 LDY #80                \ Set Y = 80 to use as the collision distance in the
                        \ call to CheckForContact below

.sign3

 LDA #23                \ Set L0042 = 23, so if we are colliding with the sign,
 STA L0042              \ CheckForContact sets collisionDriver to object 23

 JSR CheckForContact    \ Check to see if the object and the player's car are
                        \ close enough for contact, specifically if they are
                        \ within a distance of Y from each other

                        \ The final step is to calculate the object's elevation
                        \ angle, and then we are done building the sign object

 LDY #6                 \ Set Y = 6 so the call to GetObjElevation uses xVector6

 JSR GetObjElevation    \ Calculate the object's elevation angle, returning it
                        \ in A and LL
                        \
                        \ If the object is not visible on-screen, the C flag is
                        \ set, which will hide the object in the following call
                        \ to SetObjectDetails

 JSR SetObjectDetails   \ Set the object's visibility, scale and type

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: AddScaledVector
\       Type: Subroutine
\   Category: Maths
\    Summary: Add a scaled vector to another vector, one axis at a time
\
\ ------------------------------------------------------------------------------
\
\ This routine does the following calculation, one axis at a time (starting with
\ the z-axis, then the y-axis and x-axis):
\
\   [ xVector6 ]   [ xPlayerCoord ]   [ xTrackSignVector * 2 ^ (8 - Y) ]
\   [ yVector6 ] = [ yPlayerCoord ] - [ yTrackSignVector * 2 ^ (8 - Y) ]
\   [ zVector6 ]   [ zPlayerCoord ]   [ zTrackSignVector * 2 ^ (8 - Y) ]
\
\ The value of Y can be varied between calls to change the scale factor on a
\ per-axis basis.
\
\ Arguments:
\
\   A                   The relevant from xTrackSignVector, yTrackSignVector,
\                       zTrackSignVector
\
\   W                   Set to 2 for the first call
\
\   Y                   The scale factor for this axis
\
\ ******************************************************************************

.AddScaledVector

 PHA                    \ Set (V A T) = (0 A 0)
 LDA #0                 \             = A * 256
 STA T
 STA V
 PLA

 BPL addv1              \ If A is positive then V is already the correct high
                        \ byte for (V A T), so jump to addv1

 DEC V                  \ Otherwise, decrement V to &FF so it's the correct
                        \ high byte for (V A T)

                        \ We now shift (V A T) right by Y places

.addv1

 LSR V                  \ Set (V A T) = (V A T) >> 1
 ROR A
 ROR T

 DEY                    \ Decrement the shift counter

 BNE addv1              \ Loop back until we have right-shifted Y times

 STA U                  \ Set (V U T) = (V A T)
                        \             = A * 256 >> Y
                        \             = A * 2 ^ (8 - Y)
                        \
                        \ We know that V doesn't contain any data, just sign
                        \ bits, so this means:
                        \
                        \   (U T) = A * 2 ^ (8 - Y)
                        \         = xTrackSignVector * 2 ^ (8 - Y)

 LDY W                  \ Fetch the axis index from W

 DEC W                  \ Decrement the axis index in W, ready for the next call
                        \ to AddScaledVector

 LDA xPlayerCoordLo,Y   \ Set xVector6 = xPlayerCoord - (U T)
 SEC                    \
 SBC T                  \ starting with the low bytes
 STA xVector6Lo,Y

 LDA xPlayerCoordHi,Y   \ And then the high bytes
 SBC U
 STA xVector6Hi,Y

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: InitialiseDrivers
\       Type: Subroutine
\   Category: Drivers
\    Summary: Initialise all 20 drivers on the starting grid
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The routine is always called with X = 0
\
\ ******************************************************************************

.InitialiseDrivers

 STX setSpeedForDriver  \ Set setSpeedForDriver = 0, to use as a loop counter
                        \ when initialising all 20 drivers

 STX raceClass          \ Set raceClass = 0 (Novice)

 JSR SetBestRacingLine  \ Set up the 24 bytes at bestRacingLine for a Novice
                        \ race, returning with X unchanged

                        \ The following loop works starts with X = 0, and then
                        \ loops down from 19 to 1, working its way through each
                        \ of the 20 drivers

.driv1

 TXA                    \ Set A to the current driver number in X

 STA driversInOrder,X   \ Set driversInOrder for driver X to the driver number

 LSR A                  \ Set the grid row for driver X to driver number >> 1,
 NOP                    \ so drivers 0 and 1 are on row 0, drivers 2 and 3 are
 STA driverGridRow,X    \ on row 1, and so on, up to row 9 at the back of the
                        \ grid

 JSR SetDriverSpeed     \ Set the base speed for driver X
                        \
                        \ It also decrements X to the next driver number and
                        \ updates setSpeedForDriver accordingly

 LDA #0                 \ Zero (totalPointsTop totalPointsHi totalPointsLo) for
 STA totalPointsLo,X    \ driver X
 STA totalPointsHi,X
 STA totalPointsTop,X

 TXA                    \ If X <> 0, loop back to driv1 to process the next
 BNE driv1              \ driver, until we have processed all 20 of them

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintSecondLine
\       Type: Subroutine
\   Category: Text
\    Summary: Prints a text token on the second text line at the top of the
\             driving screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The token number (0 to 54)
\
\ ******************************************************************************

.PrintSecondLine

 LDA #33                \ Set A = 33 to use as the value for yCursor below, so
                        \ we print the text token on the second text line at the
                        \ top of the driving screen

 BNE PrintFirstLine+2   \ Jump to PrintFirstLine+2 to print the token in X on
                        \ the second text line in the driving screen (this BNE
                        \ is effectively a JMP as A is never zero)

\ ******************************************************************************
\
\       Name: PrintFirstLine
\       Type: Subroutine
\   Category: Text
\    Summary: Prints a text token on the first text line at the top of the
\             driving screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The token number (0 to 54)
\
\ Other entry points:
\
\   PrintFirstLine+2    Print the token on the second text line at the top of
\                       the driving screen
\
\ ******************************************************************************

.PrintFirstLine

 LDA #24                \ Set A = 24 to use as the value for yCursor below, so
                        \ we print the text token on the first line of the two
                        \ text lines at the top of the driving screen

 STA yCursor            \ Move the cursor to pixel row A (which will either be
                        \ the first or the second text line at the top of the
                        \ screen)

 LDA #1                 \ Move the cursor to character column 1
 STA xCursor

                        \ Fall through into PrintToken to print the token in X
                        \ at (xCursor, yCursor)

\ ******************************************************************************
\
\       Name: PrintToken
\       Type: Subroutine
\   Category: Text
\    Summary: Print a recursive token
\  Deep dive: Text tokens
\
\ ------------------------------------------------------------------------------
\
\ Addresses of token strings are in the (tokenHi tokenLo) table. Tokens are
\ numbered from 0 to 54.
\
\ Each token's string contains bytes that are printed as follows:
\
\   * 0-159     Print character n
\   * 160-199   Print n - 160 spaces (0 to 39)
\   * 200-254   Print token n - 200 (0 to 54)
\   * 255       End of token
\
\ Arguments:
\
\   X                   The token number (0 to 54)
\
\   (xCursor, yCursor)  The on-screen position for the token
\
\ ******************************************************************************

.PrintToken

 LDY #0                 \ We are about to work our way through the token, one
                        \ byte at a time, so set a byte counter in Y

.toke1

 LDA tokenHi,X          \ Set (S R) = the X-th entry in (tokenHi tokenLo), which
 STA S                  \ points to the string of bytes in token X
 LDA tokenLo,X
 STA R

.toke2

 LDA (R),Y              \ Set A to the Y-th byte at (S R), which contains the
                        \ next character in the token

 CMP #255               \ If A = 255 then we have reached the end of the token,
 BEQ toke8              \ so jump to toke8 to return from the subroutine

 CMP #200               \ If A < 200 then this byte is not another token, so
 BCC toke5              \ jump to toke5

 SEC                    \ A >= 200, so this is a pointer to another token
 SBC #200               \ embedded in the current token, so subtract 200 to get
                        \ the embedded token's number

 STA T                  \ Store the embedded token's number in T

 TXA                    \ Store X and Y on the stack so we can retrieve them
 PHA                    \ after printing the embedded token
 TYA
 PHA

 LDX T                  \ Set X to the number of the embedded token we need to
                        \ print

 CPX #54                \ If X <> 54, jump to toke3 to skip the following three
 BNE toke3              \ instructions and print the embedded token

 LDX #0                 \ X = 54, so call PrintHeader with X = 0 to print
 JSR PrintHeader        \ "FORMULA 3  CHAMPIONSHIP" as a double-height header
                        \ at column 4, row 3, in yellow text on a red background

 JMP toke4              \ Skip the following instruction

.toke3

 JSR PrintToken         \ Print token X (so if it also contains embedded tokens,
                        \ they will also be expanded and printed)

.toke4

 PLA                    \ Retrieve X and Y from the stack
 TAY
 PLA
 TAX

 INY                    \ Increment the byte counter

 JMP toke1              \ Loop back to print the next byte in the token, making
                        \ sure to recalculate (S R) as it will have been
                        \ corrupted by the call to PrintToken

.toke5

                        \ If we get here then A < 200, so this byte is not
                        \ another token

 CMP #160               \ If A < 160, jump to toke6 to skip the following three
 BCC toke6              \ instructions

 SBC #160               \ A is in the range 160 to 199, so subtract 160 to get
                        \ the number of spaces to print, in the range 0 to 39

 JSR PrintSpaces        \ Print the number of spaces in A

 BEQ toke7              \ Skip the following instruction (this BNE is
                        \ effectively a JMP as PrintSpaces sets the Z flag)

.toke6

 JSR PrintCharacter     \ Print the character in A (which is in the range 0 to
                        \ 159)

.toke7

 INY                    \ Increment the byte counter

 JMP toke2              \ Loop back to print the next byte in the token

.toke8

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C4DC9
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4DC9

 LDA speedHi

\ ******************************************************************************
\
\       Name: sub_C4DCB
\       Type: Subroutine
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.sub_C4DCB

 LSR A
 STA L0026
 LSR A
 STA L0028
 INC L002D
 SEC
 ROR spinSpeedLo

 LDA #4                 \ Make sound #4 (crash/contact) at the current volume
 JSR MakeSound-3        \ level

 RTS

\ ******************************************************************************
\
\       Name: SetCustomScreen
\       Type: Subroutine
\   Category: Screen mode
\    Summary: Switch to the custom screen mode
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\    screenSection      screenSection is set to -2, so the interrupt handler at
\                       ScreenHandler does not do anything straight away, but
\                       leaves the palette mapped to black, so the screen is
\                       blank
\
\ ******************************************************************************

.SetCustomScreen

 SEI                    \ Disable interrupts so we can update the 6845 registers

                        \ First we switch screen mode to the custom screen mode
                        \ used for the race, which is based on mode 5 but is
                        \ shorter at 26 character rows rather than 40
                        \
                        \ We do this by first reprogramming registers R0 to R13
                        \ of the 6845 CRTC chip using the values in the
                        \ screenRegisters table (see the screenRegisters
                        \ variable for details), and then programming register 0
                        \ of the Video ULA to the same value as standard mode 5

 LDX #13                \ We are about to write values into registers R0 to R13
                        \ so set a register counter in X to count down from 13
                        \ to 0

.cust1

 STX VIA+&00            \ Put register number X into SHEILA &00, so we can now
                        \ set the value of this 6845 register

 LDA screenRegisters,X  \ Set register X to the X-th value of screenRegisters
 STA VIA+&01

 DEX                    \ Decrement the register counter

 BPL cust1              \ Loop back until we have set registers R0 to R13 to the
                        \ values in the screenRegisters table

 DEX                    \ Set screenSection = -2, as the above loop finishes
 STX screenSection      \ with X = -1

 CLI                    \ Re-enable interrupts

 LDA #154               \ Call OSBYTE with A = 154 to set register 0 of the
 LDX #%11000100         \ Video ULA to the value in X, which sets the following,
 JSR OSBYTE             \ reading from bit 7 to bit 0:
                        \
                        \   %1  = master cursor size = large cursor
                        \   %10 = width of cursor in bytes = 2
                        \   %0  = 6845 clock rate select = low frequency clock
                        \   %01 = number of characters per line = 20
                        \   %0  = teletext output select = on-chip serialiser
                        \   %0  = flash colour select = first colour selected
                        \
                        \ These values are the same as in standard mode 5, and
                        \ this call finishes the switch to our custom screen
                        \ mode

 CLC                    \ Clear the C flag for the additions in the following
                        \ loop

                        \ We now send the following bytes to the Video ULA
                        \ palette in SHEILA &21, by starting at 7 and adding &10
                        \ to send &07, &17, &27 ... &E7, &F7
                        \
                        \ This maps all four logical colours (the top nibble) to
                        \ &7 EOR 7 (the bottom nibble, EOR 7), which maps them
                        \ to colour 0, or black

 LDA #&07               \ Set A = &07 as the first byte to send

.cust2

 STA VIA+&21            \ Send A to SHEILA &21 to send the palette byte in A to
                        \ the Video ULA

 ADC #&10               \ Set A = A + &10

 BCC cust2              \ Loop back until the addition overflows after we send
                        \ &F7 to the ULA

 SEI                    \ Disable interrupts so we can update the VIAs

 LDA IRQ1V              \ Store the current address from the IRQ1V vector in
 STA irq1Address        \ irq1Address, so the IRQ handler can jump to it after
 LDA IRQ1V+1            \ implementing the custom screen mode
 STA irq1Address+1

 LDA #2                 \ This instruction appears to have no effect, as we are
                        \ about to overwrite A and the processor flags

.cust3

 BIT VIA+&4D            \ Read the 6522 System VIA interrupt flag register IFR
                        \ (SHEILA &4D), which has bit 1 set if vertical sync
                        \ has occurred on the video system

 BEQ cust3              \ Loop back to cust3 to keep reading the System VIA
                        \ until the vertical sync occurs

 LDA #%01000000         \ Set 6522 User VIA auxiliary control register ACR
 STA VIA+&6B            \ (SHEILA &6B) bits 7 and 6 to disable PB7 (which is one
                        \ of the pins on the user port) and set continuous
                        \ interrupts for timer 1

 ORA VIA+&4B            \ Set 6522 System VIA auxiliary control register ACR
 STA VIA+&4B            \ (SHEILA &6B) bit 6 to set continuous interrupts for
                        \ timer 1

 LDA #%11000000         \ Set 6522 User VIA interrupt enable register IER
 STA VIA+&6E            \ (SHEILA &4E) bits 6 and 7 (i.e. enable the Timer1
                        \ interrupt from the User VIA)

 STA VIA+&4E            \ Set 6522 System VIA interrupt enable register IER
                        \ (SHEILA &4E) bits 6 and 7 (i.e. enable the Timer1
                        \ interrupt from the System VIA)

 LDA #&D4               \ Set 6522 User VIA T1C-L timer 1 low-order counter to
 STA VIA+&64            \ (SHEILA &44) to &D4 (so this sets the low-order
                        \ counter but does not start counting until the
                        \ high-order counter is set)

 LDA #&11               \ Set 6522 User VIA T1C-H timer 1 high-order counter
 STA VIA+&65            \ (SHEILA &45) to &11 to start the T1 counter
                        \ counting down from &1164 (4452) at a rate of 1 MHz

 LDA #&01               \ Set 6522 System VIA T1L-L timer 1 low-order latches
 STA VIA+&46            \ to &01 (so this sets the low-order counter but does
                        \ not start counting until the high-order counter is
                        \ set)

 LDA #&3D               \ Set 6522 System VIA T1C-H timer 1 high-order counter
 STA VIA+&45            \ to &3D, to start the T1 counter counting down from
                        \ &3D01

 LDA #&1E               \ Set 6522 System VIA T1L-L timer 1 low-order latches
 STA VIA+&46            \ to &1E (so this sets the low-order counter but does
                        \ not start counting until the high-order counter is
                        \ set)

 STA VIA+&66            \ Set 6522 User VIA T1L-L timer 1 low-order latches
                        \ to &1E (so this sets the low-order counter but does
                        \ not start counting until the high-order counter is
                        \ set)

 LDA #&4E               \ Set 6522 System VIA T1L-H timer 1 high-order latches
 STA VIA+&47            \ to &4E (so this sets the timer to &4E1E (19998) but
                        \ does not start counting until the current timer has
                        \ run down)

 STA VIA+&67            \ Set 6522 User VIA T1L-H timer 1 high-order latches
                        \ to &4E (so this sets the timer to &4E1E (19998) but
                        \ does not start counting until the current timer has
                        \ run down)

 LDA #HI(ScreenHandler) \ Set the IRQ1V vector to ScreenHandler, so the
 STA IRQ1V+1            \ ScreenHandler routine is now the interrupt handler
 LDA #LO(ScreenHandler)
 STA IRQ1V

 CLI                    \ Re-enable interrupts

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ScreenHandler
\       Type: Subroutine
\   Category: Screen mode
\    Summary: The IRQ handler for the custom screen mode
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ------------------------------------------------------------------------------
\
\ The screen handler starts a new screen with screenSection = -1, and then
\ increments it through 0, 1, 2, 3, 4 and 5, at which point this handler stops
\ doing anything.
\
\ Other entry points:
\
\   ScreenHandler-3     Jump to the original IRQ handler
\
\ ******************************************************************************

 JMP (irq1Address)      \ Jump to the original address from IRQ1V to pass
                        \ control to the next interrupt handler

.ScreenHandler

 LDA VIA+&6D            \ Set A to the 6522 User VIA interrupt flag register IFR
                        \ (SHEILA &46D)

 AND #%01000000         \ Extract bit 6, which is set when 6522 User VIA timer 1
                        \ runs down to zero

 BEQ ScreenHandler-3    \ If the Timer1 interrupt has not fired, jump up to
                        \ ScreenHandler-3 as we do not need to do anything at
                        \ this point

 STA VIA+&6D            \ Set bit 6 of the 6522 User VIA interrupt flag register
                        \ IFR (SHEILA &6D) to clear the timer 1 interrupt (the
                        \ timer will already have restarted as we set it to
                        \ continuous interrupts in SetCustomScreen)

 TXA                    \ Store X on the stack so we can preserve it through the
 PHA                    \ interrupt handler

 CLD                    \ Clear the D flag to switch arithmetic to normal

 LDA screenSection      \ If screenSection = 0, jump to hand1
 BEQ hand1

 BMI hand4              \ If screenSection is negative, jump to hand4

 CMP #2                 \ If screenSection < 2, i.e. screenSection = 1, jump to
 BCC hand5              \ hand5

 BEQ hand7              \ If screenSection = 2, jump to hand7

 CMP #3                 \ If screenSection = 3, jump to hand9
 BEQ hand9

 BCS hand11             \ If screenSection >= 3, i.e. screenSection = 4, jump
                        \ to hand11

.hand1

                        \ If we get here, then screenSection = 0, so we set the
                        \ screen mode to 4 and the palette for the top two lines
                        \ of text (where the race information is printed)

 LDA #%10001000         \ Set the Video ULA control register (SHEILA &20) to
 STA VIA+&20            \ %10001000, which is the same as switching to mode 4

 LDX #15                \ We now send the 16 palette bytes at paletteSection0 to
                        \ the Video ULA palette in SHEILA &21, so set a loop
                        \ counter in X


.hand2

 LDA paletteSection0,X  \ Set the X-th byte of paletteSection0 to the Video ULA
 STA VIA+&21            \ palette

 DEX                    \ Decrement the loop counter

 BPL hand2              \ Loop back until we have sent all 16 bytes

.hand3

 LDA #&C4               \ Set (X A) = &0FC4 to latch into the User VIA timer 1,
 LDX #&0F               \ so on the next timer loop it counts down from &0FC4
                        \ (4036)

 BNE hand13             \ Jump to hand13 to latch (X A) into User VIA timer 1
                        \ and return from the subroutine (this BNE is
                        \ effectively a JMP as X is never zero)

.hand4

                        \ If we get here, then screenSection is negative

 CMP #&FF               \ If screenSection <> -1, then jump to hand14 to
 BNE hand14             \ return from the interrupt handler

                        \ If we get here, then screenSection = -1

 INC screenSection      \ Set screenSection = 0

 BEQ hand3              \ Jump to hand3 to set timer 1 counting down from &0FC4
                        \ and return from the interrupt handler (this BNE is
                        \ effectively a JMP as screenSection is always zero)

.hand5

                        \ If we get here, then screenSection = 1, so we change
                        \ the palette so everything is blue, as this is the
                        \ portion of cloudless sky between the text at the top
                        \ of the screen and the car and track at the bottom

 LDA #%11000100         \ Set the Video ULA control register (SHEILA &20) to
 STA VIA+&20            \ %11000100, which is the same as switching to mode 5

 CLC                    \ Clear the C flag for the additions in the following
                        \ loop

                        \ We now send the following bytes to the Video ULA
                        \ palette in SHEILA &21, by starting at 3 and adding &10
                        \ to send &03, &13, &23 ... &E3, &F3
                        \
                        \ This maps all four logical colours (the top nibble) to
                        \ &3 EOR 7 (the bottom nibble, EOR 7), which maps them
                        \ to colour 4, or blue

 LDA #&03               \ Set A = &03 as the first byte to send

.hand6

 STA VIA+&21            \ Send A to SHEILA &21 to send the palette byte in A to
                        \ the Video ULA

 ADC #&10               \ Set A = A + &10

 BCC hand6              \ Loop back until the addition overflows after we send
                        \ &F3 to the ULA

 LDA #&3C               \ Set (timer2Hi timer2Lo) = &153C - (timer1Hi timer1Lo)
 SEC                    \
 SBC timer1Lo           \ starting with the low bytes
 STA timer2Lo

 LDA #&15               \ And then the high bytes
 SBC timer1Hi
 STA timer2Hi

 LDA timer1Lo           \ Set (X A) = (timer1Hi timer1Lo) to latch into the User
 LDX timer1Hi           \ VIA timer 1, so on the next timer loop it counts down
                        \ from (timer1Hi timer1Lo)

 BCS hand13             \ Jump to hand13 to latch (X A) into User VIA timer 1
                        \ and return from the subroutine (this BCS is
                        \ effectively a JMP as the C flag is still set from
                        \ above)

.hand7

                        \ If we get here, then screenSection = 2

 LDX #15                \ We now send the 16 palette bytes at paletteSection2 to
                        \ the Video ULA palette in SHEILA &21, so set a loop
                        \ counter in X

.hand8

 LDA paletteSection2,X  \ Set the X-th byte of paletteSection2 to the Video ULA
 STA VIA+&21            \ palette

 DEX                    \ Decrement the loop counter

 BPL hand8              \ Loop back until we have sent all 16 bytes

 LDA timer2Lo           \ Set (X A) = (timer2Hi timer2Lo) to latch into the User
 LDX timer2Hi           \ VIA timer 1, so on the next timer loop it counts down
                        \ from (timer2Hi timer2Lo)

 BNE hand13             \ Jump to hand13 to latch (X A) into User VIA timer 1
                        \ and return from the subroutine (this BNE is
                        \ effectively a JMP as X is never zero)

.hand9

                        \ If we get here, then screenSection = 3

 LDX #3                 \ We now send the 3 palette bytes at paletteSection3 to
                        \ the Video ULA palette in SHEILA &21, so set a loop
                        \ counter in X

.hand10

 LDA paletteSection3,X  \ Set the X-th byte of paletteSection2 to the Video ULA
 STA VIA+&21            \ palette

 DEX                    \ Decrement the loop counter

 BPL hand10             \ Loop back until we have sent all 16 bytes

 LDA #&00               \ Set (X A) = &1E00 to latch into the User VIA timer 1,
 LDX #&1E               \ so on the next timer loop it counts down from &1E00
                        \ (7680)

 BNE hand13             \ Jump to hand13 to latch (X A) into User VIA timer 1
                        \ and return from the subroutine (this BNE is
                        \ effectively a JMP as X is never zero)

.hand11

                        \ If we get here, then screenSection = 4

 LDX #3                 \ We now send the 3 palette bytes at paletteSection4 to
                        \ the Video ULA palette in SHEILA &21, so set a loop
                        \ counter in X

.hand12

 LDA paletteSection4,X  \ Set the X-th byte of paletteSection2 to the Video ULA
 STA VIA+&21            \ palette

 DEX                    \ Decrement the loop counter

 BPL hand12             \ Loop back until we have sent all 16 bytes

 STX screenSection      \ Set screenSection = -1, as the above loop finishes
                        \ with X = 255

 JSR AnimateTyres       \ Animate the tyres on either side of the screen

 LDA #&FF               \ Set 6522 User VIA T2C-H timer 2 high-order counter
 STA VIA+&69            \ (SHEILA &69) to &FF to start the T2 counter
                        \ counting down from &FFxx at a rate of 1 MHz

 LDA #&16               \ Set (X A) = &0B16 to latch into the User VIA timer 1,
 LDX #&0B               \ so on the next timer loop it counts down from &0B16
                        \ (2838)

.hand13

 STX VIA+&67            \ Set 6522 User VIA T1L-H and T1L-L to set both timer 1
 STA VIA+&66            \ latches (so this sets the timer to (X A) but does not
                        \ start counting until the current timer has run down)

 INC screenSection      \ Increment the screen section counter to move on to the
                        \ next section

.hand14

 PLA                    \ Restore X from the stack
 TAX

 LDA &FC                \ Set A to the interrupt accumulator save register,
                        \ which restores A to the value it had on entering the
                        \ interrupt

 RTI                    \ Return from interrupts, so this interrupt is not
                        \ passed on to the next interrupt handler, but instead
                        \ the interrupt terminates here

\ ******************************************************************************
\
\       Name: screenRegisters
\       Type: Variable
\   Category: Screen mode
\    Summary: The 6845 registers for the custom screen mode
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ------------------------------------------------------------------------------
\
\ The custom screen mode used during the race is based on standard mode 5, but
\ with the following differences:
\
\   * Horizontal sync position = 45 instead of 49
\   * Vertical displayed       = 26 instead of 32
\   * Vertical sync position   = 32 instead of 34
\   * Screen memory start      = &5A80 instead of &5800
\
\ So essentially it is a shorter mode 5 that takes up less memory, adjusts the
\ vertical and horizontal sync positions accordingly, and lives in screen memory
\ from &5A80 to &7AFF (as there are 26 character rows of 40 characters, with 8
\ bytes per character, giving 26 * 40 * 8 = 8320 bytes of screen memory, and
\ &5A80 + 8320 = &7B00).
\
\ ******************************************************************************

.screenRegisters

 EQUB 63                \ Set 6845 register R0 = 63
                        \
                        \ This is the "horizontal total" register, which sets
                        \ the horizontal sync frequency, i.e. the number of
                        \ horizontal characters minus one. This value is the
                        \ same as in standard mode 5

 EQUB 40                \ Set 6845 register R1 = 40
                        \
                        \ This is the "horizontal displayed" register, which
                        \ defines the number of character blocks per horizontal
                        \ character row. This value is the same as in standard
                        \ mode 5

 EQUB 49                \ Set 6845 register R2 = 45
                        \
                        \ This is the "horizontal sync position" register, which
                        \ defines the position of the horizontal sync pulse on
                        \ the horizontal line in terms of character widths from
                        \ the left-hand side of the screen. For comparison this
                        \ is 49 for mode 5, but is adjusted for our custom
                        \ screen

 EQUB &24               \ Set 6845 register R3 = &24
                        \
                        \ This is the "sync width" register, which sets the
                        \ horizontal sync width in characters using the low
                        \ nibble (i.e. 4), and the vertical sync width in the
                        \ high nibble (i.e. 2). These values are the same as in
                        \ standard mode 5

 EQUB 38                \ Set 6845 register R4 = 38
                        \
                        \ This is the "vertical total" register, which contains
                        \ the integer part of the vertical sync frequency minus
                        \ one. This value is the same as in standard mode 5

 EQUB 0                 \ Set 6845 register R5 = 0
                        \
                        \ This is the "vertical total adjust" register, which
                        \ contains the fractional part of the vertical sync
                        \ frequency. This value is the same as in standard mode
                        \ 5

 EQUB 26                \ Set 6845 register R6 = 26
                        \
                        \ This is the "vertical displayed" register, which sets
                        \ the number of displayed character rows to 26. For
                        \ comparison, this value is 32 for standard modes 4 and
                        \ 5, but we claw back six rows for storing code above
                        \ the end of screen memory

 EQUB 32                \ Set 6845 register R7 = 32
                        \
                        \ This is the "vertical sync position" register, which
                        \ determines the vertical sync position with respect to
                        \ the reference, programmed in character row times. For
                        \ comparison this is 34 for mode 5, but needs to be
                        \ adjusted for our custom screen's vertical sync

 EQUB %00000001         \ Set 6845 register R8 = %00000001
                        \
                        \ This is the "interlace and display" register, which
                        \ sets the following, reading from bit 7 to bit 0:
                        \
                        \   %00 = no delay in the cursor blanking signal
                        \   %00 = no delay in the display blanking signal
                        \   %00 = not used
                        \   %01 = interlace sync mode
                        \
                        \ These values are the same as in standard mode 5

 EQUB 7                 \ Set 6845 register R9 = 7
                        \
                        \ This is the "scan lines per character" register, and
                        \ contains the number of scan lines per character row,
                        \ including spacing, minus one. This value is the same
                        \ as in standard mode 5

 EQUB %01100111         \ Set 6845 register R10 = %01100111
                        \
                        \ This is the "cursor start" register, which sets the
                        \ following, reading from bit 7 to bit 0:
                        \
                        \   %0 = not used
                        \   %1 = enable blink feature
                        \   %1 = set blink frequency to 32 times the field rate
                        \   %00111 = cursor end scan line
                        \
                        \ These values are the same as in standard mode 5

 EQUB 8                 \ Set 6845 register R11 = 8
                        \
                        \ This is the "cursor end" register, which sets the
                        \ cursor end scan line. This value is the same as in
                        \ standard mode 5

 EQUB &0B               \ Set 6845 register R12 = &0B and R13 = &50
 EQUB &50               \
                        \ This sets 6845 registers (R12 R13) = &0B50 to point
                        \ to the start of screen memory in terms of character
                        \ rows. There are 8 pixel lines in each character row,
                        \ so to get the actual address of the start of screen
                        \ memory, we multiply by 8:
                        \
                        \   &0B50 * 8 = &5A80
                        \
                        \ So this sets the start of screen memory to &5A80

\ ******************************************************************************
\
\       Name: irq1Address
\       Type: Variable
\   Category: Screen mode
\    Summary: Stores the previous value of IRQ1V before we install our custom
\             IRQ handler
\
\ ******************************************************************************

.irq1Address

 EQUW 0

\ ******************************************************************************
\
\       Name: timer1Lo
\       Type: Variable
\   Category: Screen mode
\    Summary: Low byte of the timer offset between the start of section 2 and
\             the start of section 3
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.timer1Lo

 EQUB &D8

\ ******************************************************************************
\
\       Name: timer1Hi
\       Type: Variable
\   Category: Screen mode
\    Summary: High byte of the timer offset between the start of section 2 and
\             the start of section 3
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.timer1Hi

 EQUB &04

\ ******************************************************************************
\
\       Name: timer2Lo
\       Type: Variable
\   Category: Screen mode
\    Summary: Low byte of the timer offset between the start of section 3 and
\             the start of section 4
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.timer2Lo

 EQUB &64

\ ******************************************************************************
\
\       Name: timer2Hi
\       Type: Variable
\   Category: Screen mode
\    Summary: High byte of the timer offset between the start of section 3 and
\             the start of section 4
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.timer2Hi

 EQUB &10

\ ******************************************************************************
\
\       Name: KillCustomScreen
\       Type: Subroutine
\   Category: Screen mode
\    Summary: Disable the custom screen mode and switch to mode 7
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.KillCustomScreen

 SEI                    \ Disable interrupts so we can update the interrupt
                        \ vector and VIA

 LDA irq1Address        \ Set the IRQ1V vector to irq1Address, which removes the
 STA IRQ1V              \ custom screen interrupt handler from the chain
 LDA irq1Address+1
 STA IRQ1V+1

 LDA #%01000000         \ Set 6522 User VIA interrupt enable register IER
 STA VIA+&6E            \ (SHEILA &4E) bit 6 (i.e. disable the Timer1 interrupt
                        \ from the User VIA, as we no longer neeed it)

 CLI                    \ Re-enable interrupts

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers

                        \ Fall througn into SetScreenMode7 to switch to mode 7

\ ******************************************************************************
\
\       Name: SetScreenMode7
\       Type: Subroutine
\   Category: Screen mode
\    Summary: Change to screen mode 7 and hide the cursor
\
\ ******************************************************************************

.SetScreenMode7

 LDA #128               \ Set printMode = 128 so the call to PrintToken prints
 STA printMode          \ characters using OSWRCH (for mode 7)

 LDX #46                \ Print token 46, which changes to screen mode 7 and
 JSR PrintToken         \ hides the cursor

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: screenSection
\       Type: Variable
\   Category: Screen mode
\    Summary: The section of the screen that is currently being drawn by the
\             custom screen interrupt handler (0 to 4)
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.screenSection

 EQUB 0

\ ******************************************************************************
\
\       Name: MoveHorizon
\       Type: Subroutine
\   Category: Screen mode
\    Summary: Move the position of the horizon palette switch up or down,
\             depending on the current track height
\  Deep dive: Hidden secrets of the custom screen mode
\
\ ******************************************************************************

.MoveHorizon

 LDA #60                \ Set A = 60 - horizonLine
 SEC                    \
 SBC horizonLine        \ So A is larger when the horizon is low (i.e. when we
                        \ are cresting a hill), and smaller when the horizon is
                        \ high (i.e. when we are in a dip)

 BPL hori1              \ If A >= 0, then horizonLine <= 60, so jump to hori1

 CMP #&F5               \ If A >= -11, then horizonLine <= 71, so jump to hori2
 BCS hori2              \ with the C flag set

 LDA #&F5               \ Otherwise set A = -11 and set the C flag, so A has a
 SEC                    \ minimum value of -11

 BCS hori2              \ Jump to hori2 (this BCS is effectively a JMP as we
                        \ just set the C flag)

.hori1

                        \ If we get here then A >= 0, i.e. horizonLine <= 60

 CMP #18                \ If A < 18, jump to hori2 to skip the following two
 BCC hori2              \ instructions

 LDA #18                \ Otherwise set A = 18 and clear the C flag, so A has a
 CLC                    \ maximum value of 18

.hori2

 PHP                    \ Store the C flag on the stack, which will be clear if
                        \ A >= 0, or set if A < 0 (so the C flag is effectively
                        \ the sign bit of A)

 STA U                  \ Set (U A) = (A 0)
 LDA #0                 \           = A * 256
                        \
                        \ where -11 <= A < 18 and the sign bit of A is in C

 ROR U                  \ Set (U A) = (U A) >> 1, inserting the sign bit from C
 ROR A                  \ into bit 7

 PLP                    \ Set the C flag to the sign bit once again

 ROR U                  \ Set (U A) = (U A) >> 1, inserting the sign bit from C
 ROR A                  \ into bit 7
                        \
                        \ So by this point, we have:
                        \
                        \   (U A) = A * 256 / 4
                        \         = A * 64
                        \
                        \ with the correct sign, so (U A) is in the range -704
                        \ to 1152, and is larger when the horizon is low (i.e.
                        \ when we are cresting a hill), and smaller when the
                        \ horizon is high (i.e. when we are in a dip)
                        \
                        \ We now add this figure to (timer1Hi timer1Lo), which
                        \ determines the height of the horizon portion of the
                        \ custom screen mode, i.e. where the palette switches
                        \ from blue sky to the green ground
                        \
                        \ So when we are cresting a hill, (U A) is large and so
                        \ is timer 1, and therefore so is the size of the sky
                        \ above the the horizon in section 2 of the screen, so
                        \ the horizon dips down
                        \
                        \ Conversely, when we are in a dip, (U A) is small and
                        \ and so is timer 1, so the size of the sky section
                        \ above the horizon is smaller, so the horizon rises up
                        \
                        \ The range of (timer1Hi timer1Lo) values from the
                        \ following calculation is therefore:
                        \
                        \   Minimum: &04D8 - 704 = &0218 (we are in a dip)
                        \
                        \   Maximum: &04D8 + 1152 = &0958 (we are on a hill)

 SEI                    \ Disable interrupts so we can update the custom screen
                        \ variables

 CLC                    \ Set (timer1Hi timer1Lo) = (U A) + &04D8
 ADC #&D8               \
 STA timer1Lo           \ starting with the low bytes

 LDA #&04               \ And then the high bytes
 ADC U
 STA timer1Hi

 CLI                    \ Re-enable interrupts

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UpdateLaps
\       Type: Subroutine
\   Category: Drivers
\    Summary: Increment the lap number and lap times for a specific driver
\
\ ------------------------------------------------------------------------------
\
\ Update the lap number and lap times for driver X, but only if the following
\ are true:
\
\   * Driver number is in the range 0 to 19
\
\   * Bit 7 of updateLapTimes is clear
\
\   * Bit 6 of the driver's car's object status byte is clear (so the car is
\     still racing)
\
\   * If this is the current player, pastHalfway must be 1 (so the player is in
\     the second half of the track)
\
\ If these conditions are met, then the lap is incremented.
\
\ Arguments:
\
\   X                   Driver number (only drivers 0 to 19 have lap times)
\
\   updateLapTimes      If bit 7 is set, this routine does nothing
\
\ ******************************************************************************

.UpdateLaps

 BIT updateLapTimes     \ If bit 7 of updateLapTimes is set, jump to ulap1 to
 BMI ulap1              \ return from the subroutine without doing anything

 CPX #20                \ If X >= 20 then this is not a driver number, so jump
 BCS ulap1              \ to ulap1 to return from the subroutine

 LDA objectStatus,X     \ If bit 6 of the driver's car object status byte is
 ASL A                  \ set, the the car has finished racing, so jump to
 BMI ulap1              \ ulap1 to return from the subroutine without updating
                        \ the lap number

 CPX currentPlayer      \ If driver X is not the current player, jump to ulap3
 BNE ulap3              \ to skip updating the lap number top of the screen

                        \ If we get here then this is the current player, so now
                        \ we check the value of pastHalfway

 DEC pastHalfway        \ If pastHalfway = 1, then the player is in the second
 BEQ ulap2              \ half of the track, so set pastHalfway to 0 as the
 INC pastHalfway        \ player has just passwd the starting line into the
                        \ first half of the track, and jump to ulap2 to update
                        \ the lap details

.ulap1

 RTS                    \ Return from the subroutine

.ulap2

                        \ If we get here then this is the current player, and
                        \ pastHalfway has just been changed from 1 to 0, to
                        \ denote a new lap

 LDA #%10000000         \ Set bit 7 and clear bit 6 of updateDrivingInfo so the
 STA updateDrivingInfo  \ lap number gets updated at the top of the screen

.ulap3

                        \ If we get here then we have passed all the checks, so
                        \ it's time to increment the lap number and times,
                        \ starting with the lap number

 LDA driverLapNumber,X  \ Set A to the current lap number for driver X

 BMI ulap4              \ If A is negative, skip the following instruction

 INC driverLapNumber,X  \ Increment the current lap number for driver X

.ulap4

                        \ We now decide whether to increment the lap times

 BIT raceStarted        \ If bit 7 of raceStarted is clear then this is practice
 BPL ulap5              \ or qualifying, so jump to ulap5

                        \ If we get here then this is a race

 CMP numberOfLaps       \ If the current lap number for driver X < the number
 BCC ulap7              \ of laps in the race, then this is not the last lap in
                        \ the race, so jump to ulap7

 BEQ ulap6              \ If the current lap number for driver X = the number
                        \ of laps in the race, then this is the last lap in
                        \ the race, so jump to ulap6

                        \ If we get here then the current lap number is bigger
                        \ than the number of laps in the race, which means the
                        \ driver has already finished the race and is still
                        \ driving, so we don't increment the lap times

 RTS                    \ Return from the subroutine

.ulap5

                        \ If we get here then this is practice or qualifying

 CPX currentPlayer      \ If X <= the driver number of the current player, jump
 BEQ ulap7              \ to ulap7
 BCC ulap7

                        \ If we get here then driver X has a bigger number than
                        \ the current player, so we ignore it (is this because
                        \ the only players with numbers higher than the current
                        \ player are other players, rather than drivers) ???

 RTS                    \ Return from the subroutine

.ulap6

                        \ If we get here then this is a race and this is the
                        \ last lap in the race, so this driver just finished the
                        \ race (as this routine is all about incrementing the
                        \ lap number)

 CPX currentPlayer      \ If X <> the driver number of the current player, jump
 BNE ulap7              \ to ulap7

                        \ If we get here then driver X is the current player, so
                        \ the current player just finished the race

 LDA #80                \ Set leaveTrackTimer = 80, so we leave the track in 80
 STA leaveTrackTimer    \ main loop iterations and return to the game menu

.ulap7

                        \ If we get here, then it's time to increment the lap
                        \ times

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

                        \ We now subtract driver X's total race time from the
                        \ current clock time, to see whether this is a new best
                        \ time

 SEC                    \ Set T = clockTenths - totalRaceTenths for driver X
 LDA clockTenths
 SBC totalRaceTenths,X
 STA T

 LDA clockSeconds       \ Set A = clockSeconds - totalRaceSeconds for driver X
 SBC totalRaceSeconds,X

 BCS ulap8              \ If the subtraction underflowed, add 60 seconds to the
 ADC #&60               \ result
 CLC

.ulap8

 STA U                  \ Set U = A
                        \       = clockSeconds - totalRaceSeconds for driver X

 LDA clockMinutes       \ Set H = clockMinutes - totalRaceMinutes for driver X
 SBC totalRaceMinutes,X
 STA H

                        \ So by this point, (H U T) contains the time difference
                        \ between the clock time and driver X's total race time,
                        \ which is the current lap time (as we last updated the
                        \ driver's total time at the end of the last lap)

 BCC ulap9              \ If the subtraction underflowed, then somehow the clock
                        \ timer is showing a smaller time than driver X's total
                        \ race time, so this isn't a new best lap time, and we
                        \ jump to ulap9

 SEC                    \ Subtract (H U T) - driver X's best lap time
 LDA T
 SBC bestLapTenths,X
 LDA U
 SBC bestLapSeconds,X
 LDA H
 SBC bestLapMinutes,X

 BCS ulap9              \ If the subtraction didn't underflow, then (H U T) is
                        \ bigger than driver X's best lap time, so this isn't a
                        \ new best lap time, so jump to ulap9

                        \ (H U T) is lower than driver X's best lap time, so we
                        \ have a new best lap time

 LDA T                  \ Set driver X's best lap time to (H U T), setting the
 AND #&F0               \ second digit of the tenths figure to 0
 STA bestLapTenths,X
 LDA U
 STA bestLapSeconds,X
 LDA H
 STA bestLapMinutes,X

.ulap9

 LDA clockTenths        \ Set the total race time for driver X to the clock time
 STA totalRaceTenths,X  \ so we can use it to work out the lap time for the next
 LDA clockSeconds       \ lap
 STA totalRaceSeconds,X
 LDA clockMinutes
 STA totalRaceMinutes,X

 CLD                    \ Clear the D flag to switch arithmetic to normal

 RTS                    \ Return from the subroutine

 NOP                    \ These instructions have no effect - presumably they
 NOP                    \ are left over from changes during development

\ ******************************************************************************
\
\       Name: ZeroTimer
\       Type: Subroutine
\   Category: Drivers
\    Summary: Zero the specified timer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The timer to set to zero:
\
\                         * 0 = the clock timer
\                               (clockMinutes clockSeconds clockTenths)
\
\                         * 1 = the lap timer
\                               (lapMinutes lapSeconds lapTenths)
\
\ Returns:
\
\   A                   A = 0 and the Z flag is set (so a BEQ will branch)
\
\ ******************************************************************************

.ZeroTimer

 LDA #0                 \ Zero clockTenths or lapTenths
 STA clockTenths,X

 STA clockSeconds,X     \ Zero clockSeconds or lapSeconds

 STA clockMinutes,X     \ Zero clockMinutes or lapMinutes

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintBestLapTime
\       Type: Subroutine
\   Category: Text
\    Summary: Print the best lap time and the current lap time at the top of the
\             screen
\
\ ******************************************************************************

.PrintBestLapTime

 LDX #32                \ Move the cursor to character column 32 (to just after
 STX xCursor            \ "Best time" in token 40)

 INX                    \ Move the cursor to pixel row 33 (i.e. the second text
 STX yCursor            \ line at the top of the screen)

 LDX currentPlayer      \ Set X to the driver number of the current player, so
                        \ the call to PrintTimer prints the lap time for the
                        \ current driver

 LDA #%00100110         \ Print the best lap time for driver X in the following
 JSR PrintTimer         \ format:
                        \
                        \   * %00 Minutes: No leading zeroes, print both digits
                        \   * %10 Seconds: Leading zeroes, print both digits
                        \   * %0  Tenths: Print tenths of a second
                        \   * %11 Tenths: Leading zeroes, no second digit

                        \ Fall through into PrintLapTime to print the current
                        \ lap time at the top of the screen

\ ******************************************************************************
\
\       Name: PrintLapTime
\       Type: Subroutine
\   Category: Text
\    Summary: Print the current lap time at the top of the screen
\
\ ------------------------------------------------------------------------------
\
\ This routine prints the current lap time in the header at the top of the
\ screen in the following format:
\
\   * Minutes: No leading zeroes, print both digits
\   * Seconds: Leading zeroes, print both digits
\   * Tenths: Do not print tenths of a second
\
\ Other entry points:
\
\   PrintLapTime+2      Format the lap time using the format value in A (see
\                       PrintTimer for details)
\
\ ******************************************************************************

.PrintLapTime

 LDA #%00101000         \ Set A so the current lap time is printed in the
                        \ following format by the call to PrintTimer:
                        \
                        \   * %00 Minutes: No leading zeroes, print both digits
                        \   * %10 Seconds: Leading zeroes, print both digits
                        \   * %1  Tenths: Do not print tenths of a second

 LDX #10                \ Move the cursor to character column 10 (to just after
 STX xCursor            \ "Lap time" in token 40)

 LDX #33                \ Move the cursor to pixel row 33 (i.e. the second text
 STX yCursor            \ line at the top of the screen)

 LDX #21                \ Print (lapMinutes lapSeconds lapTenths) in the format
 JSR PrintTimer         \ given in A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetADCChannel
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Read the value of an ADC channel (used to read the joystick)
\
\ ------------------------------------------------------------------------------
\
\ This routine reads a joystick axis and returns a value with 0 representing the
\ stick being at the centre point, and -127 and +127 representing the left/right
\ or up/down values.
\
\ Arguments:
\
\   X                   The ADC channel to read:
\
\                         * 1 = joystick X
\
\                         * 2 = joystick Y
\
\ Returns:
\
\   A                   The high byte of the channel value, converted to an
\                       absolute figure in the range 0 to 127
\
\   X                   The sign of the result:
\
\                         * 0 = positive, i.e. right or down
\
\                         * 1 = negative, i.e. left or up
\
\   C flag              Clear if A < 10
\
\ ******************************************************************************

.GetADCChannel

 LDA #128               \ Call OSBYTE with A = 128 to fetch the 16-bit value
 JSR OSBYTE             \ from ADC channel X, returning (Y X), i.e. the high
                        \ byte in Y and the low byte in X

 TYA                    \ Copy Y to A, so A contains the high byte of the
                        \ channel value

                        \ The channel value in A will be in the range 0 to 255,
                        \ with 128 representing the stick being in the centre,
                        \ so now we need to flip this around into the range 0 to
                        \ 127, with the sign given in X

 LDX #1                 \ Set X = 1, to denote a negative result (left or down),
                        \ which we will change below if this is a positive
                        \ result

 CLC                    \ Set A = A + 128, so in terms of 8-bit numbers, this
 ADC #128               \ does the following:
                        \
                        \   * 0-127 goes to 128-255
                        \
                        \   * 128-255 goes to 256-383, i.e. 0-127
                        \
                        \ So A is now in the range 128 to 255 for low readings
                        \ from the ADC (right or down), or 0 to 127 for high
                        \ readings (left or up)

 BPL adcc1              \ If A is in the range 0 to 127, skip the following two
                        \ instructions as the result is already in the correct
                        \ range, 0 to 127, and X is set to 1 for left or up

 EOR #&FF               \ Flip the value of A, so the range 128 to 255 flips to
                        \ the range 127 to 0

 DEX                    \ Set X = 0 to denote a positive result, right or down

.adcc1

 CMP #10                \ Clear the C flag if A < 10

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ProcessTime
\       Type: Subroutine
\   Category: Main loop
\    Summary: Increment the timers and the main loop counter
\
\ ******************************************************************************

.ProcessTime

                        \ First, we update the timerAdjust counter, which
                        \ iterates from trackTimerAdjust down to zero and back
                        \ round again, but only if trackTimerAdjust <> 255
                        \
                        \ The timerAdjust counter is used to control the speed
                        \ of the timers in the AddTimeToTimer routine

 LDX timerAdjust        \ If timerAdjust <> 0, jump to tick1 to decrement the
 BNE tick1              \ counter in timerAdjust, as it hasn't wrapped round yet

                        \ If we get here then timerAdjust = 0, so we need to
                        \ wrap round to trackTimerAdjust again

 LDX trackTimerAdjust   \ Set X = trackTimerAdjust + 1
 INX                    \
                        \ We add the 1 so we can decrement it back to
                        \ trackTimerAdjust below (assuming timer adjustments are
                        \ enabled)

 BEQ tick2              \ If X = 0, then trackTimerAdjust must be 255, in which
                        \ case timer adjustments are disabled, so jump to tick2
                        \ to leave timerAdjust alone

.tick1

 DEX                    \ Set timerAdjust = X - 1
 STX timerAdjust        \
                        \ So the clock adjustment counter decrements on each
                        \ iteration round the main loop

.tick2

 LDA raceStarting       \ If bit 7 of raceStarting is set, then the race is in
 BMI tick3              \ the process of starting but hasn't started yet, so
                        \ jump to tick3 to leave the clock timer alone

 LDX #0                 \ Increment the clock timer
 JSR AddTimeToTimer

.tick3

 INC mainLoopCounterLo  \ Increment the main loop counter in (mainLoopCounterHi
                        \ mainLoopCounterLo), starting with the low byte

 BNE tick4              \ And then the high byte, if the low byte overflowed
 INC mainLoopCounterHi

.tick4

 LDA clockSeconds       \ If clockSeconds = 0, skip the following
 BEQ tick5

 LDA mainLoopCounterLo  \ If mainLoopCounterLo mod 32 <> 0, which will be true
 AND #31                \ for 31 out of 32 iterations round the main loop, jump
 BNE tick6              \ to tick6 to return from the subroutine

.tick5

                        \ We only get here when mainLoopCounterLo mod 31 = 0,
                        \ which is once every 32 iterations of the main driving
                        \ loop

 JSR SetDriverSpeed     \ Set the speed for the driver number specified in
                        \ setSpeedForDriver, and increment setSpeedForDriver so
                        \ the next time we get here (in 32 iterations of the
                        \ main loop) we set the speed for the next driver

.tick6

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetPositionAhead
\       Type: Subroutine
\   Category: Drivers
\    Summary: Decrement X to the previous position number (from 19 to 0 and
\             round again), which gives the position ahead of X
\
\ ******************************************************************************

.GetPositionAhead

 DEX                    \ Decrement X

 BPL prev1              \ If X is >= 0, jump to prev1 to skip the following
                        \ instruction

 LDX #19                \ Set X = 19, so repeated calls to this routine will
                        \ decrement X down to 0, and then start again at 19

.prev1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetPositionBehind
\       Type: Subroutine
\   Category: Drivers
\    Summary: Increment X to the next position number (from 0 to 19 and round
\             again), which gives the position behind X
\
\ ******************************************************************************

.GetPositionBehind

 INX                    \ Increment X

 CPX #20                \ If X < 20, jump to getb1 to skip the following
 BCC getb1              \ instruction

 LDX #0                 \ Set X = 0, so repeated calls to this routine will
                        \ increment X up to 19, and then start again at 0

.getb1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintCharacter
\       Type: Subroutine
\   Category: Text
\    Summary: Print a character on-screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Character number (ASCII code, 0 to 159)
\
\   printMode           Bit 7 determines how the character is printed on-screen:
\
\                         * 0 = poke the character directly into screen memory
\                               (for the custom screen mode)
\
\                         * 1 = print the character with OSWRCH (for mode 7)
\
\   (xCursor, yCursor)  For the custom screen only, this is the coordinate where
\                       we should print the character, where xCursor is the
\                       character column and yCursor is the pixel row of the
\                       bottom of the character
\
\ Returns:
\
\   A                   A is unchanged
\
\ Other entry points:
\
\   PrintCharacter-6    Print double-width character (this is used to print the
\                       double-width number on the gear stick)
\
\                       The routine must be called twice to print double-width
\                       characters, which are drawn as follows:
\
\                         * Bit 7 of W is set = draw the right half
\
\                         * Bit 7 of W is clear = draw the left half
\
\                       W must be non-zero when the routine is called on this
\                       entry point, otherwise the routine will print characters
\                       at the normal width
\
\ ******************************************************************************

 STA characterDef       \ Store the character number in characterDef

 JMP char1              \ Jump to char1 to skip the printMode check and use the
                        \ current value of W

.PrintCharacter

 BIT printMode          \ If bit 7 of printMode is set, jump to char8 to print
 BMI char8              \ the character in A with OSWRCH

 STA characterDef       \ Store the character number in characterDef

 LDA #0                 \ Set W = 0 to indicate we should print a single-width
 STA W                  \ character

.char1

 TXA                    \ Store X and Y on the stack so we can retrieve them
 PHA                    \ after we have printed the character
 TYA
 PHA

 LDY #HI(characterDef)  \ Call OSWORD with A = 10 and (Y X) = characterDef,
 LDX #LO(characterDef)  \ which puts the character definition for the specified
 LDA #10                \ character into characterDef+1 to characterDef+8
 JSR OSWORD

 LDA W                  \ If W = 0, jump to char5 to skip the following
 BEQ char5

                        \ If we get here, then W is non-zero, so we now update
                        \ the character definition to contain just one half of
                        \ the character in the left half of the character
                        \ definition, as follows:
                        \
                        \   * If bit 7 of W is set, put the right half of the
                        \     character into left half of the character
                        \     definition
                        \
                        \   * If bit 7 of W is clear, put the left half of the
                        \     character into left half of the character
                        \     definition

 LDX #8                 \ We are now going to work our way through each pixel
                        \ row of the character definition, so set X as a loop
                        \ counter for each byte in the character definition

.char2

 LDA characterDef,X     \ Set A to the bitmap for the X-th row of the character
                        \ definition

 BIT W                  \ If bit 7 of W is set, jump to char3 to skip the next
 BMI char3              \ two instructions

 AND #%11110000         \ Clear the four pixels in the right half of the pixel
 JMP char4              \ row

.char3

 ASL A                  \ Shift A to the left so the right half of the pixel
 ASL A                  \ row moves to the left half
 ASL A
 ASL A

.char4

 STA characterDef,X     \ Store the updated pixel row byte in the X-th row of
                        \ the character definition

 DEX                    \ Decrement the row counter

 BNE char2              \ Loop back until we have processed all eight rows in
                        \ the character definition

.char5

 LDY yCursor            \ Set (Q P) to the screen address of the character block
 LDA xCursor            \ containing character column xCursor and pixel row
 JSR GetScreenAddress-2 \ yCursor, and set Y to the pixel row number within that
                        \ block
                        \
                        \ As yCursor is the pixel row of the bottom of where we
                        \ should print the character, (Q P) now points to the
                        \ address where the bottom pixel row of the character
                        \ should go

 LDX #8                 \ We are now going to work our way through each pixel
                        \ row of the character definition, poking each row to
                        \ screen memory, from the bottom row of the character
                        \ to the top, so set a counter in X for eight rows

.char6

 LDA characterDef,X     \ Store the X-th row of the character definition in the
 STA (P),Y              \ Y-th byte of (Q P)

 DEY                    \ Decrement the pixel row number to point to the row
                        \ above

 BPL char7              \ If Y is positive then we are still within the
                        \ character block, so jump to char7

 LDA P                  \ Otherwise we need to move to the bottom pixel row of
 SEC                    \ the character row above, so set:
 SBC #&40               \
 STA P                  \   (Q P) = (Q P) - &140
                        \
                        \ starting with the high bytes

 LDA Q                  \ And then the low bytes, so (Q P) contains the screen
 SBC #1                 \ address of the character block above (as each
 STA Q                  \ character row contains &140 bytes)

 LDY #7                 \ Set Y = 7 to point to the bottom pixel row in the new
                        \ character block

.char7

 DEX                    \ Decrement the character pixel row counter

 BNE char6              \ Loop back to poke the next row into screen memory
                        \ until we have poked all eight rows

 INC xCursor            \ Move the cursor to the right by one character, as we
                        \ have just printed a full character

 PLA                    \ Retrieve X and Y from the stack
 TAY
 PLA
 TAX

 LDA characterDef       \ Set A to the character number, so A is unchanged by
                        \ the routine

 RTS                    \ Return from the subroutine

.char8

 JSR OSWRCH             \ Print the character in A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetScreenAddress
\       Type: Subroutine
\   Category: Graphics
\    Summary: Return the screen address for a specified screen coordinate
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The screen x-coordinate in pixels (0 to 159)
\
\   Y                   The screen y-coordinate in pixels
\
\ Returns:
\
\   (Q P)               The address of the character block containing the screen
\                       coordinates
\
\   Y                   The pixel row within the character block containing the
\                       screen coordinates
\
\ Other entry points:
\
\   GetScreenAddress-2  Treat the x-coordinate as a character column number
\                       rather than a pixel coordinate (0 to 39)
\
\ ******************************************************************************

 ASL A                  \ Set A = A << 2
 ASL A                  \       = x-coord << 2
                        \
                        \ so in the following, (Q P) gets set to x-coord << 3,
                        \ or x-coord * 8, which gives us the correct byte number
                        \ for this coordinate on the character row, as each
                        \ character block contains eight bytes

.GetScreenAddress

 STA P                  \ Set (Q P) = A << 1
 LDA #0                 \           = x-coord << 1
 ASL P                  \           = x-coord * 2
 ROL A                  \
 STA Q                  \ so (Q P) contains the correct byte number for this
                        \ coordinate as an offset from the start address of the
                        \ character row, as each character row contains 320
                        \ bytes, and the x-coordinate in A is in the range 0 to
                        \ 160 (i.e. each character block is two pixels wide)

 TYA                    \ Set X = Y
 LSR A                  \       = y-coord >> 3
 LSR A                  \
 LSR A                  \ so X is the character row number for this coordinate
 TAX

                        \ The X-th entry in the (yLookupHi yLookupLo) table
                        \ contains the screen address of the start of character
                        \ row X in the custom screen, so we now add this to
                        \ (Q P) to get the screen address of the correct
                        \ character block on this row

 LDA yLookupLo,X        \ Set (Q P) = (Q P) + X-th yLookup entry
 CLC                    \
 ADC P                  \ starting with the low bytes
 STA P

 LDA yLookupHi,X        \ And then the high bytes
 ADC Q
 STA Q

 TYA                    \ Set Y = Y mod 8, to set it to the pixel row within the
 AND #7                 \ character block for the coordinate
 TAY

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: EraseRevCounter
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Erase a line by replacing each pixel in the line with its original
\             contents
\
\ ******************************************************************************

.EraseRevCounter

 LDX lineBufferSize     \ Set X to the size of the line buffer

 BEQ erev2              \ If the line buffer is empty, jump to erev2 to return
                        \ from the subroutine, as there is no line to erase

 DEX                    \ Decrement X so that it can work as a buffer counter
                        \ working through buffer entries X down to 0

.erev1

 LDA lineBufferAddrLo,X \ Set (Q P) to the screen address of the X-th pixel in
 STA P                  \ the line buffer
 LDA lineBufferAddrHi,X
 STA Q

 LDA lineBufferPixel,X  \ Set A to the original screen contents of the X-th in
                        \ the line buffer

 LDY #0                 \ Restore the pixel to its original screen content, i.e.
 STA (P),Y              \ the pixel that was there before we drew a line over
                        \ the top of it

 DEX                    \ Decrement the buffer counter

 BPL erev1              \ Loop back until we have restored all the pixels in the
                        \ line buffer

 STY lineBufferSize     \ Set lineBufferSize = 0, to reset the line buffer

.erev2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UpdateDashboard
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the rev counter and steering wheel lines on the dashboard
\
\ ******************************************************************************

.UpdateDashboard

 JSR EraseRevCounter    \ Erase the dial hand on the rev counter and the line on
                        \ the steering wheel

 JSR DrawRevCounter     \ Redraw the dial hand on the rev counter

                        \ We now draw the line on the steering wheel

 LDA steeringLo         \ Set T = steeringLo
 STA T

 LSR A                  \ Set the C flag to bit 0 of steeringLo (the sign bit)
                        \ which is set if we are steering left, or clear if we
                        \ are steering right

 PHP                    \ Store the C flag on the stack

 LDA #2                 \ Set A = 2, to use as the value of V to send to the
                        \ DrawDashboardLine routine (shallow slope, right and
                        \ down)

 BCS upda1              \ If bit 0 of steeringLo is set, skip the following
                        \ instruction

 LDA #5                 \ Bit 0 of steeringLo is clear, so set A = 5 to use
                        \ as the value of V to send to the DrawDashboardLine
                        \ routine (shallow slope, left and down)

.upda1

 STA V                  \ Set V = A, which we will pass to the DrawDashboardLine
                        \ routine

 LDA steeringHi         \ Set A = steeringHi, so (A T) = (steeringHi steeringLo)

 ASL T                  \ Set (A T) = (A T) << 1
 ROL A                  \
                        \ setting the C flag to the top bit of (A T)

 BCS upda2              \ If the C flag is set, skip the following four
                        \ instructions to set A = 60, as the wheel is turned so
                        \ much that the indicator would be off the bottom of the
                        \ screen

 CMP #38                \ If A < 38, jump to upda4
 BCC upda4

 CMP #61                \ If A < 61, i.e. 38 <= A <= 60, jump to upda3 to
 BCC upda3              \ skip the following instruction

.upda2

 LDA #60                \ Set A = 60, the maximum value of A, so when we fall
                        \ through into the next calculation, with the C flag
                        \ set, we set:
                        \
                        \   Y = ~A + 76 + C
                        \     = ~A + 76 + 1
                        \     = ~A + 1 + 76
                        \     = -A + 76
                        \     = -60 + 76
                        \     = 16

.upda3

                        \ If we get here then the indicator is a long way away
                        \ from the centre of the wheel, as A >= 38

 EOR #&FF               \ Set Y = ~A + 76 + C
 ADC #76                \       = ~A + 1 + 75 + C
 TAY                    \       = 75 - A        when 38 <= A <= 60
                        \         16            when A > 60
                        \
                        \ so Y is in the range 37 to 16, with higher values of A
                        \ giving lower values of A
                        \
                        \ This represents the distance between this value on the
                        \ steering wheel and the nearest quadrant

 STY T                  \ Set T = Y (in the range 37 to 16) to pass to the
                        \ DrawDashboardLine routine as the amount of slope error
                        \ for each step slong the main axis

 LDX wheelPixels,Y      \ Set X to the number of pixels that would be along the
                        \ long axis of the line if the line went all the way to
                        \ the centre of the wheel, given the value of Y above

 STX SS                 \ Set SS = X to pass to the DrawDashboardLine routine
                        \ as the cumulative amount of slope error that equates
                        \ to a pixel in the shorter axis

 JMP upda5              \ Jump to upda5

.upda4

                        \ If we get here then the indicator is not far away from
                        \ the centre of the wheel, as A < 38

 TAX                    \ Set X = A (in the range 0 to 37)
                        \
                        \ This represents the distance between this value on the
                        \ steering wheel and the nearest quadrant

 STX T                  \ Set T = X (in the range 0 to 37) to pass to the
                        \ DrawDashboardLine routine as the amount of slope error
                        \ for each step slong the main axis

 LDA V                  \ Flip bit 0 of V, to flip it from the first half of the
 EOR #1                 \ quadrant to the second half
 STA V

                        \ By this point, V has the following value, which we
                        \ pass to the DrawDashboardLine routine
                        \
                        \   * 2 when sign bit of steeringLo is set and A >= 38
                        \     i.e. steering left a lot
                        \     Shallow slope, right and down
                        \
                        \   * 3 when sign bit of steeringLo is set and A < 38
                        \     i.e. steering left a little
                        \     Steep slope, right and down
                        \
                        \   * 4 when sign bit of steeringLo is clear and A < 38
                        \     i.e. steering right a little
                        \     Steep slope, left and down
                        \
                        \   * 5 when sign bit of steeringLo is clear and A >= 38
                        \     i.e. steering right a lot
                        \     Shallow slope, left and down
                        \
                        \ These are the opposite way round to the rev counter
                        \ hand, which is also drawn by the DrawDashboardLine
                        \ routine - this is because the rev counter hand is
                        \ drawn from the centre outwards, while the steering
                        \ wheel line is drawn from the outside in

 LDA wheelPixels,X      \ Set A to the number of pixels that would be along the
                        \ long axis of the line if the line went all the way to
                        \ the centre of the wheel, given the value of Y above

 STA SS                 \ Set SS = A to pass to the DrawDashboardLine routine
                        \ as the cumulative amount of slope error that equates
                        \ to a pixel in the shorter axis

.upda5

 ASL A                  \ Set A = A * 2 + 4
 CLC
 ADC #4

 EOR #&FF               \ Set Y = ~A
 TAY

 TXA                    \ Set A = X
                        \
                        \ where X is either the original value of A (0 to 37)
                        \ or the Y-th value of wheelPixels (where Y is 16 to
                        \ 37), which is in the range 38 to 51
                        \
                        \ In effect, this is the horizontal distance of the
                        \ steering line from the centre point

 PLP                    \ Set the C flag to bit 0 of steeringLo (the sign bit),
                        \ which we stored on the stack above

 BCC upda6              \ If bit 0 of steeringLo is clear, we are steering to
                        \ the right, so skip the following instruction

 EOR #&FF               \ Set A = ~A
                        \       = -A - 1
                        \
                        \ so the following addition becomes:
                        \
                        \   A = A + 80
                        \     = -A - 1 + 80
                        \     = 79 - A

.upda6

 CLC                    \ Set A = A + 80
 ADC #80                \
                        \ which turns A into the position on the steering wheel
                        \ where 80 is the centre point at the top middle of the
                        \ wheel

 STA W                  \ Set W = A, so W contains the position on the steering
                        \ wheel

 AND #%11111100         \ Clear bits 0 and 1 of A, to set A = A div 4

 JSR GetScreenAddress   \ Set (Q P) to the screen address for pixel coordinate
                        \ (A, Y), setting Y to the pixel row within the
                        \ character block containing the pixel (both of which we
                        \ pass to the DrawDashboardLine routine)

 LDA W                  \ Set W = W * 2 mod 8
 ASL A                  \
 AND #%00000111         \ This takes the x-coordinate of the line on the
 STA W                  \ steering wheel, doubled so we have 160 in the centre
                        \ of the steering wheel (so it matches the coordinates
                        \ in mode 5), and then we look at bits 0 to 2 only to
                        \ get the starting pixel to pass to DrawDashboardLine

 LDA #%100              \ Set H = %100, so the DrawDashboardLine looks up values
 STA H                  \ from the second half of the pixelByte and yLookupLo+8
                        \ tables (so the line is drawn on black rather than
                        \ white)

 LDA #6                 \ Set U = 6, so the line contains up to seven pixels
 STA U

 JSR DrawDashboardLine  \ Draw the dashboard line

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawRevCounter
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Draw the hand on the rev counter
\
\ ******************************************************************************

.DrawRevCounter

 LDA #%000              \ Set H = %000 to pass into DrawDashboardLine below
 STA H

 LDA revCount           \ Set A = revCount, which is the value we want to draw
                        \ on the rev counter, in the range 0 to 170

 CMP #30                \ If A >= 30, skip the following instruction
 BCS revs1

 LDA #30                \ Set A = 30, so A is always at least 30, and is now in
                        \ the range 30 to 170 (we do this because the hand on
                        \ the rev counter doesn't fall all the way back to zero)

.revs1

 STA T                  \ Set T = A

 LSR A                  \ Set A = A / 2 + T
 CLC                    \       = A / 2 + A
 ADC T                  \       = 1.5 * A
                        \       = 1.5 * revCount
                        \
                        \ which is in the range 45 to 255

 ROR A                  \ Set A = A / 2
                        \       = 0.75 * revCount
                        \
                        \ which is in the range 22 to 127

                        \ We now convert the value in A to the corresponding
                        \ position on the dial in terms of which quadrant it's
                        \ in, and which half of that quadrant, so we can pass
                        \ the details to the DrawDashboardLine routine

 SEC                    \ Set A = A - 76
 SBC #76

 BCS revs2              \ If the subtraction went past zero, add 152, to get:
 ADC #152               \
                        \   A = A + 76

                        \ So for A in the range 22 to 127, this converts:
                        \
                        \   A = 22-75  into A = 98-151
                        \   A = 76-127 into A = 0-51
                        \
                        \ If we consider a clock with 0 at 12 o'clock, then 38
                        \ at 3 o'clock, 76 at 6 o'clock and 114 at 9 o'clock,
                        \ A is now the position of the hand on that clock, i.e.
                        \ the position of the hand that we want to draw on the
                        \ rev counter

.revs2

                        \ We now calculate the quadrant that contains the hand
                        \ on the rev counter, numbered 0 to 3 counting clockwise
                        \ from top-right
                        \
                        \ We do this by calculating X = A / 38, by repeatedly
                        \ subtracting 38 from A until we go past zero

 LDX #&FF               \ We start by setting X = -1

 SEC                    \ Set the C flag for the subtraction

.revs3

 INX                    \ Increment X as we are doing a subtraction

 SBC #38                \ Set A = A - 38

 BCS revs3              \ If the subtraction didn't take us past zero, loop back
                        \ to subtract another 38

 ADC #38                \ Otherwise add the 38 back that pushed us over the
                        \ limit, so X now contains the quadrant number, and A
                        \ contains the remainder (i.e. the fraction that the
                        \ hand is past the start of the quadrant)

 CMP #19                \ If the remainder is < 19, skip the following, as A
 BCC revs4              \ contains the distance from the start of quadrant X to
                        \ the position of the hand (and the C flag is clear)

 SBC #19                \ Set A = ~(A - 19) + 20
 EOR #&FF               \       = ~(A - 19) + 1 + 19
 CLC                    \       = -(A - 19) + 19
 ADC #20                \       = 19 - (A - 19)
                        \
                        \ so A now contains the distance from the hand to the
                        \ end of quadrant X

 SEC                    \ Set the C flag to indicate that A is now the distance
                        \ from the hand to the end of the quadrant

.revs4

                        \ By this point:
                        \
                        \   X = quadrant number (0 to 3)
                        \
                        \   A = distance from start of quadrant to hand (C = 0)
                        \       distance from hand to end of quadrant   (C = 1)
                        \
                        \ where each quadrant is 38 in size, so A is <= 19
                        \
                        \ The C flag therefore represents which half of the
                        \ quadrant the hand is in, 0 denoting the first half and
                        \ 1 denoting the second half

 TAY                    \ Set Y = the distance between the hand and quadrant

 STY T                  \ Set T = the distance between the hand and quadrant

 TXA                    \ Ensure X is in the range 0 to 3 (it should be, but
 AND #3                 \ this makes absolutely sure)
 TAX

 TXA                    \ This sets bits 1 and 2 of V to the quadrant number,
 ROL A                  \ and bit 0 to the C flag, so the possible values are:
 STA V                  \
                        \   * 0 = %000 = Quadrant 0, first half, 12:00 to 1:30
                        \   * 1 = %001 = Quadrant 0, second half, 1:30 to 3:00
                        \   * 2 = %010 = Quadrant 1, first half, 3:00 to 4:30
                        \   * 3 = %011 = Quadrant 1, second half, 4:30 to 6:00
                        \   * 4 = %100 = Quadrant 2, first half, 6:00 to 7:30
                        \   * 5 = %101 = Quadrant 2, second half, 7:30 to 9:00
                        \   * 6 = %110 = Quadrant 3, first half, 9:00 to 10:30
                        \   * 7 = %111 = Quadrant 3, second half, 10:30 to 12:00
                        \
                        \ These are the quadrant values we need to pass to the
                        \ DrawDashboardLine routine below

 AND #%11111100         \ If bit 2 of A is zero, then the hand is in the right
 BEQ revs5              \ half of the dial, so jump to revs5 to set W = 0

 LDA #7                 \ Otherwise the hand is in the left half of the dial,
                        \ so set A so we set W = 7 below

.revs5

 STA W                  \ Set W = 0 if the hand is in the right half
                        \         7 if the hand is in the left half
                        \
                        \ so we start drawing from the leftmost pixel when
                        \ drawing to the right, or the rightmost pixel when
                        \ drawing to the left (which ensures that the hand joins
                        \ the centre spoke of the rev counter without a gap)

 LDA handPixels,Y       \ Set A to the number of pixels that are along the long
                        \ axis of the hand, given the distance between the hand
                        \ and quadrant that we set in Y above

 STA SS                 \ Set SS to the number of pixels along the long axis

 STA U                  \ Set U to the number of pixels along the long axis, to
                        \ pass through to the DrawDashboardLine routine below

 LDA startDialLo,X      \ Set the low byte of (Q P) to the low byte of the
 AND #%11111000         \ screen address for the starting point of the hand for
 STA P                  \ quadrant Y, which we get from the startDialLo table,
                        \ and clear bits 0 to 2 so the address points to the
                        \ top line of the relevant character block

 LDA startDialLo,X      \ Set Y to the pixel row within the character block
 AND #%00000111         \ for the starting point, which we get from bits 0 to 2
 TAY                    \ of the starting point's screen address

 LDA startDialHi,X      \ Set the high byte of (Q P) to the high byte of the
 STA Q                  \ screen address for the starting point of the hand for
                        \ quadrant Y, so (Q P) now contains the full address of
                        \ the starting point's character block

                        \ Fall through into DrawDashboardLine to draw a line
                        \ from the starting point given in (Q P) and Y, in the
                        \ direction given in V, with U pixels along the longest
                        \ axis, and in the half of the dial given in W

\ ******************************************************************************
\
\       Name: DrawDashboardLine
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Draw a hand on the rev counter or a line on the steering wheel
\
\ ------------------------------------------------------------------------------
\
\ This routine is a mode 5 Bresenham line-drawing routine, which modifies itself
\ to cater for lines of different slopes.
\
\ Arguments:
\
\   V                   The slope of the line to draw, which is expressed as a
\                       quadrant number, where quadrant 0 is from 12 o'clock to
\                       3 o'clock, with quadrants ordered 0 to 3 in a clockwise
\                       order:
\
\                         * 0 = %000 = Quadrant 0, first half (12:00 to 1:30)
\                                      Steep slope, right and up
\                                      Step up along y-axis (stepAxis = DEY)
\                                      Move right along x-axis (shortAxis = INX)
\
\                         * 1 = %001 = Quadrant 0, second half (1:30 to 3:00)
\                                      Shallow slope, right and up
\                                      Step right along x-axis (stepAxis = INX)
\                                      Move up along y-axis (shortAxis = DEY)
\
\                         * 2 = %010 = Quadrant 1, first half (3:00 to 4:30)
\                                      Shallow slope, right and down
\                                      Step right along x-axis (stepAxis = INX)
\                                      Move down along y-axis (shortAxis = INY)
\
\                         * 3 = %011 = Quadrant 1, second half (4:30 to 6:00)
\                                      Steep slope, right and down
\                                      Step down along y-axis (stepAxis = INY)
\                                      Move right along x-axis (shortAxis = INX)
\
\                         * 4 = %100 = Quadrant 2, first half (6:00 to 7:30)
\                                      Steep slope, left and down
\                                      Step down along y-axis (stepAxis = INY)
\                                      Move left along x-axis (shortAxis = DEX)
\
\                         * 5 = %101 = Quadrant 2, second half (7:30 to 9:00)
\                                      Shallow slope, left and down
\                                      Step left along x-axis (stepAxis = DEX)
\                                      Move down along y-axis (shortAxis = INY)
\
\                         * 6 = %110 = Quadrant 3, first half (9:00 to 10:30)
\                                      Shallow slope, left and up
\                                      Step left along x-axis (stepAxis = DEX)
\                                      Move up along y-axis (shortAxis = DEY)
\
\                         * 7 = %111 = Quadrant 3, second half (10:30 to 12:00)
\                                      Steep slope, left and up
\                                      Step up along y-axis (stepAxis = DEY)
\                                      Move left along x-axis (shortAxis = DEX)
\
\   (Q P)               The screen address of the character block containing
\                       the line's starting point
\
\   Y                   The pixel row within the character block containing the
\                       line's starting point (0 to 7)
\
\   U                   The number of pixels to step along the step axis:
\
\                         * The number of pixels along the longer (step) axis
\                           when drawing the rev counter
\
\                         * 6 when drawing the steering wheel line
\
\   T                   The slope error for each step along the step axis is
\                       T/SS, and T is set to:
\
\                         * The distance between the hand and quadrant when
\                           drawing the rev counter hand
\
\                         * When drawing the steering wheel line:
\
\                           0-37 when the line is close to the centre (in the
\                           top two quadrants either side of the centre)
\
\                           37-16 when line is further from the centre (in the
\                           left and right quadrants)
\
\   SS                  The slope error for each step along the step axis is
\                       T/SS, and SS is set to:
\
\                         * The same as U when drawing the rev counter hand
\                           i.e. the number of pixels along the longer (step)
\                           axis
\
\                         * A value from wheelPixels when drawing the steering
\                           wheel line (38 to 53)
\
\   H                   The starting index to use in the pixelByte and
\                       yLookupLo+8 lookup tables:
\
\                         * %000 when drawing the rev counter hand, so the line
\                           gets drawn in white
\
\                         * %100 when drawing the steering wheel line, so the
\                           line gets drawn in black
\
\   W                   The pixel number (0-7) of the first pixel to draw
\                       along the x-axis
\
\ ******************************************************************************

.DrawDashboardLine

 LDX V                  \ Modify the instruction at dlin2 to the V-th shortAxis
 LDA shortAxis,X        \ instruction
 STA dlin2

 LDA stepAxis,X         \ Modify the instruction at dlin8 to the V-th stepAxis
 STA dlin8              \ instruction

                        \ The following code has the instructions for V = %010,
                        \ which has INY at dlin2 for the short axis, and INX at
                        \ dlin8 for the step axis, so that's this kind of line:
                        \
                        \   * Quadrant 1, first half (3:00 to 4:30)
                        \   * Shallow slope, right and down
                        \   * Step right along x-axis (stepAxis = INX)
                        \   * Move down along y-axis (shortAxis = INY)

 LDX W                  \ Set X = W, so X contains the position of the current
                        \ pixel within the pixel row, if there were eight pixels
                        \ per row

 LDA #0                 \ Set A = -SS
 SEC                    \
 SBC SS                 \ So this is the starting point for our slope error
                        \ calculation

 CLC                    \ Clear the C flag for the following addition

.dlin1

                        \ We use A to keep track of the slope error, adding the
                        \ step along the smaller axis (in T) until it reaches 0,
                        \ at which point it is a multiple of SS and we need
                        \ to move one pixel along the smaller axis

 ADC T                  \ Set A = A + T
                        \
                        \ So A is updated with the slope error

 BCC dlin3              \ If the addition didn't overflow, then the result in A
                        \ is still negative, so skip the following instruction

                        \ The slope error just overflowed (in other words, the
                        \ cumulative slope error in A just reached a multiple of
                        \ SS), so we need to adjust the slope error to make
                        \ it negative again, and we need to step along the
                        \ shorter axis

 SBC SS                 \ Subtract SS from the cumulative slope error to
                        \ bring it back to being negative, so we can detect when
                        \ it reaches next multiple of SS

.dlin2

 INY                    \ Increment Y to move down along the y-axis (i.e. along
                        \ the shorter axis)
                        \
                        \ This instruction is modified at the start of this
                        \ routine, depending on the slope of the line in V

.dlin3

 STA II                 \ Store the updated slope error in II, so we can
                        \ retrieve it below, ready for the next iteration of the
                        \ drawing loop

 TXA                    \ X contains the position of the current pixel within
 LSR A                  \ the pixel row, in the range 0 to 7, so set A to half
 AND #%00000011         \ this value to get the mode 5 pixel number (as there
                        \ are only four pixels per pixel byte on mode 5)

 ORA H                  \ Set bit 2 of A if this is the steering wheel, which
                        \ is the same as adding 4

 STA V                  \ Store the result in V, so V contains the pixel number
                        \ (0 to 3) of the pixel to draw, plus 4 if this is the
                        \ steering wheel (4 to 7)

 TXA                    \ X contains the position of the current pixel within
                        \ the pixel line, so put this in A

 BPL dlin4              \ If bit 7 of A is clear, jump to dlin4

                        \ Otherwise we need to move (Q P) to the previous
                        \ character block to the left, by subtracting 8 (as
                        \ there are 8 bytes per character block)

 LDX #7                 \ Set X = 7 to set as the new value of W below

 LDA P                  \ Set (Q P) = (Q P) - 8
 SEC                    \
 SBC #8                 \ starting with the low bytes
 STA P

 BCS dlin5              \ And then the high bytes
 DEC Q

 BCS dlin5              \ This instruction has no effect, as we already passed
                        \ through the BCS above, which is presumably a bug (this
                        \ should perhaps be a BCC?)

.dlin4

 CMP #8                 \ If A < 8, jump to dlin5
 BCC dlin5

                        \ Otherwise we need to move (Q P) to the next character
                        \ block to the right, by adding 8 (as there are 8 bytes
                        \ per character block)

 LDX #0                 \ Set X = 0 to set as the new value of W below

 LDA P                  \ Set (Q P) = (Q P) + 8
 CLC                    \
 ADC #8                 \ starting with the low bytes
 STA P

 BCC dlin5              \ And then the high bytes
 INC Q

.dlin5

 STX W                  \ Store X in W, so W moves along one pixel to the right

 LDX lineBufferSize     \ Set X to the size of the line buffer, which gives us
                        \ the index of the next empty space in the buffer

 TYA                    \ Y contains the number of the pixel row within the
                        \ current character block, so put this in A

 BPL dlin6              \ If A >=0, jump to dlin6

                        \ Otherwise we need to move (Q P) to the next character
                        \ row above, by subtracting &140 (as there are &140
                        \ bytes per character row)

 LDA P                  \ Set (Q P) = (Q P) - &140
 SEC                    \
 SBC #&40               \ starting with the high bytes
 STA P

 LDA Q                  \ And then the low bytes
 SBC #&01
 STA Q

 LDY #7                 \ Set Y = A = 7 as the new value of Y
 TYA

 BNE dlin7              \ Jump to dlin7 (this BNE is effectively a JMP as A is
                        \ never zero)

.dlin6

 CMP #8                 \ If A < 8, jump to dlin7
 BCC dlin7

                        \ Otherwise we need to move (Q P) to the next character
                        \ row below, by adding &140 (as there are &140 bytes per
                        \ character row)

 LDA P                  \ Set (Q P) = (Q P) + &140
 CLC                    \
 ADC #&40               \ starting with the high bytes
 STA P

 LDA Q                  \ And then the low bytes
 ADC #&01
 STA Q

 LDY #0                 \ Set Y = A = 0 as the new value of Y
 TYA

.dlin7

                        \ We now store the details of the pixel we are about
                        \ to overwrite in the line buffer, which stores a screen
                        \ address plus the original contents of that address
                        \
                        \ We get the screen address by adding the address of the
                        \ character block in P to the number of the pixel row
                        \ within the character in A, which we can do with an ORA
                        \ as P only occupies bits 3 to 7, while A only occupies
                        \ bits 0 to 2

 ORA P                  \ Store the address we are about to overwrite in the
 STA lineBufferAddrLo,X \ next empty space at the end of the line buffer, i.e.
                        \ the X-th byte of (lineBufferAddrHi lineBufferAddrLo),
                        \ starting with the low byte of the address

 LDA Q                  \ And then the high byte of the address
 STA lineBufferAddrHi,X

 LDA (P),Y              \ Store the current pixel contents into the pixel
 STA lineBufferPixel,X  \ contents buffer at lineBufferPixel

 INC lineBufferSize     \ Increment the size of the pixel buffers, as we just
                        \ added an entry

 LDX V                  \ Set X = V, so X now contains the pixel number
                        \ (0 to 3) of the pixel to draw, plus 4 if this is the
                        \ steering wheel (4 to 7)

 AND yLookupLo+8,X      \ Apply the X-th pixel mask from yLookupLo+8, so this
                        \ clears the X-th pixel in the pixel row (the table
                        \ contains the same bytes in 0 to 3 as in 0 to 7)

 ORA pixelByte,X        \ OR with a pixel byte with pixel X set, so this sets
                        \ the X-th pixel to colour 2 (white) if X is 0 to 3, or
                        \ colour 0 (black) if X is 4 to 7 - so the rev counter
                        \ hand is white, while the steering wheel line is black

 STA (P),Y              \ Draw the pixel byte to the screen

                        \ We now set up all the variables so we can loop back
                        \ to dlin1 for the next pixel

 LDX W                  \ Set X = W

 LDA II                 \ Set A to the current slope error, which we stored in
                        \ II above

 CLC                    \ Clear the C flag for the addition at the start of the
                        \ loop

.dlin8

 INX                    \ Increment X to step right along the x-axis (i.e. along
                        \ the longer axis)
                        \
                        \ This instruction is modified at the start of this
                        \ routine, depending on the slope of the line in V

 DEC U                  \ Decrement the pixel counter

 BMI dlin9              \ If we have drawn the correct number of pixels along
                        \ the longer axis, jump to dlin9 to return from the
                        \ subroutine as we have finished drawing the line

 JMP dlin1              \ Otherwise loop back to draw the next pixel

.dlin9

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: AnimateTyres
\       Type: Subroutine
\   Category: Graphics
\    Summary: Update screen memory to animate the tyres
\
\ ******************************************************************************

.AnimateTyres

 INC irqCounter         \ Increment irqCounter, so it gets incremented every
                        \ time the IRQ routine reaches section 4 of the custom
                        \ screen

 LDA speedHi            \ Set tyreTravel = tyreTravel + speedHi + 48
 CLC
 ADC #48
 ADC tyreTravel
 STA tyreTravel

 BCC tyre4              \ If the addition didn't overflow, jump to tyre4 to
                        \ return from the subroutine

 LDA playerMoving       \ If playerMoving = 0 then the player's car is not
 BEQ tyre4              \ moving so we don't need to animate the tyres, so jump
                        \ to tyre4 to return from the subroutine

 LDX #4                 \ Set a loop counter to go from 4 to 0

.tyre1

 LDA tyreLeft3,X        \ Set tyreLeft3 = tyreLeft3 EOR tyreTread1
 EOR tyreTread1,X
 STA tyreLeft3,X

 LDA tyreRight3,X       \ Set tyreRight3 = tyreRight3 EOR tyreTread2
 EOR tyreTread2,X
 STA tyreRight3,X

 CPX #3                 \ If X >= 3, jump to tyre2 to skip the following
 BCS tyre2

 LDA tyreLeft1,X        \ Flip the top four bits of tyreLeft1
 EOR #%11110000
 STA tyreLeft1,X

 LDA tyreRight2,X       \ Flip the top four bits of tyreRight2
 EOR #%11110000
 STA tyreRight2,X

 BNE tyre3              \ If A is non-zero, jump to tyre3 to continue the loop

.tyre2

 LDA tyreLeft2,X        \ Flip bits 6 and 7 of tyreLeft2
 EOR #%11000000
 STA tyreLeft2,X

 LDA tyreRight1,X       \ Flip bits 4 and 5 of tyreRight1
 EOR #%00110000
 STA tyreRight1,X

.tyre3

 DEX                    \ Decrement the loop counter

 BPL tyre1              \ Loop back to animate the next tyre part

.tyre4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: tyreTread1
\       Type: Variable
\   Category: Graphics
\    Summary: Tyre tread pattern
\
\ ******************************************************************************

.tyreTread1

 EQUB &F0, &F0, &C0, &C0, &80

\ ******************************************************************************
\
\       Name: tyreTread2
\       Type: Variable
\   Category: Graphics
\    Summary: Tyre tread pattern
\
\ ******************************************************************************

.tyreTread2

 EQUB &F0, &F0, &30, &30, &10

\ ******************************************************************************
\
\       Name: trackData
\       Type: Variable
\   Category: Track data
\    Summary: This is where the track data gets loaded
\
\ ------------------------------------------------------------------------------
\
\ See the track source in revs-silverstone.asm for details of the track data. It
\ covers trackData and dashData41 - the latter gets moved into screen memory as
\ part of the memory-moving process in the SwapData routine.
\
\ ******************************************************************************

.trackData

.trackSectionData

 SKIP 1

.xTrackSectionIHi

 SKIP 1

.yTrackSectionIHi

 SKIP 1

.zTrackSectionIHi

 SKIP 1

.xTrackSectionOHi

 SKIP 1

.trackSectionTurn

 SKIP 1

.zTrackSectionOHi

 SKIP 1

.trackDriverSpeed

 SKIP 1

 SKIP 8 * 23

 SKIP 16

.xTrackSignVector

 SKIP 16

.zTrackSignVector

 SKIP 16

.yTrackSignVector

 SKIP 16

.xTrackVectorI

 SKIP 256

.yTrackVectorI

 SKIP 256

.zTrackVectorI

 SKIP 256

.xTrackVectorO

 SKIP 256

.zTrackVectorO

 SKIP 256

.trackSectionFlag

 SKIP 1

.xTrackSectionILo

 SKIP 1

.yTrackSectionILo

 SKIP 1

.zTrackSectionILo

 SKIP 1

.xTrackSectionOLo

 SKIP 1

.trackSectionFrom

 SKIP 1

.zTrackSectionOLo

 SKIP 1

.trackSectionSize

 SKIP 1

 SKIP 8 * 23

 SKIP 16

.trackRacingLine

 SKIP 24

 SKIP 2

.trackSignData

 SKIP 16

.trackSectionCount

 SKIP 1

.trackVectorCount

 SKIP 1

.trackLengthLo

 SKIP 1

.trackLengthHi

 SKIP 1

.trackPracticeLo

 SKIP 1

.trackPracticeHi

 SKIP 1

.trackLapTimeSec

 SKIP 3

.trackLapTimeMin

 SKIP 3

.trackGearRatio

 SKIP 7

.trackGearPower

 SKIP 7

.trackBaseSpeed

 SKIP 3

.trackStartPosition

 SKIP 1

.trackCarSpacing

 SKIP 1

.trackTimerAdjust

 SKIP 1

.trackRaceSlowdown

 SKIP 1

 SKIP 7

\ ******************************************************************************
\
\       Name: dashData41
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\  Deep dive: The jigsaw puzzle binary
\
\ ******************************************************************************

CLEAR &594A, &5A22      \ The track data is loaded in a separate file that is
ORG &594A               \ moved to trackData after the game binary has loaded
                        \
                        \ It overwrites part of the dashboard image at that's
                        \ loaded as part of the main game binary at dashdata41,
                        \ which is moved into screen memory before the track
                        \ data is moved
                        \
                        \ These lines rewind BeebAsm's assembly back to
                        \ dashData41 (which is at address &594A), and clear the
                        \ block from that point to CallTrackHook, so we can
                        \ can set the correct address for dashData41 while also
                        \ retaining the addresses we just set up for the track
                        \ data
.dashData41

 SKIP 67

 SKIP 149

\ ******************************************************************************
\
\       Name: CallTrackHook
\       Type: Subroutine
\   Category: Setup
\    Summary: The track file's hook code
\
\ ******************************************************************************

.CallTrackHook

 BRK                    \ The SwapCode routine replaces these three bytes with
 BRK                    \ the three bytes from just before the trackChecksum in
 BRK                    \ the track file, which contain the three bytes of hook
                        \ code for the track
                        \
                        \ In the default Silverstone track that comes with the
                        \ original version of Revs, the three bytes of hook code
                        \ contain the following:
                        \
                        \   RTS
                        \   NOP
                        \   NOP
                        \
                        \ so calling this routine does nothing (see the track
                        \ source in the revs-silverstone.asm file for details)
                        \
                        \ Other track files, such as those in the Revs 4 Tracks
                        \ expansion pack, contain JMP instructions in their hook
                        \ code, which allows the track authors to hook in entire
                        \ routines that get called when those tracks are loaded

\ ******************************************************************************
\
\       Name: AwardRacePoints
\       Type: Subroutine
\   Category: Drivers
\    Summary: Award points following a race
\
\ ------------------------------------------------------------------------------
\
\ This routine awards points to a driver for finishing in the top six in a race,
\ or for getting the fastest lap time. The points awarded are based on the
\ driver's race position, as per the pointsForPlace table:
\
\   * 9 points for first place
\   * 6 points for second place
\   * 4 points for third place
\   * 3 points for fourth place
\   * 2 points for fifth place
\   * 1 point for sixth place
\   * 1 point for the fastest lap
\
\ In single-player races, the points are awarded as above.
\
\ In multi-player races, an algorithm is used to share out the points in a way
\ that takes the relative skills into consideration. Specifically, the routine
\ awards this many points:
\
\   (U T) * the points from the above list
\
\ This is how (U T) is calculated:
\
\ * Single-player race:
\
\   (U T) = numberOfPlayers = 1, so we award the amount of points shown above
\
\ * Multi-player race:
\
\   If we are awarding points to the current player:
\
\       (U T) = (numberOfPlayers - 1) * numberOfPlayers
\
\   If we are awarding points to a human player but not the current player:
\
\       (U T) = numberOfPlayers
\
\   If we are awarding points to a computer driver:
\
\       (U T) = (numberOfPlayers - 1) * 2
\
\ I have no idea why the algorithm works like this. It needs more analysis!
\
\ Arguments:
\
\   X                   The race position to award points to:
\
\                         * 0 to 5 for the first six places
\
\                         * 6 for the fastest lap
\
\ ******************************************************************************

.AwardRacePoints

 LDA #0                 \ Zero the points in (racePointsHi racePointsLo) for
 STA racePointsLo,X     \ race position X
 STA racePointsHi,X

 STA U                  \ Set U = 0, to act as the high byte of (U T)

 LDY driversInOrder,X   \ Set Y to the number of the driver in race position X

 CPX #6                 \ If we called the routine with X = 0 to 5, then jump to
 BNE poin1              \ poin1 to skip the following instruction

 LDY driversInOrder     \ We called the routine with X = 6, so set Y to the
                        \ winning driver's number, i.e. the driver with the
                        \ fastest lap

.poin1

                        \ By this point, Y contains the number of the driver we
                        \ want to give the points to, so now we calculate the
                        \ number of points to award

 LDA numberOfPlayers    \ Set A to the number of players - 1
 SEC
 SBC #1

 BEQ poin3              \ If A = 0 then there is only one player, so jump to
                        \ poin3 to skip the following

 CPY currentPlayer      \ If Y is the number of the current player, jump to
 BEQ poin2              \ poin2

 CPY lowestPlayerNumber \ If Y >= lowestPlayerNumber then this is a human
 BCS poin3              \ player but not the current player, so jump to poin3

                        \ If we get here then we are awarding points to a
                        \ computer-controlled driver

 ASL A                  \ Double the value of A, to use as the value of T, so
                        \ we will get:
                        \
                        \   (U T) = (0 T)
                        \         = T
                        \         = A * 2
                        \         = (numberOfPlayers - 1) * 2

 BNE poin4              \ Jump to poin4 (this BNE is effectively a JMP, as A is
                        \ never zero)

.poin2

                        \ If we get here then we are awarding points to the
                        \ current player

 STA U                  \ Set U = A = numberOfPlayers - 1

 LDA numberOfPlayers    \ Set A = numberOfPlayers

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = (numberOfPlayers - 1) * numberOfPlayers

 STA U                  \ Set (U T) = (A T)
                        \           = (numberOfPlayers - 1) * numberOfPlayers

 JMP poin5              \ Jump to poin5

.poin3

                        \ If we get here then either there is only one player,
                        \ or we are awarding points to a human player but not
                        \ the current player

 LDA numberOfPlayers    \ Set A to the number of players, to use as the value of
                        \ T, so we will get:
                        \
                        \   (U T) = (0 T)
                        \         = (0 numberOfPlayers)
                        \         = numberOfPlayers

 BNE poin4              \ This instruction has no effect as poin4 is the next
                        \ instruction anyway

.poin4

 STA T                  \ Store A in T, so this sets (U T) = (U A)

.poin5

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

                        \ We now do the following addition 256 * U + T times, so
                        \ the total number of points added is:
                        \
                        \   (256 * U + T) * (9, 6, 4, 3, 2 or 1)
                        \
                        \ or putting it another way:
                        \
                        \   (U T) * (9, 6, 4, 3, 2 or 1)

.poin6

 LDA pointsForPlace,X   \ Add the X-th entry in pointsForPlace to the X-th entry
 CLC                    \ in (racePointsHi racePointsLo),  starting with the low
 ADC racePointsLo,X     \ bytes
 STA racePointsLo,X

 LDA racePointsHi,X     \ And then the high bytes
 ADC #0
 STA racePointsHi,X

 DEC T                  \ Decrement the counter in T

 BNE poin6              \ Loop back to poin6 so we do the addition a total of T
                        \ times

 DEC U                  \ Decrement the counter in U

 BPL poin6              \ Loop back to poin6 so we do an additional U loops,
                        \ with the inner loop repeating 256 times as T is now 0,
                        \ so this does a total of 256 * U additional additions

 JSR AddRacePoints      \ Add the race points from above to the accumulated
                        \ points for driver Y

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: var24Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

ORG &5E40

.var24Lo

 SKIP 16

\ ******************************************************************************
\
\       Name: var25Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var25Lo

 SKIP 24

\ ******************************************************************************
\
\       Name: var23Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var23Lo

 SKIP 40

\ ******************************************************************************
\
\       Name: var24Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var24Hi

 SKIP 16

\ ******************************************************************************
\
\       Name: var25Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var25Hi

 SKIP 24

\ ******************************************************************************
\
\       Name: var23Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var23Hi

 SKIP 40

\ ******************************************************************************
\
\       Name: L5EE0
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L5EE0

 SKIP 24

\ ******************************************************************************
\
\       Name: scaledScaffold
\       Type: Variable
\   Category: 3D objects
\    Summary: Storage for an object's scaled scaffold
\  Deep dive: Scaling objects with scaffolds
\
\ ******************************************************************************

.scaledScaffold

 SKIP 16

\ ******************************************************************************
\
\       Name: L5F08
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L5F08

 SKIP 24

\ ******************************************************************************
\
\       Name: yVergeRight
\       Type: Variable
\   Category: Track
\    Summary: Elevation of the right verge of the track in front of us
\
\ ******************************************************************************

.yVergeRight

 SKIP 24

\ ******************************************************************************
\
\       Name: numberOfPlayers
\       Type: Variable
\   Category: Drivers
\    Summary: The number of players
\
\ ******************************************************************************

.numberOfPlayers

 SKIP 1

\ ******************************************************************************
\
\       Name: lowestPlayerNumber
\       Type: Variable
\   Category: Drivers
\    Summary: The number of the player with the lowest player number
\
\ ******************************************************************************

.lowestPlayerNumber

 SKIP 1                 \ Contains 20 minus the number of players, so that's:
                        \
                        \   * 19 if there is one player
                        \   * 18 if there are two players
                        \
                        \ and so on, down to 0 if there are 20 players
                        \
                        \ Human players take the place of drivers with higher
                        \ numbers, so the first player takes the place of driver
                        \ 19 (the aptly called Dummy Driver, as they never get
                        \ to race), and the second player takes the place of
                        \ driver 18 (Peter Out), the third player replaces
                        \ driver 17 (Rick Shaw) and so on
                        \
                        \ So this not only represents the lowest player number,
                        \ but also the highest non-human driver number (which is
                        \ lowestPlayerNumber - 1)

\ ******************************************************************************
\
\       Name: raceClass
\       Type: Variable
\   Category: Drivers
\    Summary: The class of the current race
\
\ ******************************************************************************

.raceClass

 SKIP 1                 \ The class of race:
                        \
                        \   * 0 = Novice
                        \
                        \   * 1 = Amateur
                        \
                        \   * 2 = Professional

\ ******************************************************************************
\
\       Name: qualifyingTime
\       Type: Variable
\   Category: Drivers
\    Summary: The number of minutes of qualifying lap time
\
\ ******************************************************************************

.qualifyingTime

 SKIP 1                 \ The number of minutes of qualifying lap time, minus
                        \ one, as follows:
                        \
                        \   * 4 gives us 5 minutes of qualifying time
                        \
                        \   * 9 gives us 10 minutes of qualifying time
                        \
                        \   * 25 gives us 26 minutes of qualifying time
                        \
                        \   * 255 gives us infinite time (for practice)
                        \
                        \ Note that the third value should be 19 to match the
                        \ menu option of 20 minutes, but the value in the
                        \ timeFromOption table is incorrect

\ ******************************************************************************
\
\       Name: competitionStarted
\       Type: Variable
\   Category: Drivers
\    Summary: A flag to indicate whether or not the competition has started
\
\ ******************************************************************************

.competitionStarted

 SKIP 1                 \ Flag to indicate whether the competition has started:
                        \
                        \   * 0 = the competition has not started
                        \
                        \   * Non-zero = the competition has started

\ ******************************************************************************
\
\       Name: frontWingSetting
\       Type: Variable
\   Category: Driving model
\    Summary: The front wing setting, as entered by the player
\
\ ******************************************************************************

.frontWingSetting

 SKIP 1

\ ******************************************************************************
\
\       Name: rearWingSetting
\       Type: Variable
\   Category: Driving model
\    Summary: The rear wing setting, as entered by the player
\
\ ******************************************************************************

.rearWingSetting

 SKIP 1

\ ******************************************************************************
\
\       Name: lapsMenuOption
\       Type: Variable
\   Category: Drivers
\    Summary: The menu option chosen from the laps menu (0 to 2)
\
\ ******************************************************************************

.lapsMenuOption

 SKIP 1

\ ******************************************************************************
\
\       Name: baseSpeed
\       Type: Variable
\   Category: Drivers
\    Summary: The base speed for each car, copied from the track data
\
\ ******************************************************************************

.baseSpeed

 SKIP 1                 \ The base speed for each car, which is faster with a
                        \ higher class of race (this value is taken from the
                        \ track data at trackBaseSpeed):
                        \
                        \   * 134 = Novice
                        \
                        \   * 146 = Amateur
                        \
                        \   * 152 = Professional

 SKIP 7

\ ******************************************************************************
\
\       Name: yVergeLeft
\       Type: Variable
\   Category: Track
\    Summary: Elevation of the left verge of the track in front of us
\
\ ******************************************************************************

.yVergeLeft

 SKIP 24

\ ******************************************************************************
\
\       Name: backgroundColour
\       Type: Variable
\   Category: Graphics
\    Summary: The background colour for each track line
\  Deep dive: Drawing the track view
\
\ ------------------------------------------------------------------------------
\
\ Bits 0 and 1 give the starting colour (i.e. the background colour) of each
\ track line. This value is a logical colour and the physical colour is looked
\ up from the colourPalette table.
\
\ ******************************************************************************

.backgroundColour

 SKIP 80

\ ******************************************************************************
\
\       Name: bestRacingLine
\       Type: Variable
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.bestRacingLine

 SKIP 32

\ ******************************************************************************
\
\       Name: L5FD0
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L5FD0

 EQUB &00, &88, &CC, &EE, &0F, &8F, &CF, &EF, &F0, &F8, &FC, &FE
 EQUB &00, &08, &0C, &0E, &00, &80, &C0, &E0, &0F, &07, &03, &01
 EQUB &F0, &70, &30, &10, &FF, &77, &33, &11, &FF, &7F, &3F, &1F
 EQUB &FF, &F7, &F3, &F1

 EQUB &03, &60

\ ******************************************************************************
\
\       Name: scaleRange
\       Type: Variable
\   Category: 3D objects
\    Summary: Storage for scale factors when scaling objects
\
\ ******************************************************************************

.scaleRange

IF _ACORNSOFT

 EQUB &6F, &6E
 EQUB &32, &00
 EQUB &8D, &2B

ELIF _SUPERIOR

 EQUB &30, &18
 EQUB &0C, &06
 EQUB &03, &01

ENDIF

\ ******************************************************************************
\
\       Name: zeroIfYIs55
\       Type: Variable
\   Category: Graphics
\    Summary: A lookup table for zeroing Y if and only if it is &55
\
\ ******************************************************************************

.zeroIfYIs55

 FOR I%, 0, 255
  IF I% = &55
   EQUB 0
  ELSE
   EQUB I%
  ENDIF
 NEXT

\ ******************************************************************************
\
\       Name: arctanR
\       Type: Variable
\   Category: Maths
\    Summary: Table for arctan values when calculating rotation angles
\
\ ******************************************************************************

.arctanR

 FOR I%, 0, 255
  EQUB INT(0.5 + ATN(I% / 256) * 325.95)
 NEXT

\ ******************************************************************************
\
\       Name: arctanE
\       Type: Variable
\   Category: Maths
\    Summary: Table for arctan values when calculating elevation angles
\
\ ------------------------------------------------------------------------------
\
\ This is very close to the following calculation:
\
\ FOR I%, 0, 127
\  EQUB INT(0.5 + 776 - 512 * ATN(3.2595 * (I% + 128) / 256))
\ NEXT
\
\ ******************************************************************************

.arctanE

 EQUB &FF, &FE, &FC, &FA
 EQUB &F8, &F6, &F5, &F3, &F1, &EF, &ED, &EC, &EA, &E8, &E7, &E5
 EQUB &E4, &E2, &E0, &DF, &DD, &DC, &DA, &D9, &D8, &D6, &D5, &D3
 EQUB &D2, &D1, &CF, &CE, &CD, &CC, &CA, &C9, &C8, &C7, &C5, &C4
 EQUB &C3, &C2, &C1, &C0, &BF, &BD, &BC, &BB, &BA, &B9, &B8, &B7
 EQUB &B6, &B5, &B4, &B3, &B2, &B1, &B0, &AF, &AE, &AD, &AC, &AC
 EQUB &AB, &AA, &A9, &A8, &A7, &A6, &A5, &A5, &A4, &A3, &A2, &A1
 EQUB &A1, &A0, &9F, &9E, &9E, &9D, &9C, &9B, &9B, &9A, &99, &98
 EQUB &98, &97, &96, &96, &95, &94, &94, &93, &92, &92, &91, &90
 EQUB &90, &8F, &8E, &8E, &8D, &8D, &8C, &8B, &8B, &8A, &8A, &89
 EQUB &89, &88, &87, &87, &86, &86, &85, &85, &84, &84, &83, &83
 EQUB &82, &82, &81, &81

\ ******************************************************************************
\
\       Name: xPlayerCoordLo
\       Type: Variable
\   Category: 3D objects
\    Summary: The low byte of the x-coordinate of the player's 3D coordinates
\
\ ******************************************************************************

.xPlayerCoordLo

 EQUB 0

\ ******************************************************************************
\
\       Name: yPlayerCoordLo
\       Type: Variable
\   Category: 3D objects
\    Summary: The low byte of the y-coordinate of the player's 3D coordinates
\
\ ******************************************************************************

.yPlayerCoordLo

 EQUB 0

\ ******************************************************************************
\
\       Name: zPlayerCoordLo
\       Type: Variable
\   Category: 3D objects
\    Summary: The low byte of the z-coordinate of the player's 3D coordinates
\
\ ******************************************************************************

.zPlayerCoordLo

 EQUB 0

\ ******************************************************************************
\
\       Name: xPlayerCoordHi
\       Type: Variable
\   Category: 3D objects
\    Summary: The high byte of the x-coordinate of the player's 3D coordinates
\
\ ******************************************************************************

.xPlayerCoordHi

 EQUB 0

\ ******************************************************************************
\
\       Name: yPlayerCoordHi
\       Type: Variable
\   Category: 3D objects
\    Summary: The high byte of the y-coordinate of the player's 3D coordinates
\
\ ******************************************************************************

.yPlayerCoordHi

 EQUB 0

\ ******************************************************************************
\
\       Name: zPlayerCoordHi
\       Type: Variable
\   Category: 3D objects
\    Summary: The high byte of the z-coordinate of the player's 3D coordinates
\
\ ******************************************************************************

.zPlayerCoordHi

 EQUB 0

\ ******************************************************************************
\
\       Name: xVector6Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.xVector6Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: yVector6Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.yVector6Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: zVector6Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.zVector6Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: xVector6Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.xVector6Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: yVector6Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.yVector6Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: zVector6Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.zVector6Hi

 EQUB 0

 EQUB 0, 0, 0           \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: objectPalette
\       Type: Variable
\   Category: 3D objects
\    Summary: The object colour palette that maps logical colours 0 to 3 to
\             physical colours
\
\ ******************************************************************************

.objectPalette

 EQUB 0, 0, 0, 0

\ ******************************************************************************
\
\       Name: mirrorContents
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains the size of the car in each mirror segment
\
\ ******************************************************************************

.mirrorContents

 EQUB 0                 \ Mirror segment 0 (left mirror, outer segment)
 EQUB 0                 \ Mirror segment 1 (left mirror, middle segment)
 EQUB 0                 \ Mirror segment 2 (left mirror, inner segment)

 EQUB 0                 \ Mirror segment 3 (right mirror, inner segment)
 EQUB 0                 \ Mirror segment 4 (right mirror, middle segment)
 EQUB 0                 \ Mirror segment 5 (right mirror, outer segment)

\ ******************************************************************************
\
\       Name: L6299
\       Type: Variable
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Something to do with corner markers.
\
\ If bit 5 is set, the marker is red, otherwise it is white.
\ If bit 0 is set, the marker is half size.
\
\ ******************************************************************************

.L6299

 EQUB 0, 0, 0

\ ******************************************************************************
\
\       Name: L629C
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L629C

 EQUB 0, 0, 0, 0

\ ******************************************************************************
\
\       Name: var26Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var26Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: L62A1
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62A1

 EQUB 0

\ ******************************************************************************
\
\       Name: steeringLo
\       Type: Variable
\   Category: Driving model
\    Summary: The low byte of the steering wheel position
\
\ ------------------------------------------------------------------------------
\
\ The steering wheel position is stored as (steeringHi steeringLo), with the
\ sign bit in bit 0 of steeringLo, so it's a sign-magnitude number.
\
\ Negative (bit 0 set) means we are steering left, positive (bit 0 clear) means
\ we are steering right.
\
\ ******************************************************************************

.steeringLo

 EQUB 0

\ ******************************************************************************
\
\       Name: var26Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var26Hi

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: steeringHi
\       Type: Variable
\   Category: Driving model
\    Summary: The high byte of the steering wheel position
\
\ ------------------------------------------------------------------------------
\
\ The steering wheel position is stored as (steeringHi steeringLo), with the
\ sign bit in bit 0 of steeringLo, so it's a sign-magnitude number.
\
\ Negative (bit 0 set) means we are steering left, positive (bit 0 clear) means
\ we are steering right.
\
\ ******************************************************************************

.steeringHi

 EQUB 0

\ ******************************************************************************
\
\       Name: L62A6
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ If bit 7 is set L62A6, we make the sound of squealing tyres.
\
\ ******************************************************************************

.L62A6

 EQUB 0

\ ******************************************************************************
\
\       Name: L62A7
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ If bit 7 is set L62A7, we make the sound of squealing tyres.
\
\ ******************************************************************************

.L62A7

 EQUB 0

\ ******************************************************************************
\
\       Name: wingSetting
\       Type: Variable
\   Category: Driving model
\    Summary: Contains the scaled wing settings
\
\ ******************************************************************************

.wingSetting

 EQUB 0                 \ Front wing setting, scaled to the range 90 to 218

 EQUB 0                 \ Rear wing setting, scaled to the range 90 to 218

\ ******************************************************************************
\
\       Name: L62AA
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62AA

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: L62AC
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62AC

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: L62AE
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62AE

 EQUB 0, 0, 0

\ ******************************************************************************
\
\       Name: L62B1
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62B1

 EQUB 0, 0, 0

\ ******************************************************************************
\
\       Name: L62B4
\       Type: Variable
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Something to do with corner markers. The value is used as an offset into the
\ var24Lo and var24Hi tables.
\
\ ******************************************************************************

.L62B4

 EQUB 0, 0, 0

\ ******************************************************************************
\
\       Name: var27Lo
\       Type: Variable
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Something to do with corner markers.
\
\ ******************************************************************************

.var27Lo

 EQUB 0, 0, 0

\ ******************************************************************************
\
\       Name: var27Hi
\       Type: Variable
\   Category: Track
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ Something to do with corner markers.
\
\ ******************************************************************************

.var27Hi

 EQUB 0, 0, 0

\ ******************************************************************************
\
\       Name: soundBuffer
\       Type: Variable
\   Category: Sound
\    Summary: Details of each sound channel's buffer status
\
\ ******************************************************************************

.soundBuffer

 EQUB 0, 0, 0, 0, 0, 0

\ ******************************************************************************
\
\       Name: characterDef
\       Type: Variable
\   Category: Text
\    Summary: Storage for a character definition when printing characters
\
\ ******************************************************************************

.characterDef

 EQUB 0                 \ The character number

 EQUB 0, 0, 0, 0        \ The eight bytes that make up the character definition,
 EQUB 0, 0, 0, 0        \ which gets populated by an OSWORD call

\ ******************************************************************************
\
\       Name: xCursor
\       Type: Variable
\   Category: Text
\    Summary: The cursor's x-coordinate, which can either be a pixel coordinate
\             or a character row
\
\ ******************************************************************************

.xCursor

 EQUB 0

\ ******************************************************************************
\
\       Name: yCursor
\       Type: Variable
\   Category: Text
\    Summary: The cursor's pixel y-coordinate
\
\ ------------------------------------------------------------------------------
\
\ In terms of printing text on-screen, we need to set:
\
\   * yCursor = 24 for the first line of text
\
\   * yCursor = 33 for the second line of text
\
\ See the notes on the yLookupHi variable for information about the values of
\ yCursor and how they relate to the custom screen.
\
\ ******************************************************************************

.yCursor

 EQUB 0

 EQUB 0, 0              \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: var02Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var02Lo

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: spinSpeedLo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.spinSpeedLo

 EQUB 0

\ ******************************************************************************
\
\       Name: var04Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var04Lo

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: var05Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var05Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: var06Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var06Lo

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: var07Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var07Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: var08Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var08Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: var09Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var09Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: var10Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var10Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: var11Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var11Lo

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: var12Lo
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var12Lo

 EQUB 0

\ ******************************************************************************
\
\       Name: mainLoopCounterHi
\       Type: Variable
\   Category: Main loop
\    Summary: High byte of the main loop counter, which increments on each
\             iteration of the main driving loop
\
\ ------------------------------------------------------------------------------
\
\ Stored as a 16-bit value (mainLoopCounterHi mainLoopCounterLo).
\
\ ******************************************************************************

.mainLoopCounterHi

 EQUB 0

\ ******************************************************************************
\
\       Name: var02Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var02Hi

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: spinSpeedHi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.spinSpeedHi

 EQUB 0

\ ******************************************************************************
\
\       Name: var04Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var04Hi

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: var05Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var05Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: var06Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var06Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: L62E7Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62E7Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: var07Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var07Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: var08Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var08Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: var09Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var09Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: var10Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var10Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: var11Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var11Hi

 EQUB 0, 0

\ ******************************************************************************
\
\       Name: var12Hi
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.var12Hi

 EQUB 0

\ ******************************************************************************
\
\       Name: firstLapStarted
\       Type: Variable
\   Category: Drivers
\    Summary: Flag to keep track of whether we have started the first lap of
\             practice or qualifying
\
\ ------------------------------------------------------------------------------
\
\ For practice and qualifying laps, firstLapStarted keeps track of whether we
\ have started the first lap (at which point the lap timer starts).
\
\ Before we reach the starting line, firstLapStarted is -33, which is the value
\ it gets in ResetVariables for practice or qualifying laps. This is then
\ incremented to 0 when we start the first lap.
\
\ The value of firstLapStarted is decremented with each call to UpdateLapTimers
\ for practice or qualifying, but only if bit 6 of updateDrivingInfo is set and
\ firstLapStarted is non-zero. I am not sure why.
\
\ ******************************************************************************

.firstLapStarted

 EQUB 0

\ ******************************************************************************
\
\       Name: L62F0
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62F0

 EQUB 0

\ ******************************************************************************
\
\       Name: wingBalance
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.wingBalance

 EQUB 0

\ ******************************************************************************
\
\       Name: L62F2
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62F2

 EQUB 0

\ ******************************************************************************
\
\       Name: thisObjectType
\       Type: Variable
\   Category: 3D objects
\    Summary: The type of object we are currently drawing
\
\ ******************************************************************************

.thisObjectType

 EQUB 0

\ ******************************************************************************
\
\       Name: temp3
\       Type: Variable
\   Category: Graphics
\    Summary: Temporary storage, used when drawing cars
\
\ ******************************************************************************

.temp3

 EQUB 0

\ ******************************************************************************
\
\       Name: newSegmentFetched
\       Type: Variable
\   Category: Track
\    Summary: Flag that determines whether a new track segment has been fetched
\
\ ******************************************************************************

.newSegmentFetched

 EQUB 0                 \ Track segment status:
                        \
                        \   * 0 = no new segment
                        \
                        \   * Non-zero = a new segment has been fetched by the
                        \                GetTrackSegment routine

\ ******************************************************************************
\
\       Name: crashedIntoFence
\       Type: Variable
\   Category: Driving model
\    Summary: Flag that records whether we have crashed into the fence
\
\ ******************************************************************************

.crashedIntoFence

 EQUB 0                 \ Crash status
                        \
                        \   * 0 = we have not crashed into the fence
                        \
                        \   * &FF = we have crashed into the fence

\ ******************************************************************************
\
\       Name: irqCounter
\       Type: Variable
\   Category: Screen mode
\    Summary: Counter that gets incremented every time the IRQ routine reaches
\             section 4 of the custom screen
\
\ ******************************************************************************

.irqCounter

 EQUB 0

\ ******************************************************************************
\
\       Name: updateLapTimes
\       Type: Variable
\   Category: Drivers
\    Summary: Controls whether moving the car forward updates the lap number and
\             lap times
\
\ ******************************************************************************

.updateLapTimes

 EQUB 0

\ ******************************************************************************
\
\       Name: previousSignNumber
\       Type: Variable
\   Category: Track
\    Summary: Stores the number of the sign from the previous call to the
\             BuildRoadSign routine
\
\ ------------------------------------------------------------------------------
\
\ Set to 23 in ResetVariables.
\
\ ******************************************************************************

.previousSignNumber

 EQUB 0

\ ******************************************************************************
\
\       Name: tyreTravel
\       Type: Variable
\   Category: Graphics
\    Summary: Keeps track of how far we have travelled so we know when to
\             animate the tyres
\
\ ******************************************************************************

.tyreTravel

 EQUB 0

\ ******************************************************************************
\
\       Name: L62FB
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62FB

 EQUB 0

\ ******************************************************************************
\
\       Name: L62FC
\       Type: Variable
\   Category: Graphics
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62FC

 EQUB 0

\ ******************************************************************************
\
\       Name: lowestTrackLine
\       Type: Variable
\   Category: Graphics
\    Summary: Used to prevent objects from being drawn below the horizon line
\
\ ******************************************************************************

.lowestTrackLine

 EQUB 0

\ ******************************************************************************
\
\       Name: updateDriverInfo
\       Type: Variable
\   Category: Text
\    Summary: Flag that controls whether the driver names are updated in the
\             information block at the top of the screen
\
\ ------------------------------------------------------------------------------
\
\ If bit 7 is set, then we update the driver names in the "In front" and
\ "Behind" sections at the top of the screen.
\
\ Bit 7 gets set in ResetVariables, for race laps only.
\
\ ******************************************************************************

.updateDriverInfo

 EQUB 0

\ ******************************************************************************
\
\       Name: L62FF
\       Type: Variable
\   Category: 
\    Summary: 
\
\ ------------------------------------------------------------------------------
\
\ 
\
\ ******************************************************************************

.L62FF

 EQUB 0

\ ******************************************************************************
\
\       Name: GetTextInput
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Fetch a string from the keyboard, padded with spaces if required
\
\ ------------------------------------------------------------------------------
\
\ This routine fetches a string of characters from the keyboard and stores the
\ result in memory. The string is entered by pressing RETURN, at which point the
\ string in memory is padded with spaces so that it meets the required length.
\
\ The DELETE key is supported, leading spaces are ignored, and the ESCAPE key is
\ trapped and has no effect.
\
\ Arguments:
\
\   (Y A)               The address where the string should be stored
\
\   X                   The length of string that we require
\
\ Returns:
\
\   Y                   The number of characters entered, before any padding is
\                       applied
\
\ ******************************************************************************

.GetTextInput

 STA P                  \ Set (Q P) = (Y A)
 STY Q

 STX W                  \ Store the required length of input in W

 LDA #2                 \ Call OSBYTE with A = 2 and X = 0 to select the
 LDX #0                 \ keyboard as the input stream and disable RS423
 JSR OSBYTE

 LDA #21                \ Call OSBYTE with A = 21 and X = 0 to flush the
 LDX #0                 \ keyboard buffer
 JSR OSBYTE

.text1

 LDY #0                 \ Set Y = 0 to use as a counter for the number of
                        \ characters entered

.text2

 JSR OSRDCH             \ Call OSRDCH to read a character from the currently
                        \ selected input stream (i.e. the keyboard) into A

 BCS text7              \ If the call to OSRDCH set the C flag then there was an
                        \ error (probably caused by pressing ESCAPE), so jump to
                        \ text7 to process this

 CMP #13                \ If RETURN was pressed, jump to text9
 BEQ text9

 CMP #' '               \ If a control character was entered (i.e. with an ASCII
 BCC text2              \ code less than tyat of " "), jump back to text2 to
                        \ ignore it and wait for another key press

 BNE text3              \ If a key other than SPACE was pressed, jump to text3
                        \ skip the next two instructions

 CPY #0                 \ SPACE was pressed, so if no other characters have been
 BEQ text2              \ (i.e. Y = 0), jump back to text2 to ignore it

.text3

 CMP #127               \ If the character entered has an ASCII value < 127,
 BCC text4              \ jump to text4 to process it as a valid character

 BNE text2              \ If the character entered has an ASCII value > 127,
                        \ jump back to text2 to ignore it

                        \ If we get here then the DELETE key was pressed, which
                        \ has an ASCII value of 127

 DEY                    \ Decrement the number of characters entered in Y, to
                        \ process the deletion

 BPL text6              \ If Y is still positive, jump to text6 to print the
                        \ delete character, which will delete the last character
                        \ entered on-screen

 BMI text1              \ Y is negative, so we just deleted past the start of
                        \ the entered string, so jump to text1 to set Y to 0 and
                        \ start again (this BMI is effectively a JMP as we just
                        \ passed through a BPL)

.text4

                        \ If we get here then a valid character was entered

 CPY W                  \ If the number of characters entered in Y is not yet
 BNE text5              \ the required number in W, jump to text5 to store the
                        \ new character

 LDA #7                 \ Otherwise set A = 7 (the ASCII code for a beep) and
 BNE text6              \ jump to text6 to skip storing the new character and
                        \ make a beep, as we already have enough characters

.text5

                        \ If we get here then we have successfully fetched a new
                        \ character, so now we store it

 STA (P),Y              \ Store the character entered in the Y-th byte of (Q P)

 INY                    \ Increment the character counter in Y

.text6

 JSR OSWRCH             \ Print the character in A, which will either be the new
                        \ character, or a beep, or a delete

 JMP text2              \ Jump up to text2 to fetch the next character

.text7

                        \ If we get here then ESCAPE was pressed

 TYA                    \ Store the character count in Y on the stack
 PHA

 LDA #126               \ Call OSBYTE with A = 126 to acknowledge the ESCAPE
 JSR OSBYTE             \ condition

 PLA                    \ Retrieve the character count from the stack into Y
 TAY

 JMP text2              \ Jump up to text2 to fetch the next character

.text8

 INY                    \ We get here from below after appending a space to the
                        \ stored string, so we increment Y and repeat the
                        \ padding process until the string is full

.text9

                        \ If we get here then RETURN was pressed

 CPY W                  \ If the number of characters entered in Y is not yet
 BNE text10             \ the required number in W, jump to text10 to pad out
                        \ the string with spaces

 RTS                    \ Otherwise the string is the correct size, so we now
                        \ return from the subroutine

.text10

 LDA #' '               \ Append a space to the end of the stored string
 STA (P),Y

 BNE text8              \ Jump back to text8 to keep padding the string with
                        \ spaces (this BNE is effectively a JMP as A is never
                        \ zero)

\ ******************************************************************************
\
\       Name: SetDriverSpeed
\       Type: Subroutine
\   Category: Drivers
\    Summary: Set the speed for a specific driver
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   setSpeedForDriver   The number of the driver to set the speed for
\
\ Returns:
\
\   X                   The number of the previous driver
\
\   setSpeedForDriver   Points to the next driver, ready for the next call to
\                       SetDriverSpeed
\
\ ******************************************************************************

.SetDriverSpeed

 LDX setSpeedForDriver  \ Set X to the driver number to initialise

                        \ We now start a lengthy calculation of a figure in A
                        \ that we will add to the track's base speed to
                        \ determine the speed for this driver, with a higher
                        \ figure in A giving the car a higher speed in the race

 LDA VIA+&68            \ Read 6522 User VIA T1C-L timer 2 low-order counter
                        \ (SHEILA &68), which will be a pretty random figure

 PHP                    \ Store the processor flags from the random timer value
                        \ on the stack

 AND #%01111111         \ Clear bit 0 of the random number in A, so A is now in
                        \ the range 0 to 127

                        \ The following calculates the following:
                        \
                        \   * If A is in the range 0 to 63, A = A mod 4
                        \
                        \   * If A is in the range 64 to 127, A = (A - 64) mod 7
                        \
                        \ Given that A starts out as a random number, this will
                        \ produce a random number with the following chances:
                        \
                        \   50% of the time, 25% chance of 0 to 3
                        \   50% of the time, 12.5% chance of 0 to 7
                        \
                        \ So the probability of getting each of the numbers from
                        \ 0 to 7 is:
                        \
                        \   0 to 3 = 0.5 * 0.25 + 0.5 * 0.125 = 0.1875 = 18.75%
                        \   4 to 7 = 0.5 * 0.125              = 0.0625 =  6.25%
                        \
                        \ So we're three times more likely to get a number in
                        \ the range 0 to 3 as in the range 4 to 7

 LDY #16                \ Set a loop counter in Y to subtract 16 lots of 4

.fast1

 CMP #4                 \ If A < 4, jump to fast3, as A now contains the
 BCC fast3              \ original value of A mod 4

 SBC #4                 \ A >= 4, so set A = A - 4

 DEY                    \ Decrement the loop counter

 BNE fast1              \ Loop back until we have either reduced A to be less
                        \ than 4, or we have subtracted 16 * 4 = 64

                        \ If we get here then the original A was 64 or more,
                        \ 64, and A is now in the range 0 to 63

 LDY #9                 \ Set a loop counter in Y to subtract 9 lots of 7

.fast2

 CMP #7                 \ If A < 7, jump to fast3, as A now contains the
 BCC fast3              \ original value of (A - 64) mod 7

 SBC #7                 \ A >= 7, so set A = A - 7

 DEY                    \ Decrement the loop counter

 BNE fast2              \ Loop back until we have either reduced A to be less
                        \ than 7, or we have subtracted 9 * 7 = 63

                        \ If we get here then the original A was 127, and we
                        \ first subtracted 64 and then 63 to give us 0

.fast3

                        \ We now have our random number in the range 0 to 7,
                        \ with 0 to 3 more likely than 4 to 7

 PLP                    \ Retrieve the processor flags from the random timer
                        \ value that we put on the stack above, which sets the
                        \ N flag randomly (amongst others)

 JSR Absolute8Bit       \ The first instruction of Absolute8Bit is a BPL, which
                        \ normally skips negation for positive numbers, but in
                        \ this case it means the Absolute8Bit routine randomly
                        \ changes the sign of A, so A is now in the range
                        \ -7 to +7, with -3 to +3 more likely than -7 to -4 or
                        \ 4 to 7

 ASL A                  \ Set A = A << 1, so A is now in the range -14 to +14,
                        \ with -6 to +6 more likely than -14 to -7 or 7 to 14

 SEC                    \ Set A = A - driverGridRow for this driver
 SBC driverGridRow,X    \
                        \ So A is left alone for the two cars at the front of
                        \ the grid, is reduced by 1 for the next two cars, and
                        \ is reduced by 9 for the two cars at the back

 STA T                  \ Set T = A

                        \ By this point, the value in A (and T) is in the range:
                        \
                        \   * -14 to +14 for the front two cars
                        \   * -15 to +13 for the next two cars
                        \     ...
                        \   * -23 to +4 for the last two cars
                        \
                        \ We now alter this according to the race class

 LDY raceClass          \ Set Y to the race class

 DEY                    \ Decrement Y, so it will be -1 for Novice, 0 for
                        \ Amateur and 1 for Professional

 BEQ fast5              \ If Y = 0 (Amateur), jump to fast5 to leave A alone

 BPL fast4              \ If Y = 1 (Professional), jump to fast4

                        \ If we get here, then the race class is Novice

 ASL A                  \ Set A = A << 1
                        \
                        \ so A is now in the range:
                        \
                        \   * -28 to +28 for the front two cars
                        \   * -30 to +26 for the next two cars
                        \     ...
                        \   * -46 to +8 for the last two cars
                        \
                        \ This makes the range of speeds less tightly bunched,
                        \ so the race is less intense

 JMP fast5              \ Jump to fast5 to skip the following

.fast4

                        \ If we get here, then the race class is Professional

 ROL T                  \ Shift bit 7 of T into the C flag, and because T = A,
                        \ this puts bit 7 of A into the C flag

 ROR A                  \ Shift A right while inserting a copt of bit 7 into
                        \ bit 7, so this effectively divides A by two while
                        \ keeping the sign intact:
                        \
                        \   A = A / 2
                        \
                        \ So A is now in the range:
                        \
                        \   * -7 to +7 for the front two cars
                        \   * -8 to +6 for the next two cars
                        \     ...
                        \   * -12 to +2 for the last two cars
                        \
                        \ This makes the range of speeds more tightly bunched,
                        \ so the race is more intense

.fast5

                        \ By this point we have our value A, which determines
                        \ the speed of the driver based on our random number,
                        \ the car's grid position and the race class, so now we
                        \ add this to the track's base speed to get the driver's
                        \ speed for the race
                        \
                        \ The track's base speed is different depending on the
                        \ race class, so taking Silverstone as an example, we
                        \ get these final ranges for the front two cars:
                        \
                        \   * Novice       = 134 plus -28 to +28 = 106 to 162
                        \   * Amateur      = 146 plus -14 to +14 = 132 to 160
                        \   * Professional = 153 plus  -7 to  +7 = 146 to 160
                        \
                        \ and these final ranges for the two cars at the back:
                        \
                        \   * Novice       = 134 plus -46 to +8 =  88 to 142
                        \   * Amateur      = 146 plus -23 to +4 = 123 to 150
                        \   * Professional = 153 plus -12 to +2 = 141 to 155

 CLC                    \ Set the driverSpeed for driver X to baseSpeed + A
 ADC baseSpeed
 STA driverSpeed,X

 JSR GetPositionAhead   \ Set X to the number of the position ahead of the
                        \ driver whose speed we just set

 STX setSpeedForDriver  \ Set setSpeedForDriver = X
                        \
                        \ So the next call to the routine will set the speed for
                        \ the next driver ahead

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SetPlayerPositions
\       Type: Subroutine
\   Category: Drivers
\    Summary: Set the current player's position, plus the positions behind and
\             in front
\
\ ******************************************************************************

.SetPlayerPositions

 LDA currentPlayer      \ Set A to the number of the current player

 LDX #19                \ We are about to work our way through the ordered list
                        \ of drivers in driversInOrder, so set a loop counter
                        \ in X, starting at the end of the list (i.e. last
                        \ place)

.ppos1

 CMP driversInOrder,X   \ If the driver in position X in the list matches the
 BEQ ppos2              \ current player, jump to ppos2

 DEX                    \ Decrement the driver number

 BPL ppos1              \ Loop back until we have gone through the whole table

.ppos2

                        \ By this point, X contains the position within the
                        \ driversInOrder list of the current player (or -1 if
                        \ the current player doesn't appear in the list)

 STX currentPosition    \ Store the current player's position in currentPosition

 JSR GetPositionBehind  \ Set X to the number of the position behind this one

 STX positionBehind     \ Store the position behind the current player in
                        \ positionBehind

 LDX currentPosition    \ Set X to the number of the position ahead of the
 JSR GetPositionAhead   \ current player's position

 STX positionAhead      \ Store the position ahead of the current player in
                        \ positionAhead

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Protect
\       Type: Subroutine
\   Category: Setup
\    Summary: Decrypt or unprotect the game code (disabled)
\
\ ******************************************************************************

IF _SUPERIOR

.Protect

 JMP SetupGame          \ Jump to SetupGame to continue setting up the game

 NOP                    \ Presumably this contained some kind of copy protection
 NOP                    \ or decryption code that has been replaced by NOPs in
 NOP                    \ this unprotected version of the game
 NOP
 NOP

ENDIF

\ ******************************************************************************
\
\       Name: GetSteeringAssist
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Fetch the current Computer Assisted Steering (CAS) status and show
\             or hide the CAS indicator
\
\ ------------------------------------------------------------------------------
\
\ The Computer Assisted Steering (CAS) indicator is in the centre-bottom of the
\ rev counter, and is made up of four pixels in colour 2 (white) as follows:
\
\   ...xx...
\   ..x..x..
\
\ which would be encoded in mode 5 screen memory as follows:
\
\   %00010000   %10000000
\   %00100000   %01000000
\
\ This routine shows or hides the indicator according to the current setting of
\ configAssist, returning the value of configAssist in X.
\
\ Returns:
\
\   X                   The current value of configAssist:
\
\                         * %10000000 if Computer Assisted Steering is enabled
\
\                         * 0 if Computer Assisted Steering is not enabled
\
\   A                   A is unchanged
\
\   C flag              Set to bit 7 of directionFacing (clear if our car is
\                       facing forwards, set if we are facing backwards)
\
\ ******************************************************************************

IF _SUPERIOR

.GetSteeringAssist

 PHA                    \ Store A on the stack so we can retrieve it below

 LDA configAssist       \ Set A to configAssist, which has the following value:
                        \
                        \   * %10000000 if Computer Assisted Steering is enabled
                        \
                        \   * 0 if Computer Assisted Steering is not enabled
                        \
                        \ The following updates screen memory to add a small
                        \ "hat" marker to the centre-bottom of the rev counter
                        \ when CAS is enabled (or to to remove the marker when
                        \ it isn't enabled)

 STA assistRight1       \ Set assistRight1 = 0 or %10000000

 LSR A                  \ Set assistRight2 = 0 or %01000000
 STA assistRight2

 LSR A                  \ Set assistLeft2 = 0 or %00100000
 STA assistLeft2

 LSR A                  \ Set assistLeft1 = 0 or %00010000
 STA assistLeft1

 LDA directionFacing    \ Set the C flag to bit 7 of directionFacing, which we
 ROL A                  \ return from the subroutine

 PLA                    \ Restore the value of A that we put on the stack above

 LDX configAssist       \ Set X to configAssist

 RTS                    \ Return from the subroutine

ENDIF

\ ******************************************************************************
\
\       Name: SetupGame
\       Type: Subroutine
\   Category: Setup
\    Summary: Decrypt or unprotect the game code (disabled)
\
\ ******************************************************************************

IF _SUPERIOR

.SuperiorSetupGame

CLEAR &3850, &3880      \ In the Superior Software release of Revs, the routines
ORG &3850               \ for Computer Assisted Steering (CAS) take up extra
                        \ memory, so we need to claw back some memory from
                        \ somewhere
                        \
                        \ The clever solution is to move the SetupGame routine,
                        \ which is run when the game loads, but is never needed
                        \ again, so in the Superior version, SetupGame is put
                        \ into the same block of memory as the carSpeedLo,
                        \ totalPointsLo and totalPointsLo variables, which are
                        \ only used after the game has started
                        \
                        \ These lines rewind BeebAsm's assembly back to
                        \ carSpeedLo (which is at address &3850), and clear the
                        \ block that is occupied by these three variables, so we
                        \ can assemble SetupGame in the right place while
                        \ retaining the correct addresses for the three
                        \ variables
                        \
                        \ We also make a note of the current address, so we can
                        \ ORG back to it after assembling SetupGame

ENDIF

.SetupGame

 LDA #4                 \ Call OSBYTE with A = 4, X = 1 and Y = 0 to disable
 LDY #0                 \ cursor editing
 LDX #1
 JSR OSBYTE

 JSR SetScreenMode7     \ Change to screen mode 7 and hide the cursor

 LDX #9                 \ We now zero the ten bytes starting at configStop, so
                        \ set a loop counter in X

 LDA #0                 \ Set lineBufferSize = 0, to reset the line buffer
 STA lineBufferSize

.setp1

 STA configStop,X       \ Zero the X-th byte at configStop
                        \
                        \ The address in this instruction gets modified

 DEX                    \ Decrement the loop counter

 BPL setp1              \ Loop back until we have zeroed all ten bytes

 LDA #246               \ Set volumeLevel = -10, which sets the sound level to
 STA volumeLevel        \ medium (-15 is full volume, 0 is silent)

 TSX                    \ Store the stack pointer in startingStack so we can
 STX startingStack      \ restore it when restarting the game

 JSR CallTrackHook      \ Call the hook code in the track file (for Silverstone
                        \ the hook routine is just an RTS, so this does nothing)

IF _ACORNSOFT

                        \ Fall through into the main game loop to start the game

ELIF _SUPERIOR

 LDA #190               \ Call OSBYTE with A = 190, X = %00100000 and Y = 0 to
 LDY #0                 \ configure the digital joystick port on the BBC Master
 LDX #%00100000         \ Compact conversion type to 32-bit conversion (as the
 JSR OSBYTE             \ Superior Software version was released for this
                        \ machine)
                        \
                        \ The configuration does the following:
                        \
                        \   * Bit 7 clear = update channel values from cursor
                        \     keys and/or digital joystick
                        \
                        \   * Bit 6 clear = do not simulate key presses from the
                        \     digital joystick
                        \
                        \   * Bit 5 set = return fixed values to channels 1 and
                        \     2 as follows:
                        \
                        \     Left = &FFFF to channel 1
                        \     Centre (horizontal) = &7FFF to channel 1
                        \     Right = 0 to channel 1
                        \     Down = &FFFF to channel 2
                        \     Centre (vertical) = &7FFF to channel 2
                        \     Up = 0 to channel 2
                        \
                        \   * Bit 4 is unused
                        \
                        \   * Bits 0-3 clear = emulate the analogue speed of
                        \     joystick movement by returning slowly changing
                        \     values related to the joystick movement

 JMP MainLoop           \ Jump to the main game loop to start the game

 EQUB &FF               \ This byte appears to be unused

ORG SuperiorSetupGame   \ Switch back to the original address, so we can
                        \ continue with the assembly

ENDIF

\ ******************************************************************************
\
\       Name: MainLoop (Part 1 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: The main game loop: practice laps
\
\ ------------------------------------------------------------------------------
\
\ This part of the main loop implements practice laps.
\
\ ******************************************************************************

.MainLoop

 LDX #0                 \ Set configStop = 0 so we clear out any existing
 STX configStop         \ stop-related key presses

 JSR InitialiseDrivers  \ Initialise all 20 drivers

 LDX #4                 \ Print "REVS   REVS   REVS" as a double-height header
 JSR PrintHeader        \ at column 0, row 4, with the colours of each letter in
                        \ REVS set to magenta/yellow/cyan/green

 JSR PrintHeaderChecks  \ Print chequered lines above and below the header

 LDX #39                \ Print token 39, which shows a menu with the following
 JSR PrintToken         \ options:
                        \
                        \   1 = PRACTICE
                        \
                        \   2 = COMPETITION

 LDX #2                 \ Fetch the menu choice into X (0 to 1)
 JSR GetMenuOption

 CPX #1                 \ If X >= 1, then the choice was competition, so jump to
 BCS game1              \ game1 to start setting up the competition races

 STX currentPlayer      \ Otherwise X = 0 and the choice was practice, so set
                        \ currentPlayer = 0

 DEX                    \ Set qualifyingTime = 255, so that the time we spend
 STX qualifyingTime     \ practicing is as long as we want

 JSR ResetBestLapTimes  \ Reset the best lap times to 10:00.0 for all drivers

 JSR HeadToTrack        \ Head to the track to choose the wing settings and
                        \ start the practice laps, which the player exits by
                        \ pressing SHIFT and right arrow to restart the game
                        \ (so we don't return from this call)

\ ******************************************************************************
\
\       Name: MainLoop (Part 2 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: The main game loop: competition setup
\
\ ------------------------------------------------------------------------------
\
\ This part of the main loop gets all the general information required for the
\ competition: the race class and the duration of qualifying laps.
\
\ ******************************************************************************

.game1

 LDA #0                 \ Set competitionStarted = 0, to indicate that the
 STA competitionStarted \ competition hasn't started yet (so we still need to
                        \ get the race class, the number of laps, and the
                        \ players' names)

 LDX #21                \ Print token 21, which shows a menu with the following
 JSR PrintToken         \ options:
                        \
                        \   Prompt = SELECT THE CLASS OF RACE
                        \
                        \   1 = Novice
                        \
                        \   2 = Amateur
                        \
                        \   3 = Professional

 LDX #3                 \ Fetch the menu choice into X (0 to 2)
 JSR GetMenuOption

 STX raceClass          \ Set raceClass to the chosen race class (0 to 2)

 JSR SetBestRacingLine  \ Set up the 24 bytes at bestRacingLine according to the
                        \ race class

.game2

 LDX #22                \ Print token 22, which shows a menu with the following
 JSR PrintToken         \ options:
                        \
                        \   Prompt = SELECT DURATION OF QUALIFYING LAPS
                        \
                        \   1 = 5 mins
                        \
                        \   2 = 10 mins
                        \
                        \   3 = 20 mins

 LDX #3                 \ Fetch the menu choice into X (0 to 2)
 JSR GetMenuOption

 LDA timeFromOption,X   \ Set the value of qualifyingTime to 4, 9 or 25, which
 STA qualifyingTime     \ should be the number of minutes of qualifying time
                        \ minus one, but the latter seems to be a bug

\ ******************************************************************************
\
\       Name: MainLoop (Part 3 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: The main game loop: qualifying laps
\
\ ------------------------------------------------------------------------------
\
\ This part of the main loop gets the players' driver names, and heads to the
\ track for their qualifying laps.
\
\ ******************************************************************************

 JSR ResetBestLapTimes  \ Reset the best lap times to 10:00.0 for all drivers

 LDA #20                \ Set currentPlayer = 20, so the first human player will
 STA currentPlayer      \ be number 19, the next one will be 18, and so on

.game3

 DEC currentPlayer      \ Decrement currentPlayer so it points to the next human
                        \ player

 LDX currentPlayer      \ Set X to the new player number

 JSR ResetBestLapTime   \ Reset the best lap time to 10:00.0 for the new player

 LDA competitionStarted \ If competitionStarted = 0, jump to game4 to ask for
 BEQ game4              \ the player's name, as the competition hasn't started
                        \ yet and we are still running qualifying laps

                        \ If we get here then the competition is in full swing,
                        \ so we need to run qualifying laps for all the human
                        \ players

 JSR PrintDriverPrompt  \ Print the "DRIVER ->" prompt and the player's name

 JSR HeadToTrack        \ Head to the track to choose the wing settings and
                        \ drive the qualifying laps, returning here when the
                        \ laps are finished

 LDA currentPlayer      \ If currentPlayer <> lowestPlayerNumber, then we still
 CMP lowestPlayerNumber \ have more qualifying laps to get, so jump back to
 BNE game3              \ game3 for the next player's qualifying laps

                        \ By this point we have all the qualifying times for the
                        \ human players

 LDA #0                 \ Sort the drivers by lap time, putting the results into
 JSR SortDrivers        \ positionNumber and driversInOrder

 JMP game9              \ Jump down to game9 to print the driver table, showing
                        \ the grid positions for the race

.game4

                        \ If we get here then we need to get the player's name,
                        \ as the competition has not yet started

 LDX #23                \ Print token 23, which shows the following prompt:
 JSR PrintToken         \
                        \   ENTER NAME OF DRIVER
                        \
                        \ and a text prompt:
                        \
                        \   > 
                        \     ------------

 JSR GetDriverName      \ Fetch the player's name from the keyboard

 JSR HeadToTrack        \ Head to the track to choose the wing settings and
                        \ start the qualifying laps, returning here when the
                        \ laps are finished

 LDX currentPlayer      \ If currentPlayer = 0 then we have got as many players
 BEQ game5              \ as we can handle (20 of them), so jump to game5 to
                        \ skip asking for another driver

 LDX #27                \ Print token 27, which shows a menu with the following
 JSR PrintToken         \ options:
                        \
                        \   1 = ENTER ANOTHER DRIVER
                        \
                        \   2 = START RACE

 LDX #2                 \ Fetch the menu choice into X (0 to 1)
 JSR GetMenuOption

 CPX #0                 \ If X = 0, then the choice was to enter another driver,
 BEQ game3              \ so jump back to game3 to add the new player and head
                        \ to the track for their qualifying laps

\ ******************************************************************************
\
\       Name: MainLoop (Part 4 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: The main game loop: the competition race
\
\ ------------------------------------------------------------------------------
\
\ This part of the main loop checks the slowest qualifying lap times to see if
\ we should make the game easier.
\
\ ******************************************************************************

.game5

 LDA currentPlayer      \ We have now got all the player names and qualifying
 STA lowestPlayerNumber \ times that we need, so store the player number in
                        \ lowestPlayerNumber, which will contain 19 if there is
                        \ one player, 18 if there are two, and so on
                        \
                        \ Human players take the place of drivers with higher
                        \ numbers, so the first player takes the place of driver
                        \ 19 (the aptly called Dummy Driver, as they never get
                        \ to race), and the second player takes the place of
                        \ driver 18 (Peter Out), the third player replaces
                        \ driver 17 (Rick Shaw) and so on
                        \
                        \ So this not only represents the lowest player number,
                        \ but also the highest non-human driver number (which is
                        \ lowestPlayerNumber - 1)

 LDA #0                 \ Sort the drivers by best lap time, putting the results
 JSR SortDrivers        \ into positionNumber and driversInOrder, so they now
                        \ contain the order of the drivers on the grid for the
                        \ coming race

                        \ We now adjust the class of the race to cater for the
                        \ player's qualifying lap time, which makes things more
                        \ fun for a mixed group of player skills

 LDX #0                 \ Set X to the race class number for Novice

.game6

 LDY driversInOrder+19  \ Set Y to the driver number with the slowest lap time

 CPY lowestPlayerNumber \ If Y < lowestPlayerNumber, then driver Y is one of the
 BCC game8              \ computer-controlled drivers and they have the slowest
                        \ lap time, so jump to game8 as the race class doesn't
                        \ need changing

                        \ Otherwise the slowest lap time is by one of the human
                        \ players, so we now set the race class (i.e. the race
                        \ difficulty setting) according to the figures in the
                        \ track data)

 LDA bestLapSeconds,Y   \ Calculate the slowest lap time minus the time for
 SEC                    \ class X from the track data, starting with the seconds
 SBC trackLapTimeSec,X

 LDA bestLapMinutes,Y   \ And then the minutes
 SBC trackLapTimeMin,X

                        \ Note that for X = 2 (professional), the track data
                        \ figure is 0, so the C flag will always be set

 BCS game7              \ If the slowest lap time is longer than trackLapTimeMin
                        \ from the track data, jump to game7 to consider setting
                        \ the class to X, if it is easier than the current class
                        \
                        \ In other words, if the slowest lap time is really slow
                        \ and is by a human player, this can make the game
                        \ easier if the race class isn't already on Novice
                        \
                        \ For example, for Silverstone:
                        \
                        \   * We will consider setting the class to Novice if
                        \     the longest lap is > 1:51 and by a human player
                        \
                        \   * We will consider setting the class to Amateur if
                        \     the longest lap is <= 1:51 and > 1:41 and by a
                        \     human player
                        \
                        \   * We will consider setting the class to Professional
                        \     if the longest lap is <= 1:41 and by a human
                        \     player

                        \ If we get here, the slowest lap time is quicker than
                        \ the figure from the track data, so we now check the
                        \ next figure from the track data and try again

 INX                    \ Increment X to the next difficulty level

 BNE game6              \ Jump back to game6 to check the next race class (this
                        \ BNE is effectively a JMP as X is never zero)

.game7

 CPX raceClass          \ If X >= raceClass then X is the same or more difficult
 BCS game8              \ than the current setting, so jump to game8 to leave
                        \ the class unchanged

 STX raceClass          \ Otherwise set the race class to the easier class in X

\ ******************************************************************************
\
\       Name: MainLoop (Part 5 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: The main game loop: the competition race
\
\ ------------------------------------------------------------------------------
\
\ This part of the main loop heads to the track to run the actual race. We
\ print the driver table showing the grid positions, and set the grid row for
\ any human drivers. We then start a loop, running a race for each human player,
\ and asking for the number of laps in the race for the first such race. The
\ loop concludes in the next part of the main loop.
\
\ ******************************************************************************

.game8

 LDX raceClass          \ Set X to the race class

 JSR SetBestRacingLine  \ Set up the 24 bytes at bestRacingLine according to the
                        \ race class

 LDX #26                \ Print token 26, which is a double-height header with
 JSR PrintToken         \ the text "STANDARD OF RACE"

 JSR PrintRaceClass     \ Print the race class

 JSR WaitForSpace       \ Print a prompt and wait for SPACE to be pressed

.game9

 LDX #2                 \ Print the driver table, showing lap times, under the
 LDA #0                 \ heading "GRID POSITIONS", so this shows the drivers
 JSR PrintDriverTable   \ in their starting positions on the grid

                        \ We now make a copy of the driversInOrder list into
                        \ driversInOrder2, so we can retrieve it below, and at
                        \ the same time we set the correct grid row for any
                        \ human players, depending on their starting position
                        \ on the grid (there are two cars per grid row)

 LDY #19                \ Set up a counter in Y so we can work through the
                        \ drivers in order, from the back of the grid to the
                        \ front

.game10

 LDA driversInOrder,Y   \ Copy the Y-th positon from driversInOrder to
 STA driversInOrder2,Y  \ driversInOrder2, setting A to the number of the driver
                        \ in position Y

 CMP lowestPlayerNumber \ If A < lowestPlayerNumber, then driver A is one of the
 BCC game11             \ computer-controlled drivers, so jump to game11 to skip
                        \ setting the grid number for the driver

                        \ If we get here then driver A is a human player

 TAX                    \ Set X = the player's driver number

 LDA positionNumber,Y   \ Set A = the position of the player on the grid

 LSR A                  \ Set the driver's grid row to A / 2, so the first two
 STA driverGridRow,X    \ drivers are on grid row 0, then the next two are on
                        \ grid row 1, and so on

.game11

 DEY                    \ Decrement the counter

 BPL game10             \ Loop back until we have saved all the positions

 LDA competitionStarted \ If competitionStarted <> 0, then the competition has
 BNE game12             \ already started, so jump to game12 to skip the lap
                        \ selection process

 LDX #28                \ Print token 28, which shows a menu with the following
 JSR PrintToken         \ options:
                        \
                        \   Prompt = SELECT NUMBER OF LAPS
                        \
                        \   1 = 5 laps
                        \
                        \   2 = 10 laps
                        \
                        \   3 = 20 laps

 LDA #20                \ Set numberOfPlayers = 20 - lowestPlayerNumber
 SEC                    \
 SBC lowestPlayerNumber \ so numberOfPlayers is 1 if there is one player, 2 if
 STA numberOfPlayers    \ there are two players, and so on

 LDX #3                 \ Fetch the menu choice into X (0 to 2)
 JSR GetMenuOption

 LDA lapsFromOption,X   \ Convert the menu choice (0 to 2) into the number of
 STA numberOfLaps       \ laps (5, 10, 20) using the lapsFromOption lookup, and
                        \ store the result in numberOfLaps

 STX lapsMenuOption     \ Store the menu choice (0 to 2) in lapsMenuOption

.game12

 LDA #20                \ We now work our way through the human players so each
 STA currentPlayer      \ one can race in turn, so set currentPlayer to 20 so
                        \ it gets decremented to 19 for the first player

.game13

 DEC currentPlayer      \ Decrement currentPlayer to move on to the next player

 JSR PrintDriverPrompt  \ Print the "DRIVER ->" prompt and the player's name

 LDX #19                \ We now restore the grid positions we saved above, so
                        \ set a counter in X

.game14

 LDA driversInOrder2,X  \ Restore the X-th positon from driversInOrder2 to
 STA driversInOrder,X   \ driversInOrder

 DEX                    \ Decrement the counter

 BPL game14             \ Loop back until we have restored all the positions

 JSR ResetBestLapTimes  \ Reset the best lap times to 10:00.0 for all drivers

 LDA #%10000000         \ Head to the track to choose the wing settings and
 JSR HeadToTrack+2      \ start the race (as bit 7 of A is set), returning here
                        \ when the race is finished

\ ******************************************************************************
\
\       Name: MainLoop (Part 6 of 6)
\       Type: Subroutine
\   Category: Main loop
\    Summary: The main game loop: race points and competition results
\
\ ------------------------------------------------------------------------------
\
\ This part of the main loop processes the points from the race and displays the
\ driver tables, and loops back to the previous part if there are more human
\ players in the race. When all the players have raced, we loop back to part 2
\ for the next race in the championship.
\
\ ******************************************************************************

 LDA #%10000000         \ Sort the drivers by total race time, putting the
 JSR SortDrivers        \ results into positionNumber and driversInOrder

 LDX #5                 \ We now award points to the top six drivers in the
                        \ race, so set a counter in X

.game15

 JSR AwardRacePoints    \ Award points to the driver in race position X

 DEX                    \ Decrement the counter

 BPL game15             \ Loop back until we have awarded points to the top six
                        \ drivers

 LDA #0                 \ Sort the drivers by best lap time, putting the results
 JSR SortDrivers        \ into positionNumber and driversInOrder

 LDX #6                 \ Award a point to the driver with the fastest lap
 JSR AwardRacePoints

.game16

 LDA #%10000000         \ Sort the drivers by total race time, putting the
 JSR SortDrivers        \ results into positionNumber and driversInOrder

 LDX #1                 \ Print the driver table, showing points awarded in the
 LDA #4                 \ last race, under the heading "POINTS", so this shows
 JSR PrintDriverTable   \ the best drivers from the last race, along with the
                        \ points awarded to the fastest six drivers

 LDA #0                 \ Sort the drivers by best lap time, putting the results
 JSR SortDrivers        \ into positionNumber and driversInOrder

 LDX #6                 \ Print the driver table, showing lap times, under the
 LDA #0                 \ heading "BEST LAP TIMES", so this shows the lap times
 JSR PrintDriverTable   \ from the race

 LDA #%01000000         \ Sort the drivers by accumulated points, putting the
 JSR SortDrivers        \ results into positionNumber and driversInOrder

 LDX #3                 \ Set competitionStarted = 3, which is non-zero, so this
 STX competitionStarted \ indicates that the competition has started (so we
                        \ don't get asked to choose the number of laps or player
                        \ names)

 LDA #&88               \ Print the driver table, showing accumulated points,
 JSR PrintDriverTable   \ under the heading "ACCUMULATED POINTS", so this shows
                        \ the cumulative results of all races

 BIT G                  \ If bit 7 of G is clear, then RETURN was pressed, so
 BPL game16             \ jump back to game16 to show the driver tables again

 LDA currentPlayer      \ If currentPlayer <> lowestPlayerNumber, then we still
 CMP lowestPlayerNumber \ have more players to race, so jump back to game13 to
 BNE game13             \ start the next player's race

 JMP game2              \ Jump back to game2 to move on to the next race in the
                        \ competition

\ ******************************************************************************
\
\       Name: HeadToTrack
\       Type: Subroutine
\   Category: Main Loop
\    Summary: Get the wing settings and start a race, practice or qualifying lap
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   HeadToTrack+2       Called with A = %10000000 to start a race, as opposed to
\                       practice or a qualifying lap
\
\ ******************************************************************************

.HeadToTrack

 LDA #%00101000         \ Set A to the value for practice or a qualifying lap
                        \ (this instruction will be skipped when starting a race
                        \ by calling HeadToTrack+2)

 STA raceStarted        \ Set raceStarted to the value of A, so bit 7 gets set
                        \ if this is a race, but is clear for practice or a
                        \ qualifying lap

 STA raceStarting       \ Set raceStarting to the value of A, which will be 128
                        \ if this is a race, so the starting lights get shown
                        \ rand the estrictions of the starting grid (can't move
                        \ the car, timers are disabled) are applied
                        \
                        \ If this not a race then we clear bit 7 of raceStarting
                        \ so the restrictions are not applied

.race1

 JSR GetWingSettings    \ Get the front and rear wing settings from the player

 JSR MainDrivingLoop    \ Call the main driving loop to switch to the custom
                        \ mode, implement the driving part of the game, and
                        \ return here with the screen mode back to mode 7

 BIT configStop         \ If bit 6 of configStop is set then we are returning to
 BVS race1              \ the track after visiting the pits, so loop back to
                        \ race1 to get new wing settings before rejoining the
                        \ driving loop

 BPL race2              \ If bit 7 of configStop is clear then we did not use
                        \ SHIFT and right arrow to exit the main driving loop,
                        \ so jump to race2 to return from the subroutine

                        \ If we get here then bit 6 of configStop is clear and
                        \ bit 7 of configStop is set, which means we presses
                        \ SHIFT and right arrow to exit the main driving loop,
                        \ which is the key combination for resarting the whole
                        \ game

 JSR RestartGame        \ Jump to RestartGame to restart the game, which removes
                        \ the return address from the stack and jumps to the
                        \ main loop, so this call acts like JMP RestartGame

.race2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetMenuOption
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the keyboard for a menu entry number, highlight the choice,
\             show the SPACE bar message and return the choice number
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of entries in the menu
\
\ Returns:
\
\   X                   The chosen option, zero-based (so the first option is 0,
\                       the second option is 1, and so on)
\
\ ******************************************************************************

.GetMenuOption

 LDY #0                 \ Set W = 0, to indicate that we have not yet chosen an
 STY W                  \ option from the menu

 STX U                  \ Store the number of entries in U

.mopt1

 JSR CheckRestartKeys   \ Check whether the restart keys are being pressed, and
                        \ if they are, restart the game (the restart keys are
                        \ SHIFT and right arrow)

 LDY U                  \ We now loop through each valid menu option for this
                        \ menu and check whether the relevant key is being
                        \ pressed, so we set a loop counter in U to start from
                        \ the menu size and loop down to zero

.mopt2

 STY V                  \ Store the loop counter in V so we can retrieve it
                        \ below

IF _ACORNSOFT

 LDX menuKeys,Y         \ Fetch the key number for menu option Y

ELIF _SUPERIOR

 LDX menuKeysSuperior,Y \ Fetch the key number for menu option Y

ENDIF

 JSR ScanKeyboard       \ Scan the keyboard to see if this key is being pressed

 BEQ mopt3              \ If this key is being pressed, jump to mopt3

 LDY V                  \ Retrieve the value of the loop counter

 DEY                    \ Decrement the loop counter to scan for the next menu
                        \ option

 BPL mopt2              \ Loop back to check the key for the next option

 BMI mopt1              \ Loop back to mopt1 to keep checking through the option
                        \ keys (this BMI is effectively a JMP as we just passed
                        \ through a BPL)

.mopt3

 LDY V                  \ Set Y to the menu option that was chosen

 BNE mopt4              \ If Y is non-zero, jump to mopt4 to process the choice

                        \ If we get here, SPACE was pressed

 LDA W                  \ If W = 0 then we have not yet chosen an option from
 BEQ mopt1              \ the menu, so jump back to mopt1 to keep checking for
                        \ key presses, as SPACE is only a valid key press when
                        \ we have chosen an option

                        \ If we get here then we have already chosen an option
                        \ from the menu, and SPACE has been pressed

 LDA #152               \ Poke the mode 7 conceal character into screen memory,
 STA row24_column5      \ to hide row 24 from column 5 onwards, i.e. hide the
                        \ "PRESS SPACE BAR TO CONTINUE" prompt

 LDX G                  \ Set X = G - 1, to return as the zero-based choice
 DEX                    \ number

 RTS                    \ Return from the subroutine

.mopt4

 STY G                  \ Set G to the number of the choice we just made

 LDA W                  \ If W is non-zero, jump to mopt5 to skip the following
 BNE mopt5              \ three instructions

 LDX #30                \ Set X = 30 to pass to PrintToken below

 STX W                  \ Set W = 30, so W is now non-zero and denotes that we
                        \ have made a choice

 JSR PrintToken         \ Print token 30 ("PRESS SPACE BAR TO CONTINUE" in cyan
                        \ at column 5, row 24)

.mopt5

                        \ We now work our way through the menu, setting each
                        \ entry's background colour according to the choice made
                        \ (the chosen entry is set to red, while other entries
                        \ are set to blue)

 LDX #0                 \ Set an offset counter in X to step through the screen
                        \ address of the on-screen number for each menu entry,
                        \ starting at an offset of 0 (the offset is added to
                        \ row18_column5 in the loop below)

 LDY #1                 \ Set a counter in Y to count through the menu entries

.mopt6

 LDA #132               \ Set A to the mode 7 control code for blue, to set as
                        \ the background colour for the unselected menu entries

 CPY G                  \ If Y <> G then this is not the chosen entry, so skip
 BNE mopt7              \ the following instruction to leave A as blue

 LDA #129               \ Set A to the mode 7 control code for red, to set as
                        \ the background colour for the selected menu entry

.mopt7

 STA row18_column5,X    \ Poke the colour in A into screen memory at offset X
                        \ from column 5 on row 18, which is the screen address
                        \ of the number for the first menu entry (so this sets
                        \ the background colour of the current entry to A)

 TXA                    \ Set X = X + 80
 CLC                    \
 ADC #80                \ so X now points to the next menu entry, as 80 is two
 TAX                    \ lines of mode 7 characters, and the menu entries are
                        \ shown on every other line

 INY                    \ Increment the option counter in Y

 CPY U                  \ If Y <= U then loop back to set the background colour
 BCC mopt6              \ for the next option, until we have done all of them
 BEQ mopt6

 BNE mopt1              \ Jump back to mopt1 to keep checking for key presses,
                        \ so we can change the option, or press SPACE to lock in
                        \ our choice (this BNE is effectively a JMP as we just
                        \ passed through a BEQ)

\ ******************************************************************************
\
\       Name: ConvertNumberToBCD
\       Type: Subroutine
\   Category: Maths
\    Summary: Convert a number into binary coded decimal (BCD), for printing
\
\ ------------------------------------------------------------------------------
\
\ This routine converts a number in the range 0 to 19 into a BCD number in the
\ range 1 to 20, so the number can be printed.
\
\ Arguments:
\
\   A                   The number to be converted into BCD (0 to 19)
\
\ Returns:
\
\   A                   The number in BCD (1 to 20)
\
\ ******************************************************************************

.ConvertNumberToBCD

 CMP #10                \ If A < 10, skip the following instruction as A is in
 BCC ibcd1              \ the range 0 to 9, which is the same number in BCD

 ADC #5                 \ A >= 10, so set A = A + 6 (as the C flag is set) to
                        \ convert the number into BCD, like this:
                        \
                        \   * 10 = &0A -> &10 (i.e. 10 in BCD)
                        \   * 11 = &0B -> &11 (i.e. 11 in BCD)
                        \   * 12 = &0C -> &12 (i.e. 12 in BCD)
                        \   * 13 = &0D -> &13 (i.e. 13 in BCD)
                        \   * 14 = &0E -> &14 (i.e. 14 in BCD)
                        \   * 15 = &0F -> &15 (i.e. 15 in BCD)
                        \   * 16 = &10 -> &16 (i.e. 16 in BCD)
                        \   * 17 = &11 -> &17 (i.e. 17 in BCD)
                        \   * 18 = &12 -> &18 (i.e. 18 in BCD)
                        \   * 19 = &13 -> &19 (i.e. 19 in BCD)

.ibcd1

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

 ADC #1                 \ Increment A in BCD mode, so the result is in the
                        \ range 1 to 20

 CLD                    \ Clear the D flag to switch arithmetic to normal

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintDriverTable
\       Type: Subroutine
\   Category: Text
\    Summary: Print the table of drivers
\
\ ------------------------------------------------------------------------------
\
\ The driver table consists of the following:
\
\   * A header, as specified by the argument in X
\
\   * A table with one row for each driver, showing a number, a driver name and
\     a third column as specified by the argument in A
\
\   * A "PRESS SPACE TO CONTINUE" prompt below the table
\
\ If the table is being shown after practice or qualifying, the drivers are
\ shown in driver order, from 1 to 20, but if it is shown after a race, the
\ first column shows the numbers from the positionNumber table, the second
\ column shows the drivers in the order that they appear in the driversInOrder
\ list, and the race class is printed above the table.
\
\ The routine also waits for SPACE or RETURN to be pressed before returning.
\
\ Arguments:
\
\   X                   The number of the token to print as the header (see
\                       PrintHeader for more details):
\
\                         * 1 = "POINTS"
\
\                         * 2 = "GRID POSITIONS"
\
\                         * 3 = "ACCUMULATED POINTS"
\
\                         * 6 = "BEST LAP TIMES"
\
\   A                   Defines what to show in the third column in the table:
\
\                         * 0 = lap times
\
\                         * 4 = points awarded in the last race
\
\                         * &88 = accumulated points
\
\   positionNumber      A list of position numbers (for race tables only), which
\                       contains the numbers 0 to 19 in sequence, with tied
\                       positions represented by shared position numbers
\
\ Returns:
\
\   G                   Bit 7 is clear if RETURN was pressed, set if SPACE was
\                       pressed
\
\ ******************************************************************************

.PrintDriverTable

 PHA                    \ Store the value of A on the stack so we can retrieve
                        \ it below

 AND #%00001111         \ Set colourScheme to the lower nibble of A, which
 STA colourScheme       \ contains the colour scheme to use for the table, so we
                        \ can pass it to SetRowColours below

 JSR PrintHeader        \ Print the header specified in X

 LDY #0                 \ We are about to print a table containing 20 rows, one
                        \ for each driver, so set a row counter in Y

.dtab1

 STY rowCounter         \ Store the row counter in rowCounter

 LDA #%00000000         \ Set G = 0 so the call to Print2DigitBCD below will
 STA G                  \ print the second digit and will not print leading
                        \ zeroes when printing the driver number

 JSR SetRowColours      \ Set the colours in token 31 according to the colour
                        \ scheme we stored in colourScheme above, so they can be
                        \ used to set the colours of each table cell

 LDX #32                \ Print token 32, which prints two spaces and backspaces
 JSR PrintToken         \ followed by token 31, so this sets up the colours for
                        \ the first column

 LDY rowCounter         \ Set Y to the table row number

 LDA positionNumber,Y   \ Set A to the positionNumber for this row, to show in
                        \ the first column

 BIT raceStarted        \ If bit 7 of raceStarted is set, that means the results
 BMI dtab2              \ are from a finished race, so jump to dtab2 to skip the
                        \ following instruction, so we print the numbers from
                        \ positionNumber in the first column

 TYA                    \ Set A to the row number, so we print the row number in
                        \ the first column (i.e. 1 to 20, as )

.dtab2

 JSR ConvertNumberToBCD \ Convert the number in A into binary coded decimal
                        \ (BCD), adding 1 in the process

 JSR Print2DigitBCD     \ Print the binary coded decimal (BCD) number in A, and
                        \ because we set G to 0 above, it will print the second
                        \ digit and will not print leading zeroes

 LDX #31                \ Print token 31, which prints two spaces and sets the
 JSR PrintToken         \ colours as configured above, so this inserts a black
                        \ gap between the first and second table columns

 LDY rowCounter         \ Set Y to the table row number

 JSR PrintPositionName  \ Print the name of the driver in position Y, so row Y
                        \ of the table contains the details of the driver in
                        \ position Y, and set driverPrinted to the number of the
                        \ driver that was printed

 LDX #31                \ Print token 31, which prints two spaces and sets the
 JSR PrintToken         \ colours as configured above, so this inserts a black
                        \ gap between the second and third table columns

 LDX driverPrinted      \ Set X to the number of the driver we just printed, so
                        \ the call to PrintTimer prints the lap time for driver
                        \ X

 PLA                    \ If the value of A that we stored on the stack at the
 PHA                    \ start of the routine is non-zero, jump to dtab3 to
 BNE dtab3              \ skip the following

                        \ If we get here then the value of A passed to the
                        \ routine was 0, so we now print the third column
                        \ containing the driver's best lap time

 LDA #%00100110         \ Print the lap time for driver X in the following
 JSR PrintTimer         \ format:
                        \
                        \   * %00 Minutes: No leading zeroes, print both digits
                        \   * %10 Seconds: Leading zeroes, print both digits
                        \   * %0  Tenths: Print tenths of a second
                        \   * %11 Tenths: Leading zeroes, no second digit

 JMP dtab6              \ Jump down to dtab6 to move on to the next table row

.dtab3

                        \ If we get here then the value of A passed to the
                        \ routine was non-zero (i.e. 4 or &88)

 BMI dtab4              \ If bit 7 of A is set (i.e. A = &88), jump to dtab4

                        \ If we get here then the value of A passed to the
                        \ routine was 4, so we now print the third column
                        \ containing the points awarded to the driver in the
                        \ last race
                        \
                        \ Only the top six drivers from each race get points,
                        \ so we print a blank column for the other drivers

 LDA rowCounter         \ Set A = rowCounter + 20
 CLC
 ADC #20

 CMP #26                \ Set X = A, and if A < 26 (so rowCounter is 0 to 5),
 TAX                    \ jump to dtab5 to print the race points
 BCC dtab5

 LDA #7                 \ A >= 26 (so rowCounter is 6 to 19), so print seven
 JSR PrintSpaces        \ spaces in the last column

 BEQ dtab6              \ Jump to dtab6 to move on to the next table row (this
                        \ BEQ is effectively a JMP, as PrintSpaces sets the Z
                        \ flag)

.dtab4

                        \ If we get here then the value of A passed to the
                        \ routine had bit 7 set, so it must have been &88, so
                        \ we now print the third column containing the driver's
                        \ accumulated points

 LDA #%00101000         \ Set G, so the next three calls to Print2DigitBCD do
 STA G                  \ the following:
                        \
                        \   * No leading zeroes, print second digit
                        \   * Leading zeroes, print second digit
                        \   * Leading zeroes, print second digit
                        \
                        \ The second and third two calls to Print2DigitBCD are
                        \ in the Print4DigitBCD routine below

 LDA totalPointsTop,X   \ If the top byte of the driver's total points is zero,
 BEQ dtab5              \ jump to dtab5

 JSR Print2DigitBCD     \ Otherwise print the top byte of the driver's total
                        \ points, which is a binary coded decimal (BCD) number

 LDA totalPointsHi,X    \ Fetch the high byte of the driver's total points, to
                        \ pass to Print4DigitBCD

 JSR Print4DigitBCD     \ Print both the high and low bytes of the driver's
                        \ total points in full, followed by a space

 JMP dtab6              \ Jump to dtab6 to move on to the next table row

.dtab5

 JSR Print234DigitBCD   \ Print the high and low bytes of the driver's total
                        \ points, replacing leading zeroes with spaces, and
                        \ followed by a space

.dtab6

                        \ If we get here then we have finished printing the
                        \ current table row, so now we move on to the next row

 LDY rowCounter         \ Set Y to the table row number

 INY                    \ Increment the table row number

 CPY #20                \ Loop back to print the next table row, until we have
 BNE dtab1              \ printed all 20

 LDA #3                 \ Print three spaces to pad out the final row
 JSR PrintSpaces

 LDA #156               \ Print ASCII 156 to switch to a black background
 JSR OSWRCH

 LDA raceStarted        \ If bit 7 of raceStarted is clear, that means the
 BPL dtab7              \ results are from qualifying or practice, so jump to
                        \ dtab7 to skip the following so we do not print the
                        \ race class above ths table

                        \ We now print the race class and number of laps in the
                        \ gap between the page header and the top of the table

 LDX #49                \ Print token 49, which moves the cursor to column 9,
 JSR PrintToken         \ row 2

 JSR PrintRaceClass     \ Print the race class

 LDA lapsMenuOption     \ Set the configurable token in token 50 to 218 plus the
 CLC                    \ figure in lapsMenuOption, to give 218, 219 or 220,
 ADC #218               \ which correspond to the tokens for " 5", "10" and "20"
 STA token50+3

 LDX #50                \ Print token 50, which is "n laps", where n is the
 JSR PrintToken         \ number of laps we just configured

.dtab7

 PLA                    \ Retrieve the value of A that we stored on the stack at
                        \ the start of the routine

 JSR WaitForSpaceReturn \ Print a prompt and wait for SPACE or RETURN to be
                        \ pressed, depending on bit 7 of A

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintNearestDriver
\       Type: Subroutine
\   Category: Text
\    Summary: Print a driver's name in the "In front" or "Behind" slot in the
\             header
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The position of the driver whose name we print
\
\   A                   The pixel row on which to print the driver name:
\
\                         * 24 = the first line of text at the top of the screen
\                                (i.e. the "In front:" section of token 43)
\
\                         * 33 = the second line of text at the top of the
\                                screen (i.e. the "Behind:" section of token 44)
\
\ ******************************************************************************

.PrintNearestDriver

 STA yCursor            \ Move the cursor to the pixel row in A

 LDA #27                \ Move the cursor to character column 27
 STA xCursor

                        \ Fall through into PrintPositionName to print the
                        \ driver name at column 27 on the specified row

\ ******************************************************************************
\
\       Name: PrintPositionName
\       Type: Subroutine
\   Category: Text
\    Summary: Print the name of the driver in a specific position in the driver
\             position list
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The position of the driver whose name we print
\
\ Returns:
\
\   driverPrinted       The number of the driver that we printed
\
\ ******************************************************************************

.PrintPositionName

 LDX driversInOrder,Y   \ Set X to the number of the driver in position Y

 STX driverPrinted      \ Store the driver number in driverPrinted, so we can
                        \ return it

 JSR GetDriverAddress   \ Set (Y A) to the address of driver X's name

 JSR PrintDriverName    \ Print the name of the driver at address (Y A)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintDriverPrompt
\       Type: Subroutine
\   Category: Text
\    Summary: Print the "DRIVER ->" prompt and a driver's name, to show whose
\             turn it is next when playing a multi-player game
\
\ ******************************************************************************

.PrintDriverPrompt

 LDX #29                \ Print token 29, which clears the screen, displays the
 JSR PrintToken         \ F3 header, and shows a " DRIVER -> " prompt

 LDX currentPlayer      \ Set X to the driver number of the current player

 JSR GetDriverAddress   \ Set (Y A) to the address of driver X's name

 JSR PrintDriverName    \ Print the name of the driver at address (Y A)

 JSR WaitForSpace       \ Print a prompt and wait for SPACE to be pressed

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: AddRacePoints
\       Type: Subroutine
\   Category: Driving
\    Summary: Add the race points to the driver's total points
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The race position whose points should be added
\
\   Y                   The driver who receives those points, i.e. who has then
\                       added to their total accumulated points
\
\ ******************************************************************************

.AddRacePoints

 SED                    \ Set the D flag to switch arithmetic to Binary Coded
                        \ Decimal (BCD)

 LDA totalPointsLo,Y    \ Add (0 racePointsHi racePointsLo) for position X to
 CLC                    \ (totalPointsTop totalPointsHi totalPointsLo) for
 ADC racePointsLo,X     \ driver Y, starting with the low bytes
 STA totalPointsLo,Y

 LDA totalPointsHi,Y    \ And then the high bytes
 ADC racePointsHi,X
 STA totalPointsHi,Y

 LDA totalPointsTop,Y   \ And then the top bytes
 ADC #0
 STA totalPointsTop,Y

 CLD                    \ Clear the D flag to switch arithmetic to normal

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ResetTrackLines
\       Type: Subroutine
\   Category: Graphics
\    Summary: Reset the track lines below the horizon in the track view
\
\ ------------------------------------------------------------------------------
\
\ This routine does the following:
\
\   * Set horizonLine+1 bytes at rightGrassStart to &80
\
\   * Set horizonLine+1 bytes at leftVergeStart to &80
\
\   * Set horizonLine+1 bytes at rightVergeStart to &80
\
\   * Set horizonLine+1 bytes at leftTrackStart to &80
\
\   * Set 80 bytes at backgroundColour to 0
\
\ ******************************************************************************

.ResetTrackLines

 LDX horizonLine        \ We start by setting horizonLine+1 bytes at
                        \ leftVergeStart, rightGrassStart rightVergeStart and
                        \ leftTrackStart to &80, so set a byte counter in X

 LDA #&80               \ Set A = &80 to use as our reset value

.resl1

 STA leftVergeStart,X   \ Set the X-th byte of leftVergeStart to &80

 STA leftTrackStart,X   \ Set the X-th byte of leftTrackStart to &80

 STA rightVergeStart,X  \ Set the X-th byte of rightVergeStart to &80

 STA rightGrassStart,X  \ Set the X-th byte of rightGrassStart to &80

 DEX                    \ Decrement the byte counter

 BPL resl1              \ Loop back until we have zeroed all horizonLine+1 bytes

 LDX #79                \ We now zero the 80 bytes at backgroundColour, so set a
                        \ byte counter in X

 LDA #0                 \ Set A = 0 to use as our zero value

.resl2

 STA backgroundColour,X \ Zero the X-th byte of backgroundColour

 DEX                    \ Decrement the byte counter

 BPL resl2              \ Loop back until we have zeroed all 80 bytes

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetDriverName
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Fetch a player's name from the keyboard
\
\ ******************************************************************************

.GetDriverName

 LDX currentPlayer      \ Set X to the driver number of the current player

 JSR GetDriverAddress   \ Set (Y A) to the address of driver X's name

 LDX #12                \ Fetch a string of length 12 from the keyboard and
 JSR GetTextInput       \ store it in (Y A), padding the string out with spaces
                        \ if required

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawCars
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw all the car objects, with four objects for the closest car in
\             front of us
\
\ ******************************************************************************

.DrawCars

 LDX currentPosition    \ Set X to the current player's position, so we work our
                        \ way backwards through the pack, starting with the car
                        \ behind the current player, and wrapping round to the
                        \ cars in front, working our way towards the player's
                        \ car in the order in which they should be drawn (with
                        \ distant cars first)

 BPL cars2              \ If X is positive, jump to cars2 to skip the following
                        \ instruction

.cars1

 JSR DrawCarInPosition  \ Draw the car in position X

.cars2

 JSR GetPositionBehind  \ Set X to the number of the position behind position X,
                        \ so we work our way back through the pack

 CPX positionAhead      \ Loop back to cars1 until we have reached the position
 BNE cars1              \ ahead of the current player

                        \ We now draw the car that's just in front of us, which
                        \ is made up of four objects that can be skewed to make
                        \ it look like the car is steering

 LDX #22                \ The four objects are the front tyres, body, rear tyres
                        \ and rear wing, so set up a counter in X to work
                        \ through the first three in the order 22, 21 and 20, to
                        \ pass to DrawCarOrSign in turn so they get drawn in
                        \ that order: front tyres, body/helmet and rear tyres

.cars3

 STX xStore2            \ Store X in xStore2 so it gets preserved through
                        \ the call to DrawCarOrSign

 JSR DrawCarOrSign      \ Draw the specified part of the four-object car just
                        \ in front of us

 DEX                    \ Decrement the object counter

 CPX #20                \ Loop back until we have drawn all three objects
 BCS cars3

 LDX positionAhead      \ Set X to the position ahead of the current player

 JSR DrawCarInPosition  \ Draw the car in position X, which draws the rear wing
                        \ as the last (and closest) of the four objects

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: dashData42
\       Type: Variable
\   Category: Dashboard
\    Summary: Contains part of the dashboard image that gets moved into screen
\             memory
\
\ ******************************************************************************

ORG &6C00

.dashData42

 SKIP 2853

\ ******************************************************************************
\
\       Name: UpdateMirrors
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Update the wing mirrors to show any cars behind us
\
\ ******************************************************************************

ORG &7B00

.UpdateMirrors

 LDY positionBehind     \ Set Y to the position of the driver behind us

 LDX driversInOrder,Y   \ Set X to the number of the driver behind us

 LDA objectStatus,X     \ If the object status byte for the car behind us has
 BMI upmi1              \ bit 7set, then it is hidden, so jump to upmi1 to clear
                        \ the mirror (as V will be set to a negative value, and
                        \ this will never match any values from mirrorSegment,
                        \ as all the mirrorSegment entries are positive)

                        \ We now calculate the size of the car to draw in the
                        \ mirror (in other words, the height of the block we
                        \ draw)
                        \
                        \ We do this by taking the scale factor for the driver
                        \ behind and dividing by 8 to give us half the number of
                        \ pixel lines to draw, in T
                        \
                        \ We then calculate the upper and lower offsets within
                        \ the mirror segment, by taking the offset of the middle
                        \ row in the segment, and adding and subtracting T to
                        \ give us T rows either side of &B6 in TT and N
                        \
                        \ We then pass N and TT (the latter via A) into the
                        \ DrawCarInMirror routine

 LDA objectScaleUp,X    \ Set A = the scale factor (i.e. size) for the driver
                        \ behind

 LSR A                  \ Set T = A / 8
 LSR A                  \       = objectScaleUp / 8
 LSR A
 STA T

 CLC                    \ Set TT = &B6 + T
 ADC #&B6
 STA TT

 LDA #&B6               \ Set N = &B6 - T
 SEC
 SBC T
 STA N

                        \ Next we calculate the mirror segment that the car
                        \ should appear in, based on the objRotationHi value
                        \ for the car, and playerRotationHi, storing the result
                        \ in A
                        \
                        \ This will then be matched with the values in
                        \ mirrorSegment to see which segment to update

 LDA objRotationHi,X    \ Set A = objRotationHi for the driver behind

 SEC                    \ Set A = (A - playerRotationHi - 4) / 8
 SBC playerRotationHi   \       = (objRotationHi - playerRotationHi - 4) / 8
 SEC
 SBC #4
 LSR A
 LSR A
 LSR A

.upmi1

 STA V                  \ Set V = A

                        \ So by this point:
                        \
                        \  * V is negative if there is no car in the mirror
                        \
                        \  * Otherwise V is potentially a mirror segment number
                        \    (and if it is, we draw the car in that segment
                        \    below)

 LDY #5                 \ We now loop through the six mirror segments, either
                        \ clearing or drawing each of them, so we set up a loop
                        \ counter in Y to count from 5 to 0

.upmi2

 LDA V                  \ If V matches this segment's mirrorSegment value, then
 CMP mirrorSegment,Y    \ we can see a car in this segment, so jump to upmi3 to
 BEQ upmi3              \ set A = TT (which we calculated above to denote the
                        \ size of the car) and send this to mirrorContents and
                        \ DrawCarInMirror

                        \ If we get here then we can't see a car in this mirror
                        \ segment, so we need to clear the mirror to white

 LDA mirrorContents,Y   \ If this segment's mirrorContents value is 0, then
 BEQ upmi5              \ there is no car being shown in this segment, so jump
                        \ to upmi5 to move on to the next segment, as the
                        \ mirror segment is already clear

 LDA #0                 \ Otherwise we need to clear this segment, so set A = 0
 BEQ upmi4              \ and jump to upmi4 to send this to mirrorContents and
                        \ DrawCarInMirror (this BEQ is effectively a JMP as A is
                        \ always zero)

.upmi3

 LDA TT                 \ Set A = TT to store in mirrorContents and pass to
                        \ DrawCarInMirror

.upmi4

 STA mirrorContents,Y   \ Store A in the Y-th entry in mirrorContents, which
                        \ will be zero if there is no car in this mirror
                        \ segment, non-zero if there is

 JSR DrawCarInMirror    \ Draw the car in the specified mirror segment, between
                        \ the upper and lower offsets in A and N

.upmi5

 DEY                    \ Decrement the loop counter

 BPL upmi2              \ Loop back until we have looped through 5 to 0

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ShowStartLights
\       Type: Subroutine
\   Category: Graphics
\    Summary: Show the lights at the start of the race
\
\ ------------------------------------------------------------------------------
\
\ The lights at the start of the race follow this patern:
\
\   * The lights are initially off, so they show as three lights with a white
\     border and black interior.
\
\   * Once we have started our engine, the timer starts and after a pause the
\     lights turn blue. During this time we can't move, but we can rev the
\     engine.
\
\   * After another pause, the lights turn green and we can start the race.
\
\   * After another pause, the lights disappear.
\
\ This is implemented by the counter in raceStarting, which works like this.
\
\ When a race is about to start, raceStarting is set to 128, and stays on this
\ value until the engine is started, at which point it starts to count down,
\ with one tick per iteration of the main loop, working through the following
\ sequence:
\
\   * 128 = show black lights, engine not yet started
\
\   * Start counting down from 240 once engine starts
\
\   * 240-192 = show black lights
\
\   * 191-161 = show blue lights
\
\   * 160 = keep showing blue lights and stop counting down until main loop
\           counter is a multiple of 64
\
\   * Start counting down from 40 once loop counter is a multiple of 64
\
\   * 40-1 = show green lights
\
\   * 0 = show no lights (race has started)
\
\ ******************************************************************************

.ShowStartLights

 LDA raceStarted        \ If bit 7 of raceStarted is clear then this is either
 BPL star9              \ a practice or qualifying lap, so jump to star9 to
                        \ return from the subroutine, as there is no need for
                        \ starting lights

 LDX raceStarting       \ If raceStarting = 0, then the race is not in the
 BEQ star9              \ process of starting (i.e. it's already started), so
                        \ jump to star9 to return from the subroutine, as there
                        \ is no need for starting lights

 BPL star2              \ If raceStarting <= 127, jump to star2 to decrement
                        \ the raceStarting counter (this instruction isn't
                        \ necessary as the following comparison covers the same
                        \ test, so this branch could be removed)

 CPX #128               \ If raceStarting <> 128, jump to star2 to decrement
 BNE star2              \ the raceStarting counter

                        \ If we get here then raceStarting = 128, which means
                        \ the lights are showing as black, and we are waiting
                        \ for the engine to start to continue the countdown

 BIT engineStatus       \ If bit 7 of engineStatus is clear, then the engine is
 BPL star1              \ not yet on, so jump to star1 to keep the value of X
                        \ (and therefore the value of raceStarting) at 128, as
                        \ we only move on to the second stage once we have
                        \ started our engine

 LDX #240               \ If we get here then the engine has started, so set
                        \ X = 240 to store as the updated value of raceStarting,
                        \ which can now start ticking down

.star1

                        \ If we get here then the lights are off

 LDY #0                 \ Set Y to the EOR pattern that doesn't flip any pixels,
                        \
                        \ See star8 below for an explanation of the EOR pattern

 LDA #%10000000         \ Set A to a pixel byte containing four pixels with
                        \ colours 2, 0, 0, 0 (white, black, black, black)

 BNE star6              \ Jump to star6 to store the updated value of X in
                        \ raceStarting and draw the lights (this BNE is
                        \ effectively a JMP as A is never zero)

.star2

                        \ If we get here, then X is non-zero and X <> 128, so
                        \ the engine has started and the light sequence has
                        \ started

 CPX #160               \ If X = 160, jump to star4 to consider switching from
 BEQ star4              \ the blue lights to the green lights

 DEX                    \ Decrement X

 BPL star5              \ If X is positive, jump to star5 to display the green
                        \ lights

 CPX #192               \ If X >= 192, jump to star1
 BCS star1

.star3

                        \ If we get here then the lights are blue (the second
                        \ stage)

 LDA #%10100101         \ Set A to a pixel byte containing four pixels with
                        \ colours 2, 1, 2, 1 (white, blue, white, blue)

 LDY #%01110111         \ Set Y to the EOR pattern that flips the above to
                        \ %11010010, i.e. colours 2, 2, 1, 2 (white, white,
                        \ blue, white)
                        \
                        \ See star8 below for an explanation of the EOR pattern

 BNE star6              \ Jump to star6 to store the updated value of X in
                        \ raceStarting and draw the lights (this BNE is
                        \ effectively a JMP as A is never zero)

.star4

 LDA mainLoopCounterLo  \ If mainLoopCounterLo mod 64 <> 0, which will be true
 AND #63                \ for 63 out of 64 iterations round the main loop, jump
 BNE star3              \ to star3 to display the blue lights

                        \ Otherwise it is time to switch on the green lights

 LDX #40                \ Set X = 40

.star5

                        \ If we get here then the lights are green (the third
                        \ and final stage)

 LDA #%11110010         \ Set A to a pixel byte containing four pixels with
                        \ colours 2, 2, 3, 2 (white, white, green, white)

 LDY #%00000101         \ Set Y to the EOR pattern that flips the above to
                        \ %11110111, i.e. colours 2, 3, 3, 3 (white, green,
                        \ green, green)
                        \
                        \ See star8 below for an explanation of the EOR pattern

.star6

 STX raceStarting       \ Store the updated value of X in raceStarting

                        \ We now draw the lights, starting with the white border
                        \ lines, and then the lights themselves using the pixel
                        \ byte in A and the EOR pattern in Y
                        \
                        \ We only need to draw the left set of lights, as the
                        \ screen buffer will replicate the other two sets to the
                        \ right
                        \
                        \ The whole light takes up ten pixel rows: two rows for
                        \ the top edge, six rows for the light bulb, and another
                        \ two rows for the bottom edge

 PHA                    \ Store the pixel byte in A on the stack, so we can
                        \ retrieve it below when drawing the lights

 STY T                  \ Store the EOR pattern in T, so we can retrieve it when
                        \ drawing the lights

 LDA #%11110000         \ Set A to a pixel byte containing four pixels with
                        \ colours 2, 2, 2, 2 (white, white, white, white), for
                        \ drawing the edges, which we actually draw as a full
                        \ block of white, and then fill in the centre later

 LDX #9                 \ The light contains ten pixel rows, so set a row
                        \ counter in X

.star7

 STA dashData37+36,X    \ Store the X-th row of the light in the screen buffer,
                        \ in dash data block 37 (the screen drawing routine will
                        \ replicate the light in blocks 38 and 39)

 DEX                    \ Decrement the pixel row counter

 BPL star7              \ Loop back until we have drawn all ten rows of the
                        \ light

 PLA                    \ Set A to the pixel byte for the lights that we stored
                        \ on the stack above

 LDX #5                 \ The central bulb of the light is six pixel rows, so
                        \ set a row counter in X

.star8

 STA dashData37+38,X    \ Store the X-th row of the light in the screen buffer,
                        \ again in dash data block 37, starting two pixel rows
                        \ after the edge that we drew above

 EOR T                  \ Flip the pixels by EOR'ing with T, so the pattern of
                        \ the bulb pixels flips with each row required
                        \
                        \ This means the green light looks like this:
                        \
                        \    white, white, green, white      ..x.
                        \    white, green, green, green      .xxx
                        \    white, white, green, white      ..x.
                        \    white, green, green, green      .xxx
                        \    white, white, green, white      ..x.
                        \    white, green, green, green      .xxx
                        \
                        \ and the blue light looks like this:
                        \
                        \   white, blue,  white, blue        .x.x
                        \   white, white, blue,  white       ..x.
                        \   white, blue,  white, blue        .x.x
                        \   white, white, blue,  white       ..x.
                        \   white, blue,  white, blue        .x.x
                        \   white, white, blue,  white       ..x.
                        \
                        \ The EOR pattern for the black lights is 0, so there is
                        \ no flipping and every row is the same:
                        \
                        \   white, black, black, black       .xxx
                        \   white, black, black, black       .xxx
                        \   white, black, black, black       .xxx
                        \   white, black, black, black       .xxx
                        \   white, black, black, black       .xxx
                        \   white, black, black, black       .xxx

 DEX                    \ Decrement the pixel row counter

 BPL star8              \ Loop back until we have drawn all six rows of the
                        \ bulb

.star9

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintTimer
\       Type: Subroutine
\   Category: Text
\    Summary: Print the specified timer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The lap time to print:
\
\                         * 0 to 19: Lap time for the specified driver
\
\                         * 20 = the clock timer
\                                (clockMinutes clockSeconds clockTenths)
\
\                         * 21 = the lap timer
\                                (lapMinutes lapSeconds lapTenths)
\
\   A                   Flags to control how the time is printed:
\
\                         * Bit 7: clear = do not print leading zeroes in mins
\                                  set = print leading zeroes in mins
\
\                         * Bit 6: clear = print second digit in mins
\                                  set = do not print second digit in mins
\
\                         * Bit 5: clear = do not print leading zeroes in secs
\                                  set = print leading zeroes in secs
\
\                         * Bit 4: clear = print second digit in secs
\                                  set = do not print second digit in secs
\
\                         * Bit 3: clear = print tenths of a second
\                                  set = do not print tenths of a second
\
\                         * Bit 2: clear = do not print leading zeroes in tenths
\                                  set = print leading zeroes in tenths
\
\                         * Bit 1: clear = print second digit in tenths
\                                  set = do not print second digit in tenths
\
\ ******************************************************************************

.PrintTimer

 STA G                  \ Store A in G so we can check the value of bit 7 below

 LDA bestLapMinutes,X   \ Print the number of minutes in driver X's best lap
 JSR Print2DigitBCD     \ time

 LDA #&3A               \ Print ":"
 JSR PrintCharacter

 LDA bestLapSeconds,X   \ Print the number of seconds in driver X's best lap
 JSR Print2DigitBCD     \ time

 ASL G                  \ If bit 7 of G is set, we do not want to print tenths
 BCS plap1              \ of a second, so jump to plap1 to return from the
                        \ subroutine

 LDA #&2E               \ Print "."
 JSR PrintCharacter

 LDA bestLapTenths,X    \ Print the number of tenths of a second in driver X's
 JSR Print2DigitBCD     \ best lap time

.plap1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawTrackView (Part 4 of 4)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Revert all the code modifications made by the DrawTrackView
\             routine
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ******************************************************************************

.view19

 LDA view3+1            \ Modify the instruction at view20 to use the low byte
 STA view20+1           \ of the address from view3
                        \
                        \ In part 2 we modified the instruction at view3 to
                        \ revert the specified instruction back to STA (P),Y,
                        \ ready for a loop-back that never happened, so view20
                        \ will now revert this change instead

 LDA view8+1            \ Modify the instruction at view21 to use the low byte
 STA view21+1           \ of the address from view8
                        \
                        \ In part 3 we modified the instruction at view8 to
                        \ revert the specified instruction back to STA (P),Y,
                        \ ready for a loop-back that never happened, so view21
                        \ will now revert this change instead

 LDA view14+1           \ Modify the instruction at view22 to use the low byte
 STA view22+1           \ of the address from view14
                        \
                        \ In part 3 we modified the instruction at view14 to
                        \ revert the specified instruction back to STA (P),Y,
                        \ ready for a loop-back that never happened, so view22
                        \ will now revert this change instead

 LDA #&91               \ Set A to the opcode for the STA (P),Y instruction

.view20

 STA DrawTrackBytes+15  \ Revert the instruction that view3 would have reverted

.view21

 STA DrawTrackBytes+15  \ Revert the instruction that view8 would have reverted

.view22

 STA byte2+15           \ Revert the instruction that view14 would have reverted

 LDA #&E0               \ Set A to the opcode for the CPX #44 instruction

 STA byte3              \ Revert the instruction at byte3 to CPX #44

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawTrackView (Part 1 of 4)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the top part of the track view using the data in the dash
\             data blocks
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ******************************************************************************

.DrawTrackView

 LDA #0                 \ Set (Q P) = &6700 and (S R) = &6800, ready to pass to
 STA P                  \ the DrawTrackLine routine (so the track view gets
 STA R                  \ drawn at the correct place on screen, from &6701
 LDX #&67               \ onwards, as the first line is drawn at (Q P) + 1)
 STX Q
 INX
 STX S

 LDX #79                \ Set X = 79, to point to the first byte to draw from
                        \ each dash data block (i.e. the byte at the end of the
                        \ data block, at offset 79)

 JSR DrawTrackLine      \ Draw one-pixel high lines that correspond to dash data
                        \ offsets 79 to 44, returning from the subroutine after
                        \ drawing the line specified by offset X = 44 (so this
                        \ draws all the lines from the top of the track view,
                        \ down to the line just above the top of the dashboard)

 JMP view1              \ Jump to part 2 to draw the rest of the track view from
                        \ offsets 43 to 3, modifying the code so it draws the
                        \ rest of the lines around the shape of the dashboard

\ ******************************************************************************
\
\       Name: DrawTrackLine (Part 2 of 2)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw a pixel line across the screen in the track view
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ******************************************************************************

.prow2

                        \ At this point, X contains the offset within the dash
                        \ data of the pixel line to be drawn across the screen

 LDA backgroundColour,X \ Fetch the colour of the first byte on the line from
 AND #%00000011         \ the X-th entry in backgroundColour (bits 0 to 2)
 TAY

 LDA colourPalette,Y    \ Set A to logical colour Y from the colour palette,
                        \ to use as the first byte on the line

                        \ Fall through into DrawTrackBytes to draw the pixel
                        \ bytes that make up the line we want to draw
                        \
                        \ If we are drawing the lines above the top of the
                        \ dashboard, then the following then loops back to the
                        \ start of the DrawTrackLine routine to keep drawing
                        \ lines until we do reach the top of the dashboard, at
                        \ which point we return from the DrawTrackLine routine
                        \ to part 2 of DrawTrackView, which modifies the code to
                        \ draw subsequent lines around the shape of the
                        \ dashboard

\ ******************************************************************************
\
\       Name: DRAW_BYTE
\       Type: Macro
\   Category: Graphics
\    Summary: Draw a pixel byte as part of a horizontal line when drawing the
\             track view
\
\ ------------------------------------------------------------------------------
\
\ This routine draws a row of four pixels (i.e. one byte) as part of the track
\ view.
\
\ The track view is drawn one line at a time, with each line being one pixel
\ high. Each of these lines is drawn as a sequence of bytes, with each byte
\ containing four pixels.
\
\ Each macro instance draws one pixel byte into screen memory, so that's one
\ four-pixel block within the horizontal line. So the full sequence of macros,
\ from DRAW_BYTE 0 through DRAW_BYTE 39, draws a one-pixel high line across
\ the full width of the screen. In other words, each DRAW_BYTE macro draws a
\ character block's worth of line, as the screen is 40 character blocks wide.
\
\ Each macro instance draws one pixel byte, from offset X within dash data block
\ I%, into screen memory. The offset X is decremented for each run through the
\ sequence of macros, as data is stored at the end of each dash data block. So
\ as each pixel line is drawn, moving down the screen, X decrements down from 79
\ (the start of each dash data block) as we work our way through the data.
\
\ The destination address in screen memory for the data is governed by (Q P),
\ which points to the address of the pixel byte to update in the first byte
\ (i.e. the address of the first pixel in the line across the screen).
\
\ If the dash data byte is zero, then the current value of A is stored in screen
\ memory (i.e. the same value that was stored in the previous byte).
\
\ If the dash data byte is non-zero, then this is stored in A and screen memory,
\ unless it is &55, in which a zero is stored in A and screen memory.
\
\ As it is copied, the source dash data byte is zeroed, so the macro effectively
\ moves a byte into screen memory, clearing it in the process.
\
\ Arguments:
\
\   I%                  The pixel byte number (0 to 39)
\
\   X                   The offset within the dash data of the data to be drawn
\                       on the screen (from &7F down, as the dash data lives at
\                       the end of each dash data block)
\
\   A                   The value stored in screen memory in the previous pixel
\                       byte (or the starting value if this is pixel byte 0)
\
\   (Q P)               The screen address of the leftmost character block to
\                       update (i.e. the screen address of the pixel byte to
\                       draw in the first character block on the line, so this
\                       is the address of the start of the horizontal line that
\                       the seqential macros draw)
\
\   (S R)               Contains (Q P) + &100, to be used instead of (Q P) for
\                       pixel bytes 32 to 39
\
\ ******************************************************************************

MACRO DRAW_BYTE I%

 LDY dashData+&80*I%,X  \ Set Y to the X-th byte of dash data block I%

 BEQ P%+10              \ If Y = 0, skip the next three instructions (i.e. jump
                        \ to the LDY #LO(8*I%) instruction to leave the value of
                        \ A alone)

                        \ Otherwise Y is non-zero, and we do the following in
                        \ the next three instructions:
                        \
                        \   * Zero the location in code block I% from which we
                        \     just read a byte
                        \
                        \   * Set A to the byte we just read from code block I%,
                        \     unless the value is &55, in which case set A = 0

 LDA #0                 \ Zero the X-th byte of dash data block I%
 STA dashData+&80*I%,X

 LDA zeroIfYIs55,Y      \ Set A to the Y-th byte from zeroIfYIs55
                        \
                        \ This sets A = Y, unless Y = &55, in which case it sets
                        \ Y = 0, so that's:
                        \
                        \   If Y = &55, set A = 0, otherwise set A = Y
                        \
                        \ The zeroIfYIs55 table exists just to enable us to do
                        \ this logic in one instruction

                        \ If Y = 0 above, this is where we jump to

 LDY #LO(8*I%)          \ Store A in character block I% in screen memory, as an
 IF I% < 32             \ offset from (Q P)
  STA (P),Y             \
 ELSE                   \ (S R) is used instead of (Q P) for pixel bytes 32 to
  STA (R),Y             \ 39, which saves us from having to increment Q to cross
 ENDIF                  \ the page boundary, as (S R) = (Q P) + &100

                        \ Fall through into the next DRAW_BYTE macro to draw
                        \ the next pixel byte along to the right, continuing the
                        \ horizontal line of pixels

ENDMACRO

\ ******************************************************************************
\
\       Name: DrawTrackBytes (Part 1 of 3)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the pixel bytes that make up the track view (0 to 15)
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ------------------------------------------------------------------------------
\
\ This routine draws pixel bytes 0 to 39, which draws a one-pixel high line in
\ the track view.
\
\ Note that this routine starts on a page boundary (DrawTrackBytes = &7C00).
\ This is important as it means the code can be modified at a specific address
\ using only the low byte of that address, as we know that high byte is the same
\ throughout the routine. This is why the staDrawByte and ldaDrawByte lookup
\ tables only need to store the low bytes of the addresses for instructions that
\ we need to modify.
\
\ ******************************************************************************

.DrawTrackBytes

 DRAW_BYTE 0            \ Draw pixel bytes 0 to 15
 DRAW_BYTE 1
 DRAW_BYTE 2
 DRAW_BYTE 3
 DRAW_BYTE 4
 DRAW_BYTE 5
 DRAW_BYTE 6
 DRAW_BYTE 7
 DRAW_BYTE 8
 DRAW_BYTE 9
 DRAW_BYTE 10
 DRAW_BYTE 11
 DRAW_BYTE 12
 DRAW_BYTE 13
 DRAW_BYTE 14
 DRAW_BYTE 15

 JMP byte1              \ Jump to part 2 to continue with pixel byte 16

\ ******************************************************************************
\
\       Name: DrawTrackView (Part 2 of 4)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the part of the track view that fits around the dashboard
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ------------------------------------------------------------------------------
\
\ This routine modifes the DrawTrackBytes routine so that it draws all the
\ remaining lines in the track view so they fit around the shape of the
\ dashboard.
\
\ ******************************************************************************

.view1

                        \ We get here with X = 44, as in part 1 we drew the
                        \ lines specified by dash data offsets 79 to 44
                        \
                        \ In the following loop, we draw the lines specified by
                        \ dash data offsets 43 to 28

 LDA #&60               \ Set A to the opcode for the RTS instruction

 STA byte3              \ Modify the following instruction in DrawTrackBytes
                        \ (part 3):
                        \
                        \   CPX #44 -> RTS
                        \
                        \ so that calls to DrawTrackLine and DrawTrackBytes from
                        \ now on will draw individual lines rather than looping
                        \ back to DrawTrackLine as they did for the lines above
                        \ the dashboard

.view2

 DEX                    \ Decrement the dash data block pointer to point to
                        \ the data for the next line

 LDY staDrawByte,X      \ Set Y to the X-th entry in staDrawByte, which contains
                        \ the low byte of the address of the STA (P),Y
                        \ instruction in the DRAW_BYTE macro given in the
                        \ table

 CPY view3+1            \ If the instruction at view3 has already been modified
 BEQ view5              \ to this address, jump to view5 to skip the following
                        \ modifications, as they have already been done on the
                        \ previous iteration of the loop

 LDA #&91               \ Set A to the opcode for the STA (P),Y instruction

.view3

 STA DrawTrackBytes+15  \ Modify the specified instruction back to STA (P),Y
                        \ (the address of the modified instruction is set by the
                        \ following, so the first time we run this line it has
                        \ no effect)

 STY view4+1            \ Modify the instruction at view4 to change the low byte
                        \ of the address to the X-th entry in staDrawByte, so
                        \ the instruction at view4 changes the STA (P),Y
                        \ instruction to an RTS in the DRAW_BYTE macro given
                        \ in staDrawByte

 STY view3+1            \ Modify the instruction at view3 to change the low byte
                        \ of the address to the X-th entry in staDrawByte, so
                        \ the instruction at view3 changes the RTS instruction
                        \ back to STA (P),Y when we loop back around

 LDA #&60               \ Set A to the opcode for the RTS instruction

.view4

 STA DrawTrackBytes     \ Modify the specified instruction to an RTS so the next
                        \ call to DrawTrackLine will return at that point (the
                        \ address of the modified instruction is set above)

 LDY ldaDrawByte,X      \ Set Y to the X-th entry in ldaDrawByte, which contains
                        \ the low byte of the LDA #0 instruction in the specific
                        \ DRAW_BYTE macro, as given in the table

 STY view6+1            \ Modify the instruction at view6 to change the low byte
                        \ of the address to the X-th entry in ldaDrawByte, so
                        \ the instruction at view6 changes so it jumps to the
                        \ LDA #0 instruction in the DRAW_BYTE macro specified in
                        \ the table

.view5

 JSR DrawTrackLine      \ Draw the left portion of this track line
                        \
                        \ This routine was modified above to return from the
                        \ subroutine at the STA instruction in the DRAW_BYTE
                        \ macro specified in the staDrawByte table, so this
                        \ returns the last pixel byte of this portion of the
                        \ line in A, i.e. the rightmost byte of the left portion
                        \ of the track line, where the line meets the left
                        \ border of the central part of the dashboard

 AND leftDashMask,X     \ We now merge the track byte in A with the left edge
 ORA leftDashPixels,X   \ of the dashboard, by masking out the pixels in A that
 STA (P),Y              \ are hidden by the dashboard (with AND leftDashMask),
                        \ and replacing them with the pixels from the left edge
                        \ of the dashboard (with ORA leftDashPixels)

 LDA dashRightEdge,X    \ Fetch the the track pixel byte that would be shown
                        \ along the right edge of the dashboard, i.e. the
                        \ leftmost byte of the right portion of the track line,
                        \ where the line meets the right border of the central
                        \ part of the dashboard

 AND rightDashMask,X    \ We now merge the track byte in A with the right edge
 ORA rightDashPixels,X  \ of the dashboard, by masking out the pixels in A that
                        \ are hidden by the dashboard (with AND rightDashMask),
                        \ and replacing them with the pixels from the left edge
                        \ of the dashboard (with ORA rightDashPixels)

 TAY                    \ Copy the pixel byte into Y, because the following JSR
                        \ jumps straight to the LDA #0 instruction within the
                        \ DRAW_BYTE macro, and at that point the macro expects
                        \ the pixel byte to be in Y rather than A

.view6

 JSR byte2              \ Draw the right portion of this track line
                        \
                        \ This JSR was modified above to jump to the LDA #0
                        \ instruction in the DRAW_BYTE macro specified in the
                        \ ldaDrawByte table

 CPX #28                \ Loop back to keep drawing lines, working our way down
 BNE view2              \ through the dash data from entry 44 down to entry 28

 JMP view7              \ Jump to part 3 to draw the rest of the track view from
                        \ offsets 27 to 3, modifying the code so it draws the
                        \ rest of the lines around the shape of the dashboard
                        \ and the shape of the tyres

\ ******************************************************************************
\
\       Name: DrawTrackBytes (Part 2 of 3)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the pixel bytes that make up the track view (16 to 39)
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ------------------------------------------------------------------------------
\
\ Note that the latter half of this routine, from .byte2 onwards, starts on a
\ page boundary (byte2 = &7E00). This is important as it means the code can be
\ modified at a specific address using only the low byte of that address, as we
\ know that high byte is the same throughout the routine. This is why the lookup
\ tables at staDrawByte and ldaDrawByte only need to store the low bytes of
\ the addresses for instructions that we need to modify.

\ ******************************************************************************

.byte1

 DRAW_BYTE 16           \ Draw pixel bytes 16 to 25
 DRAW_BYTE 17
 DRAW_BYTE 18
 DRAW_BYTE 19
 DRAW_BYTE 20
 DRAW_BYTE 21
 DRAW_BYTE 22
 DRAW_BYTE 23
 DRAW_BYTE 24
 DRAW_BYTE 25

.byte2

 DRAW_BYTE 26           \ Draw pixel bytes 26 to 39
 DRAW_BYTE 27
 DRAW_BYTE 28
 DRAW_BYTE 29
 DRAW_BYTE 30
 DRAW_BYTE 31
 DRAW_BYTE 32
 DRAW_BYTE 33
 DRAW_BYTE 34
 DRAW_BYTE 35
 DRAW_BYTE 36
 DRAW_BYTE 37
 DRAW_BYTE 38
 DRAW_BYTE 39

.byte3

 CPX #44                \ If X = 44, then we have just drawn the last pixel
 BEQ byte4              \ line above the top of the dashboard, so return from
                        \ the subroutine so we can modify the routine to draw
                        \ subsequent lines in two parts, to fit around the
                        \ dashboard (as byte4 contains an RTS)

 DEX                    \ Decrement the dash data pointer in X to move on to the
                        \ next pixel line

                        \ Fall through into DrawTrackLine to draw the next line

\ ******************************************************************************
\
\       Name: DrawTrackLine (Part 1 of 2)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw a pixel line across the screen in the track view, broken up
\             into bytes
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The offset within the dash data of the data to be drawn
\                       on the screen (from &7F down, as the dash data lives at
\                       the end of each dash data block)
\
\   (Q P)               The screen address of the leftmost pixel of the line
\                       above where we want to draw the horizontal pixel line
\
\   (S R)               Contains (Q P) + &100
\
\ ******************************************************************************

.DrawTrackLine

                        \ We start by incrementing (Q P) and (S R) to point to
                        \ the next pixel row down the screen

 LDY P                  \ Set Y = P + 1, which is the low byte of (Q P) + 1
 INY

 TYA                    \ If Y mod 8 = 0 then incrementing (Q P) will take us
 AND #&07               \ into the next character block (i.e. from pixel row 7
 BEQ prow1              \ to pixel row 8), so jump to prow1 to update the screen
                        \ addresses accordingly

 STY P                  \ Otherwise set the low bytes of (Q P) and (S R) to Y,
 STY R                  \ so this does:
                        \
                        \   (Q P) = (Q P) + 1
                        \
                        \   (S R) = (S R) + 1
                        \
                        \ so they point to the next pixel row down the screen

 JMP prow2              \ Jump to part 2 to draw this pixel row

.prow1

 TYA                    \ Set (Q P) = Y + &138
 CLC                    \
 ADC #&38               \ starting with the low bytes
 STA P
 STA R

 LDA Q                  \ And then the high bytes, so (Q P) points to the start
 ADC #&01               \ of the character block on the next character row
 STA Q                  \ (i.e. the next pixel row down)

 ADC #&01               \ Set (S R) = (Q P) + &100
 STA S

 JMP prow2              \ Jump to part 2 to draw this pixel row

\ ******************************************************************************
\
\       Name: DrawTrackBytes (Part 3 of 3)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Return from the subroutine
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ******************************************************************************

.byte4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawTrackView (Part 3 of 4)
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw the part of the track view that fits around the dashboard and
\             tyres
\  Deep dive: Drawing around the dashboard
\             Drawing the track view
\
\ ------------------------------------------------------------------------------
\
\ This routine modifes the DrawTrackBytes routine so that it draws all the
\ remaining lines in the track view so they fit around the shape of the
\ dashboard and the tyres.
\
\ ******************************************************************************

                        \ We get here with X = 28, as in part 1 we drew the
                        \ lines specified by dash data offsets 79 to 44, and in
                        \ part 2 we drew the lines specified by dash data
                        \ offsets 43 to 28
                        \
                        \ In the following loop, we draw the lines specified by
                        \ dash data offsets 27 to 3

.view7

 DEX                    \ Decrement the dash data block pointer to point to
                        \ the data for the next line

 LDY staDrawByte,X      \ Set Y to the X-th entry in staDrawByte, which contains
                        \ the low byte of the address of the STA (P),Y
                        \ instruction in the DRAW_BYTE macro given in the
                        \ table

 CPY view8+1            \ If the instruction at view8 has already been modified
 BEQ view10             \ to this address, jump to view10 to skip the following
                        \ modifications, as they have already been done on the
                        \ previous iteration of the loop

 LDA #&91               \ Set A to the opcode for the STA (P),Y instruction

.view8

 STA DrawTrackBytes+15  \ Modify the specified instruction back to STA (P),Y
                        \ (the address of the modified instruction is set by the
                        \ following, so the first time we run this line it has
                        \ no effect)

 STY view9+1            \ Modify the instruction at view9 to change the low byte
                        \ of the address to the X-th entry in staDrawByte, so
                        \ the instruction at view9 changes the STA (P),Y
                        \ instruction to an RTS in the DRAW_BYTE macro given
                        \ in staDrawByte

 STY view8+1            \ Modify the instruction at view8 to change the low byte
                        \ of the address to the X-th entry in staDrawByte, so
                        \ the instruction at view8 changes the RTS instruction
                        \ back to STA (P),Y when we loop back around

 LDA #&60               \ Set A to the opcode for the RTS instruction

.view9

 STA DrawTrackBytes     \ Modify the specified instruction to an RTS so the next
                        \ call to DrawTrackLine will return at that point (the
                        \ address of the modified instruction is set above)

.view10

                        \ The following code is normally run at the start of the
                        \ DrawTrackLine routine, but we are going to call the
                        \ DrawTrackBytes routine to draw our line instead, so
                        \ we can skip the bytes that are hidden behind the left
                        \ tyre
                        \
                        \ So we repeat the code here, which increments the
                        \ screen addresses in (Q P) and (S R) to point to the
                        \ next pixel row down the screen

 LDY P                  \ Set Y = P + 1, which is the low byte of (Q P) + 1
 INY

 TYA                    \ If Y mod 8 <> 0 then incrementing (Q P) will keep us
 AND #&07               \ within the current character block (i.e. the new pixel
 BNE view11             \ row will be 7 or less), so jump to view11 to store the
                        \ incremented values

                        \ Otherwise incrementing (Q P) will take us into the
                        \ next character block (i.e. from pixel row 7 to pixel
                        \ row 8), so we need to update the screen addresses to
                        \ jump to the next character row

 TYA                    \ Set (Q P) = Y + &138
 CLC                    \
 ADC #&38               \ starting with the low bytes
 STA P
 STA R

 LDA Q                  \ And then the high bytes, so (Q P) points to start of
 ADC #&01               \ the character block on the next character row (i.e.
 STA Q                  \ the next pixel row down)

 ADC #&01               \ Set (S R) = (Q P) + &100
 STA S

 BCC view12             \ Jump to view12 to skip the following

.view11

                        \ If we get here then incrementing the screen addresses
                        \ keeps us within the current character block, so we can
                        \ store the incremented addresses in (Q P) and (S R)

 STY P                  \ Set the low bytes of (Q P) and (S R) to Y, so this
 STY R                  \ does:
                        \
                        \   (Q P) = (Q P) + 1
                        \
                        \   (S R) = (S R) + 1
                        \
                        \ so they point to the next pixel row down the screen

.view12

                        \ The staDrawByteTyre table contains the low byte offset
                        \ of the address of the STA (P),Y instruction for the
                        \ track line, which we convert into an RTS when drawing
                        \ the track line up against the right tyre, so we stop
                        \ in time (see the code that modifies view14 and view15
                        \ below)
                        \
                        \ As the tyres are reflections of each other, we can
                        \ also use this value to calculate the starting point
                        \ for the line that starts at the left tyre, which is
                        \ what we do now

 LDA #LO(byte3)+3       \ Set A = LO(byte3) + 3 - staDrawByteTyre
 SEC                    \
 SBC staDrawByteTyre,X  \ There are 14 instances of the DRAW_BYTE macro between
                        \ byte2 and byte3, ranging from DRAW_BYTE 26 up to
                        \ DRAW_BYTE 39
                        \
                        \ This calculation converts the low address byte from
                        \ the staDrawByteTyre table so that instead of pointing
                        \ to the LDA #0 instruction in the n-th DRAW_BYTE macro,
                        \ it points to the LDA #0 instruction in the 14-n-th
                        \ macro, as an offset from byte2
                        \
                        \ This effectively takes the end point given in the
                        \ staDrawByteTyre table and returns the start point if
                        \ the range DRAW_BYTE 26 to DRAW_BYTE 39 were
                        \ "reflected" into DRAW_BYTE 39 to DRAW_BYTE 26
                        \
                        \ This enables us to calculate the offset of the start
                        \ point's macro for the left tyre, as an offset from
                        \ DrawTrackBytes, which is what we want

 STA view13+1           \ Modify the instruction at view13 to change the low
                        \ byte of the address to A, so the instruction at view13
                        \ changes so it jumps to the LDA #0 instruction in the
                        \ DRAW_BYTE macro specified in the table

 LDY tyreEdgeIndex,X    \ Set Y to the index of the mask and pixel bytes for the
                        \ tyre edge for this track line, so we can use it below
                        \ to fetch the correct entries from leftTyreMask and
                        \ leftTyrePixels

 LDA tyreRightEdge,X    \ Fetch the the track pixel byte that would be shown
                        \ along the right edge of the left tyre, i.e. the
                        \ leftmost byte of the track line, where the line meets
                        \ the left tyre

 AND leftTyreMask,Y     \ We now merge the track byte in A with the edge of the
 ORA leftTyrePixels,Y   \ left tyre, by masking out the pixels in A that are
                        \ hidden by the tyre (with AND leftTyreMask), and
                        \ replacing them with the pixels from the edge of the
                        \ left tyre (with ORA leftTyrePixels)

 TAY                    \ Copy the pixel byte into Y, because the following JSR
                        \ jumps straight to the LDA #0 instruction within the
                        \ DRAW_BYTE macro, and at that point the macro expects
                        \ the pixel byte to be in Y rather than A

.view13

 JSR DrawTrackBytes     \ Draw the left portion of this track line
                        \
                        \ This routine was modified above to return from the
                        \ subroutine at the STA instruction in the DRAW_BYTE
                        \ macro specified in the staDrawByte table, so this
                        \ returns the last pixel byte of this portion of the
                        \ line in A, i.e. the rightmost byte of the left portion
                        \ of the track line, where the line meets the left
                        \ border of the central part of the dashboard

 AND leftDashMask,X     \ We now merge the track byte in A with the left edge
 ORA leftDashPixels,X   \ of the dashboard, by masking out the pixels in A that
                        \ are hidden by the dashboard (with AND leftDashMask),
                        \ and replacing them with the pixels from the left edge
                        \ of the dashboard (with ORA leftDashPixels)

 STA (P),Y              \ Write the merged pixel byte into screen memory

 LDY staDrawByteTyre,X  \ Set Y to the X-th entry in staDrawByteTyre, which
                        \ contains the low byte of the address of the STA (P),Y
                        \ instruction in the DRAW_BYTE macro given in the
                        \ table

 CPY view14+1           \ If the instruction at view14 has already been modified
 BEQ view16             \ to this address, jump to view16 to skip the following
                        \ modifications, as they have already been done on the
                        \ previous iteration of the loop

 LDA #&91               \ Set A to the opcode for the STA (P),Y instruction

.view14

 STA byte2+15           \ Modify the specified instruction back to STA (P),Y
                        \ (the address of the modified instruction is set by the
                        \ following, so the first time we run this line it has
                        \ no effect)

 STY view15+1           \ Modify the instruction at view15 to change the low
                        \ byte of the address to the X-th entry in
                        \ staDrawByteTyre, so the instruction at view15 changes
                        \ the STA (P),Y instruction to an RTS in the DRAW_BYTE
                        \ macro given in staDrawByteTyre

 STY view14+1           \ Modify the instruction at view14 to change the low
                        \ byte of the address to the X-th entry in
                        \ staDrawByteTyre, so the instruction at view14 changes
                        \ the STA (P),Y instruction to an RTS in the DRAW_BYTE
                        \ macro given in staDrawByteTyre

 LDA #&60               \ Set A to the opcode for the RTS instruction

.view15

 STA byte2              \ Modify the specified instruction to an RTS so the next
                        \ call to byte2 will return at that point (the address
                        \ of the modified instruction is set above)

.view16

 LDY ldaDrawByte,X      \ Set Y to the X-th entry in ldaDrawByte, which contains
                        \ the low byte of the LDA #0 instruction in the specific
                        \ DRAW_BYTE macro, as given in the table

 STY view17+1           \ Modify the instruction at view17 to change the low
                        \ byte of the address to the X-th entry in ldaDrawByte,
                        \ so the instruction at view17 changes so it jumps to
                        \ the LDA #0 instruction in the DRAW_BYTE macro
                        \ specified in the table

 LDA dashRightEdge,X    \ Fetch the the track pixel byte that would be shown
                        \ along the right edge of the dashboard, i.e. the
                        \ leftmost byte of the right portion of the track line,
                        \ where the line meets the right border of the central
                        \ part of the dashboard

 AND rightDashMask,X    \ We now merge the track byte in A with the right edge
 ORA rightDashPixels,X  \ of the dashboard, by masking out the pixels in A that
                        \ are hidden by the dashboard (with AND rightDashMask),
                        \ and replacing them with the pixels from the left edge
                        \ of the dashboard (with ORA rightDashPixels)

 TAY                    \ Copy the pixel byte into Y, because the following JSR
                        \ jumps straight to the LDA #0 instruction within the
                        \ DRAW_BYTE macro, and at that point the macro expects
                        \ the pixel byte to be in Y rather than A

.view17

 JSR byte2              \ Draw the right portion of this track line
                        \
                        \ This JSR was modified above to jump to the LDA #0
                        \ instruction in the DRAW_BYTE macro specified in the
                        \ ldaDrawByte table

 STY U                  \ Store Y in U so we can retrieve it below

 LDY tyreEdgeIndex,X    \ Set Y to the index of the mask and pixel bytes for the
                        \ tyre edge for this track line, so we can use it to
                        \ fetch the correct entries from rightTyreMask and
                        \ rightTyrePixels

 AND rightTyreMask,Y    \ We now merge the track byte in A with the edge of the
 ORA rightTyrePixels,Y  \ right tyre, by masking out the pixels in A that are
                        \ hidden by the tyre (with AND rightTyreMask), and
                        \ replacing them with the pixels from the edge of the
                        \ right tyre (with ORA rightTyrePixels)

 LDY U                  \ Retrieve the value of Y that we stored above

 STA (R),Y              \ Write the merged pixel byte into screen memory, using
                        \ (S R) as the screen address as this is at the right
                        \ end of the track line

 CPX #3                 \ If we just drew the line at dash data entry 3, jump
 BEQ view18             \ to view18 to stop drawing track lines

 JMP view7              \ Loop back to keep drawing lines, working our way down
                        \ through the dash data from entry 27 down to entry 3

.view18

 JMP view19             \ Jump to part 4 to reverse our code modifications

\ ******************************************************************************
\
\       Name: DrawCarInMirror
\       Type: Subroutine
\   Category: Dashboard
\    Summary: Draw a car in a specified segment of one of the wing mirrors, or
\             clear a specified segment
\
\ ------------------------------------------------------------------------------
\
\ This routine draw white or black pixel lines in the specified mirror segment
\ (the latter with randomly added distortion), depending on this calculation:
\
\   * If N <= offset < A              then draw a black line (draw a car)
\
\   * If N > offset or offset >= A    then draw a white line (clear the mirror)
\
\ where offset runs from the startMirror value for this segment to the endMirror
\ value for this segment. In other words, when we draw a car, we draw it between
\ offset N and offset A - 1.
\
\ If A = 0, then we end up clearing the mirror segment, as the offset is always
\ greater or equal to zero.
\
\ So, for example, segment 2 has a startMirror of &B0 and endMirror of &BC, so
\ the offset will run from &BC down to &B0, one for each line we draw. If this
\ value is between A and N, as above, then we draw a black pixel line, otherwise
\ we clear that pixel line in the mirror. In other words, we can restrict the
\ size of the car that's drawn by setting A and N to values within the range for
\ this segment.
\
\ The mirror segments have the following addresses and offsets, for reference:
\
\   Mirror 0 base address = &7540 (left mirror, outer segment)
\   Centre point = &7540 + &B6 (&75F6)
\   Range = &7540 + &AA (&75EA) to &7540 + &C2 (&7602)
\
\   Mirror 1 base address = &7548 (left mirror, middle segment)
\   Centre point = &7548 + &B6 (&75FE)
\   Range = &7548 + &AC (&75F4) to &7548 + &C0 (&7608)
\
\   Mirror 2 base address = &7418 (left mirror, inner segment)
\   Range = &7418 + &B0 (&74C8) to &7418 + &BC (&74D4)
\   Centre point = &7418 + &B6 (&74CE)
\
\   Mirror 3 base address = &7530 (right mirror, inner segment)
\   Range = &7530 + &B0 (&75E0) to &7530 + &BC (&75EC)
\   Centre point = &7530 + &B6 (&75E6)
\
\   Mirror 4 base address = &7670 (right mirror, middle segment)
\   Range = &7670 + &AC (&771C) to &7670 + &C0 (&7730)
\   Centre point = &7670 + &B6 (&7726)
\
\   Mirror 5 base address = &7678 (right mirror, outer segment)
\   Range = &7678 + &AA (&7722) to &7678 + &C2 (&773A)
\   Centre point = &7678 + &B6 (&772E)
\
\ Arguments:
\
\   Y                   Mirror segment (0 to 5)
\
\                         * 0 = left mirror, outer segment
\                         * 1 = left mirror, middle segment
\                         * 2 = left mirror, inner segment
\                         * 3 = right mirror, inner segment
\                         * 4 = right mirror, middle segment
\                         * 5 = right mirror, outer segment
\
\   N                   Start offset within the segment for the car lines
\
\   A                   End offset within the segment for the car lines (or 0 to
\                       clear the mirror segment)
\
\ Returns:
\
\   Y                   Y is unchanged
\
\ ******************************************************************************

.DrawCarInMirror

 STA RR                 \ Store A in RR

 STY G                  \ Store Y in G so we can retrieve it before returning
                        \ from the subroutine

 LDA mirrorAddressHi,Y  \ Set (Q P) to the base screen address of this mirror
 STA Q                  \ segment (to which we add the following offsets to get
 LDA mirrorAddressLo,Y  \ the screen address for this particular segment)
 STA P

 LDA startMirror,Y      \ Set W to the offset of the first pixel byte in this
 STA W                  \ mirror segment

 LDA endMirror,Y        \ Set Y to the offset of the first pixel byte in this
 TAY                    \ mirror segment

.mirr1

                        \ We now work our way through the mirror segment pixel
                        \ bytes, going backwards from the end byte to the start
                        \ byte, either removing the car or drawing the car with
                        \ added random blurriness

 LDA #%11110000         \ Set A to the pixel byte containing four pixels of
                        \ colour 2 (white)

 CPY RR                 \ If Y >= RR, jump to mirr2 to draw a white pixel byte
 BCS mirr2

 CPY N                  \ If Y < N, jump to mirr2 to draw a white pixel byte
 BCC mirr2

                        \ If we get here then N <= Y < RR, so we draw a pixel
                        \ byte of black pixels to represent the car, with the
                        \ pixels randomised but tending to black when the
                        \ engine is on (if the engine is off, then all the
                        \ pixels are black, so this part simulates the mirror
                        \ shuddering when the engine is on)

 LDX VIA+&68            \ Read 6522 User VIA T1C-L timer 2 low-order counter
                        \ (SHEILA &68), which will be a pretty random figure

 AND &2000,X            \ There is game code at location &2000, so this randomly
                        \ switches some of the white pixels (colour 2) to black
                        \ (colour 0) in the pixel byte in A

 AND engineStatus       \ If our engine is off, then engineStatus is zero and
                        \ all the pixels are set to black, but if the engine is
                        \ on, engineStatus is &FF so this instruction has no
                        \ effect, leaving the image randomised

.mirr2

 STA (P),Y              \ Draw the pixel byte in A at screen address (Q P) + Y

 DEY                    \ Decrement Y to point to the pixel byte above

 BPL mirr3              \ If Y is positive then jump to mirr3 to move on to the
                        \ next pixel byte

 TYA                    \ If Y mod 8 < 7 then jump to mirr3 to move on to the
 AND #7                 \ next pixel byte
 CMP #7
 BCC mirr3

                        \ If we get here then we need to move up a character row
                        \ as we just moved Y past of the top of the current
                        \ character block

 LDA P                  \ Set (Q P) = (Q P) - &138
 SEC                    \
 SBC #&38               \ starting with the low bytes
 STA P

 LDA Q                  \ And then the high bytes, so (Q P) points to the end of
 SBC #&01               \ the character block on the previous character row
 STA Q                  \ (i.e. the next pixel row up)

.mirr3

 CPY W                  \ Loop back to draw the next pixel byte, until Y < W
 BCS mirr1

 LDY G                  \ Retrieve the value of Y that we stored in G, so that
                        \ Y is preserved through the call to the routine

 RTS                    \ Return from the subroutine

 EQUB &FF               \ This byte appears to be unused

\ ******************************************************************************
\
\ Save Revs.bin
\
\ For an explanation of the following, see the deep dive on "The jigsaw puzzle
\ binary"
\
\ ******************************************************************************

\ Step 1: Insert the dashboard image into the game code, split into 18 pieces

ORG &9000

INCBIN "1-source-files/images/dashboard.bin"

COPYBLOCK &9EF6, &9EF6+10, dashData25
COPYBLOCK &9ECD, &9EF6, dashData26
COPYBLOCK &9E99, &9ECD, dashData27
COPYBLOCK &9E61, &9E99, dashData28
COPYBLOCK &9E25, &9E61, dashData29
COPYBLOCK &9DE5, &9E25, dashData30
COPYBLOCK &9DA1, &9DE5, dashData31
COPYBLOCK &9D58, &9DA1, dashData32
COPYBLOCK &9D0B, &9D58, dashData33
COPYBLOCK &9CBE, &9D0B, dashData34
COPYBLOCK &9C72, &9CBE, dashData35
COPYBLOCK &9C38, &9C72, dashData36
COPYBLOCK &9C04, &9C38, dashData37
COPYBLOCK &9BD0, &9C04, dashData38
COPYBLOCK &9B9C, &9BD0, dashData39
COPYBLOCK &9B68, &9B9C, dashData40
COPYBLOCK &9B25, &9B68, dashData41
COPYBLOCK &9000, &9B25, dashData42

\ Step 2: Insert the code that runs in screen memory into the game code, split
\ into 26 pieces

COPYBLOCK &7FCC, &8000, dashData0
COPYBLOCK &7F98, &7FCC, dashData1
COPYBLOCK &7F64, &7F98, dashData2
COPYBLOCK &7F2A, &7F64, dashData3
COPYBLOCK &7EDE, &7F2A, dashData4
COPYBLOCK &7E91, &7EDE, dashData5
COPYBLOCK &7E44, &7E91, dashData6
COPYBLOCK &7DFB, &7E44, dashData7
COPYBLOCK &7DB7, &7DFB, dashData8
COPYBLOCK &7D77, &7DB7, dashData9
COPYBLOCK &7D3B, &7D77, dashData10
COPYBLOCK &7D03, &7D3B, dashData11
COPYBLOCK &7CCF, &7D03, dashData12
COPYBLOCK &7CA6, &7CCF, dashData13
COPYBLOCK &7C82, &7CA6, dashData14
COPYBLOCK &7C5E, &7C82, dashData15
COPYBLOCK &7C3A, &7C5E, dashData16
COPYBLOCK &7C16, &7C3A, dashData17
COPYBLOCK &7BF2, &7C16, dashData18
COPYBLOCK &7BCE, &7BF2, dashData19
COPYBLOCK &7BAA, &7BCE, dashData20
COPYBLOCK &7B86, &7BAA, dashData21
COPYBLOCK &7B62, &7B86, dashData22
COPYBLOCK &7B3E, &7B62, dashData23
COPYBLOCK &7B1A, &7B3E, dashData24
COPYBLOCK &7AF6+10, &7B1A, dashData25+10

\ 3: Split the game code into the parts that make up the game binary file and
\ pack them together in the correct order

COPYBLOCK &5FD0, &6700, &64D0
COPYBLOCK &0D00, &16DC, &5A80
COPYBLOCK &7000, &70DB, &1500
COPYBLOCK &70DB, &7725, &5300
COPYBLOCK &0B00, &0D00, &1300
COPYBLOCK &7900, &7A00, &1200
CLEAR &645C, &64D0

\ 4: Add workspace noise to match the final game binary

ORG &15DB

CLEAR &15DB, &16DC

 EQUB &20, &00, &63, &60, &A6, &03, &10, &03, &20, &CB, &2A, &20
 EQUB &84, &50, &E4, &4D, &D0, &F6, &A2, &16, &86, &45, &20, &D1
 EQUB &2A, &CA, &E0, &14, &B0, &F6, &A6, &4D, &20, &CB, &2A, &60
 EQUB &20, &0E, &2B, &A2, &F4, &20, &CC, &0B, &20, &0E, &2B, &A2
 EQUB &FD, &20, &CC, &0B, &A9, &14, &85, &42, &A9, &02, &20, &5D
 EQUB &2A, &A9, &15, &85, &42, &A9, &01, &A2, &F4, &20, &5F, &2A
 EQUB &A9, &16, &85, &42, &A9, &00, &A2, &FA, &20, &5F, &2A, &A6
 EQUB &45, &60, &C9, &05, &90, &F9, &BD, &8C, &01, &30, &F4, &FE
 EQUB &8C, &01, &60, &A2, &FD, &85, &37, &20, &45, &21, &A4, &42
 EQUB &A5, &8A, &99, &80, &03, &A5, &8B, &99, &98, &03, &20, &B1
 EQUB &2A, &20, &85, &22, &A4, &42, &B0, &2C, &38, &E9, &01, &30
 EQUB &27, &99, &B0, &03, &A5, &2B, &38, &E9, &09, &AA, &A5, &2A
 EQUB &CA, &F0, &0C, &10, &06, &4A, &E8, &D0, &FC, &F0, &04, &0A
 EQUB &CA, &D0, &FC, &99, &C8, &03, &B9, &8C, &01, &29, &70, &05
 EQUB &37, &4C, &AD, &2A, &A4, &42, &B9, &8C, &01, &09, &80, &99
 EQUB &8C, &01, &60, &A0, &25, &20, &A5, &0C, &A5, &7D, &85, &55
 EQUB &D0, &0E, &C4, &7C, &90, &0A, &C6, &68, &A5, &7C, &85, &41
 EQUB &A5, &42, &85, &67, &60, &86, &45, &BD, &3C, &01, &AA, &BD
 EQUB &8C, &01, &30, &35, &29, &0F, &85, &37, &BD, &80, &03, &38
 EQUB &E5, &0A, &85, &74, &BD, &98, &03, &E5, &0B, &10, &06, &C9
 EQUB &E0, &90, &1E, &B0, &04, &C9, &20, &B0, &18, &06, &74, &2A
 EQUB &06, &74, &2A, &18, &69

SAVE "3-assembled-output/Revs.bin", LOAD%, LOAD_END%
